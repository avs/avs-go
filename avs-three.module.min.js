import { Group as Group$1, Matrix4, Vector3, Points as Points$1, LineSegments as LineSegments$1, Mesh as Mesh$1, PointLight as PointLight$1, DirectionalLight as DirectionalLight$1, AmbientLight as AmbientLight$1, OrthographicCamera as OrthographicCamera$1, PerspectiveCamera as PerspectiveCamera$1, Scene as Scene$1, Matrix3, Vector2, Color, UniformsUtils, UniformsLib as UniformsLib$1, ShaderMaterial, Material, LessEqualDepth, AlwaysStencilFunc, KeepStencilOp, Loader, FileLoader, Vector4, Plane, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Box3, Sphere, Ray, Object3D, LoaderUtils, BufferGeometryLoader, SphereBufferGeometry, LoadingManager, ImageLoader, CubeTexture, Texture, Fog, FogExp2, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, Raycaster, WebGLRenderTarget, InstancedBufferAttribute, BufferGeometry, TOUCH, Quaternion, EventDispatcher, MOUSE, Spherical } from 'three';

var REVISION = '1';
var DEFAULT_VIEWER_WIDTH = 400;
var DEFAULT_VIEWER_HEIGHT = 400;
var RAYCASTER_LINE_PRECISION = 0.03;
var PickDepthEnum = {
		All : 0,    
		Closest : 1 
	};
var PickTypeEnum = {
		Ray : 0,
		Rectangle : 1
	};
var PickLevelEnum = {
		Cell : 0,    
		CellSet : 1,
		SceneNode : 2
	};
var CellTypeEnum = {
		Points : 1,
		Lines : 2,
		Triangles : 3,
		Quads : 4
	};

function Group() {

	Group$1.call( this );

}

Group.prototype = Object.assign( Object.create( Group$1.prototype ), {

	constructor: Group,

	toJSON: function( meta ) {

		const data = Group$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

} );

const _position = new Vector3();

function Points( geometry, material ) {

	Points$1.call( this, geometry, material );

}

Points.prototype = Object.assign( Object.create( Points$1.prototype ), {

	constructor: Points,

	toJSON: function( meta ) {

		const data = Points$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	},

    /*
     * GO-165
     * Custom point raycasting by projecting each point position through the camera
     * and expanding by the pixel size (either from material or attribute).
     * Instead of using the Raycaster directly and the Points threshold.
     */
	raycast: function ( raycaster, intersects ) {

		const attributes = this.geometry.attributes;
		const positions = attributes.position.array;

		let size = 0.5;
		if ( this.material.vertexSizes === undefined ) size = this.material.size / 2;

		let x, y;
		let minx, maxx, miny, maxy;

		// Assume non-indexed BufferGeometry
		for ( let i = 0, l = positions.length / 3; i < l; i ++ ) {

			_position.fromArray( positions, i * 3 );
			_position.applyMatrix4( this.matrixWorld );
			_position.project( raycaster.camera );

			x = ( ( _position.x + 1) / 2 ) * raycaster.scene.width;
			y = ( 1 - ( _position.y + 1) / 2 ) * raycaster.scene.height;
			
			if ( this.material.vertexSizes ) size = attributes.vsize.array[ i ] / 2;

			minx = x - size; maxx = x + size;
			miny = y - size; maxy = y + size;

			if ( raycaster.x >= minx && raycaster.x <= maxx && raycaster.y >= miny && raycaster.y <= maxy ) {

				intersects.push( {

					distance: null,
					distanceToRay: null,
					point: null,
					index: i,
					face: null,
					object: this

				} );

			}

		}

	}

} );

function LineSegments( geometry, material ) {

	LineSegments$1.call( this, geometry, material );

}

LineSegments.prototype = Object.assign( Object.create( LineSegments$1.prototype ), {

	constructor: LineSegments,

	toJSON: function( meta ) {

		const data = LineSegments$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

} );

const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceOrientationMatrix = new Matrix4();

const _instanceIntersects = [];

const _mesh = new Mesh$1();

function Mesh( geometry, material ) {

	Mesh$1.call( this, geometry, material );

}

Mesh.prototype = Object.assign( Object.create( Mesh$1.prototype ), {

	constructor: Mesh,

	updateMorphTargets: function () {

	},

	raycast: function ( raycaster, intersects ) {

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined || _mesh.geometry === undefined ) return;

		// No glyphs, raycast normally
		if ( ! _mesh.material.glyphs ) return Mesh$1.prototype.raycast.call( this, raycaster, intersects );

		const matrixWorld = this.matrixWorld;
		const offsetArray = _mesh.geometry.attributes.offset.array;
		const nInstances = offsetArray.length / 3;
		let vec3Index, scaleArray, orientationArray0, orientationArray1, orientationArray2;

		for ( let i = 0; i < nInstances; i ++ ) {

			vec3Index = 3 * i;

			// Calculate the world matrix for each instance

			if ( _mesh.material.vertexScales ) {

				scaleArray = _mesh.geometry.attributes.scale.array;
				_instanceLocalMatrix.makeScale( scaleArray[ vec3Index ], scaleArray[ vec3Index + 1 ], scaleArray[ vec3Index + 2 ] );

			} else {

				_instanceLocalMatrix.makeScale( _mesh.material.scale[ 0 ], _mesh.material.scale[ 1 ], _mesh.material.scale[ 2 ] );

			}

			if ( _mesh.material.vertexOrientations ) {

				orientationArray0 = _mesh.geometry.attributes.orientation0.array;
				orientationArray1 = _mesh.geometry.attributes.orientation1.array;
				orientationArray2 = _mesh.geometry.attributes.orientation2.array;

				_instanceOrientationMatrix.set( orientationArray0[ vec3Index     ], orientationArray1[ vec3Index     ], orientationArray2[ vec3Index ], 0,
				                                orientationArray0[ vec3Index + 1 ], orientationArray1[ vec3Index + 1 ], orientationArray2[ vec3Index + 1 ], 0,
				                                orientationArray0[ vec3Index + 2 ], orientationArray1[ vec3Index + 2 ], orientationArray2[ vec3Index + 2 ], 0,
				                                0, 0, 0, 1 );

				_instanceLocalMatrix.multiple( _instanceOrientationMatrix );

			}

			_instanceLocalMatrix.setPosition( offsetArray[ vec3Index ], offsetArray[ vec3Index + 1 ], offsetArray[ vec3Index + 2 ] );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// _mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// Process the result of raycast

			if ( _instanceIntersects.length > 0 ) {

				const intersect = _instanceIntersects[ 0 ];
				intersect.faceIndex = i;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	},

	toJSON: function( meta ) {

		const data = Mesh$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

} );

function PointLight( color, intensity, distance, decay ) {

	PointLight$1.call( this, color, intensity, distance, decay );

}

PointLight.prototype = Object.assign( Object.create( PointLight$1.prototype ), {

	constructor: PointLight,

	toJSON: function( meta ) {

		const data = PointLight$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.Light.toJSON()
		if ( this.color.getHex() === 16777215 ) data.object.color = undefined;
		if ( this.intensity === 1 ) data.object.intensity = undefined;
		data.object.shadow = undefined;

		return data;

	}

} );

function DirectionalLight( color, intensity ) {

	DirectionalLight$1.call( this, color, intensity );

}

DirectionalLight.prototype = Object.assign( Object.create( DirectionalLight$1.prototype ), {

	constructor: DirectionalLight,

	toJSON: function( meta ) {

		const data = DirectionalLight$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.Light.toJSON()
		if ( this.color.getHex() === 16777215 ) data.object.color = undefined;
		if ( this.intensity === 1 ) data.object.intensity = undefined;
		data.object.shadow = undefined;

		return data;

	}

} );

function AmbientLight( color, intensity ) {

	AmbientLight$1.call( this, color, intensity );

}

AmbientLight.prototype = Object.assign( Object.create( AmbientLight$1.prototype ), {

	constructor: AmbientLight,

	toJSON: function( meta ) {

		const data = AmbientLight$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.Light.toJSON()
		if ( this.color.getHex() === 16777215 ) data.object.color = undefined;
		if ( this.intensity === 1 ) data.object.intensity = undefined;

		return data;

	}

} );

function OrthographicCamera( left, right, top, bottom, near, far ) {

	OrthographicCamera$1.call( this, left, right, top, bottom, near, far );

}

OrthographicCamera.prototype = Object.assign( Object.create( OrthographicCamera$1.prototype ), {

	constructor: OrthographicCamera,

	toJSON: function( meta ) {

		const data = OrthographicCamera$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.OrthographicCamera.toJSON()
		if ( this.zoom === 1 ) data.object.zoom = undefined;
		if ( this.left === - 1 ) data.object.left = undefined;
		if ( this.right === 1 ) data.object.right = undefined;
		if ( this.top === 1 ) data.object.top = undefined;
		if ( this.bottom === - 1 ) data.object.bottom = undefined;
		if ( this.near === 0.1 ) data.object.near = undefined;
		if ( this.far === 2000 ) data.object.far = undefined;

		return data;

	}

} );

function PerspectiveCamera( fov, aspect, near, far ) {

	PerspectiveCamera$1.call( this, fov, aspect, near, far );

}

PerspectiveCamera.prototype = Object.assign( Object.create( PerspectiveCamera$1.prototype ), {

	constructor: PerspectiveCamera,

	toJSON: function( meta ) {

		const data = PerspectiveCamera$1.prototype.toJSON.call( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.PerspectiveCamera.toJSON()
		if ( this.fov === 50 ) data.object.fov = undefined;
		if ( this.zoom === 1 ) data.object.zoom = undefined;
		if ( this.near === 0.1 ) data.object.near = undefined;
		if ( this.far === 2000 ) data.object.far = undefined;
		if ( this.focus === 10 ) data.object.focus = undefined;
		if ( this.aspect === 1 ) data.object.aspect = undefined;
		if ( this.filmGauge === 35 ) data.object.filmGauge = undefined;
		if ( this.filmOffset === 0 ) data.object.filmOffset = undefined;

		return data;

	}

} );

class Scene extends Scene$1 {

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

}

const UniformsLib = {

	base: {

		pickState: { value: new Float32Array( 1 ) },
		startCell: { value: 0 },
		uscale: { value: new Vector3( 1, 1, 1 ) },
		uorientation: { value: new Matrix3() }

	},

	line: {

		linePattern: { value: 0xffff },
		resolution: { value: new Vector2( 1, 1 ) }

	},

	mesh: {

		stipple: { value: 0 },
		stippleColor: { value: new Color( 0x000000 ) },
		stipplePattern: { value: new Float32Array( 64 ) }

	}

};

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t}\n}";

var points_vert = "attribute float vsize;\nattribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float size;\nuniform float pickState[ 1 ];\nuniform float startCell;\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <color_vertex>\n\t#include <begin_vertex>\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n#else\n\ttransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n#else\n\ttransformed = uorientation * transformed;\n#endif\n\ttransformed += offset;\n#endif\n\t#include <project_vertex>\n#ifdef USE_SIZE\n\tgl_PointSize = vsize;\n#else\n\tgl_PointSize = size;\n#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var line_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float linePattern;\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#ifdef USE_PATTERN\nvarying float vPattern;\n#endif\nvarying float vDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tfloat pattern;\n#ifdef USE_PATTERN\n\tpattern = floor( vPattern );\n#else\n\tpattern = linePattern;\n#endif\n\tfloat shift = pow( 2.0, floor( mod( vDistance, 16.0 ) ) );\n\tif( mod( floor( pattern / shift ), 2.0 ) < 0.5 ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t}\n}";

var line_vert = "attribute vec3 otherPosition;\nattribute float pattern;\nattribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float pickState[ 1 ];\nuniform float startCell;\nuniform vec2 resolution;\n#ifdef USE_PATTERN\nvarying float vPattern;\n#endif\nvarying float vDistance;\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <color_vertex>\n\tvec3 transformed = vec3( position );\n\tvec3 otherTransformed = vec3( otherPosition );\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n\totherTransformed *= scale;\n#else\n\ttransformed *= uscale;\n\totherTransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n\totherTransformed = orientation * otherTransformed;\n#else\n\ttransformed = uorientation * transformed;\n\totherTransformed = uorientation * otherTransformed;\n#endif\n\ttransformed += offset;\n\totherTransformed += offset;\n#endif\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\tvec2 ndcPos1 = gl_Position.xy / gl_Position.w;\n\tvec4 other_Position = projectionMatrix * modelViewMatrix * vec4( otherTransformed, 1.0 );\n\tvec2 ndcPos2 = other_Position.xy / other_Position.w;\n\tfloat aspect = resolution.x / resolution.y;\n\tvec2 dir = ndcPos2 - ndcPos1;\n\tdir.x *= aspect;\n\tbool end = false;\n\tif ( dir.y < -EPSILON ) {\n\t\tend = true;\n\t}\n\telse if ( dir.y > EPSILON ) {\n\t\tend = false;\n\t}\n\telse if ( dir.x < -EPSILON ) {\n\t\tend = true;\n\t}\n\tvDistance = end ? 0.0 : length( dir * resolution ) / 2.0;\n#ifdef USE_PATTERN\n\tvPattern = pattern + 0.5;\n#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var thickline_vert = "attribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nattribute float instancePattern;\nattribute float instanceLinewidthStart;\nattribute float instanceLinewidthEnd;\nattribute float cellCount;\nattribute float cellOffset;\nuniform float pickState[ 1 ];\nuniform float startCell;\nuniform float linewidth;\nuniform vec2 resolution;\n#ifdef USE_PATTERN\nvarying float vPattern;\n#endif\nvarying float vDistance;\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount + cellOffset;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n#ifdef USE_COLOR\n\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart.xyz : instanceColorEnd.xyz;\n#endif\n#ifdef USE_PATTERN\n\tvPattern = instancePattern + 0.5;\n#endif\n#ifdef LINEWIDTH_SCALE\n\tvec4 start = vec4( instanceStart, 1.0 );\n\tvec4 end = vec4( instanceEnd, 1.0 );\n\tfloat widthFactor, avgWidthFactor;\n#ifdef USE_LINEWIDTH\n\twidthFactor = ( position.y < 0.5 ) ? instanceLinewidthStart : instanceLinewidthEnd;\n\tavgWidthFactor = ( instanceLinewidthStart + instanceLinewidthEnd ) / 2.0;\n#else\n\twidthFactor = avgWidthFactor = linewidth;\n#endif\n\tvec2 xyStart = start.xy;\n\tvec2 xyEnd = end.xy;\n\tvec2 dir = xyEnd - xyStart;\n\tdir = normalize( dir );\n\tvec2 offset = vec2( dir.y, -dir.x );\n\tif ( position.x < 0.5 ) offset *= -1.0;\n\toffset += ( position.y < 0.5 ) ? -dir * 0.3 : dir * 0.3;\n\toffset *= ( widthFactor * 0.5 );\n\tvec4 clip = ( position.y < 0.5 ) ? start : end;\n\tclip.x += offset.x;\n\tclip.y += offset.y;\n\tgl_Position = projectionMatrix * modelViewMatrix * clip;\n#else\n\tfloat aspect = resolution.x / resolution.y;\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\tvec4 clipStart = projectionMatrix * start;\n\tvec4 clipEnd = projectionMatrix * end;\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\tvec2 dir = ndcEnd - ndcStart;\n\tvec2 dirOrig = dir;\n\tdir.x *= aspect;\n\tdir = normalize( dir );\n\tvec2 offset = vec2( dir.y, -dir.x );\n\tdir.x /= aspect;\n\toffset.x /= aspect;\n\tif ( position.x < 0.5 ) offset *= -1.0;\n\tfloat widthFactor, avgWidthFactor;\n#ifdef USE_LINEWIDTH\n\twidthFactor = ( position.y < 0.5 ) ? instanceLinewidthStart : instanceLinewidthEnd;\n\tavgWidthFactor = ( instanceLinewidthStart + instanceLinewidthEnd ) / 2.0;\n#else\n\twidthFactor = avgWidthFactor = linewidth;\n#endif\n\toffset *= widthFactor;\n\tdir *= widthFactor;\n\toffset /= resolution.y;\n\tdir /= resolution.y;\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\toffset *= clip.w;\n\tclip.xy += offset;\n\tif ( clip.z > -1.0 ) {\n\t\tclip.z -= 5.0e-4;\n\t\tif ( clip.z < -1.0 ) clip.z = -1.0;\n\t}\n\tgl_Position = clip;\n\tvDistance = ( position.y < 0.5 ) ? 0.0 : ( length( dirOrig * resolution ) + 2.0 * length( dir * resolution ) ) / avgWidthFactor / 2.0;\n#endif\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag = "uniform float stipple;\nuniform vec3 stippleColor;\nuniform vec4 stipplePattern[ 16 ];\nuniform vec3 diffuse;\nuniform float opacity;\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tif ( stipple > 0.5 ) {\n\t\tvec2 coord = floor( mod( gl_FragCoord.xy, 32.0 ) );\n\t\tint index = int( floor( coord.x / 64.0 ) + ( coord.y / 2.0 ) );\n\t\tint comp = int( floor( coord.x / 16.0 ) + mod( coord.y , 2.0 ) * 2.0 );\n\t\tfor ( int i = 0; i < 16; i ++ ) {\n\t\t\tif ( i == index ) {\n\t\t\t\tfloat shift = pow( 2.0, floor( mod( gl_FragCoord.x, 16.0 ) ) );\n\t\t\t\tfloat shortPattern;\n\t\t\t\tif ( comp == 0 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].x;\n\t\t\t\t} else if ( comp == 1 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].y;\n\t\t\t\t} else if ( comp == 2 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].z;\n\t\t\t\t} else {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].w;\n\t\t\t\t}\n\t\t\t\tif ( mod( floor( shortPattern / shift ), 2.0 ) > 0.5 ) {\n\t\t\t\t\tdiffuseColor = vec4( stippleColor, opacity );\n\t\t\t\t} else if ( stipple < 1.5 ) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\t}\n}";

var meshbasic_vert = "attribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float pickState[ 1 ];\nuniform float startCell;\nvarying vec3 vPickColor;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n#else\n\ttransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n#else\n\ttransformed = uorientation * transformed;\n#endif\n\ttransformed += offset;\n#endif\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphong_frag = "uniform float ambientIntensity;\nuniform float diffuseIntensity;\nuniform float stipple;\nuniform vec3 stippleColor;\nuniform vec4 stipplePattern[ 16 ];\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\tif ( stipple > 0.5 ) {\n\t\tvec2 coord = floor( mod( gl_FragCoord.xy, 32.0 ) );\n\t\tint index = int( floor( coord.x / 64.0 ) + ( coord.y / 2.0 ) );\n\t\tint comp = int( floor( coord.x / 16.0 ) + mod( coord.y , 2.0 ) * 2.0 );\n\t\tfor ( int i = 0; i < 16; i ++ ) {\n\t\t\tif ( i == index ) {\n\t\t\t\tfloat shift = pow( 2.0, floor( mod( gl_FragCoord.x, 16.0 ) ) );\n\t\t\t\tfloat shortPattern;\n\t\t\t\tif ( comp == 0 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].x;\n\t\t\t\t} else if ( comp == 1 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].y;\n\t\t\t\t} else if ( comp == 2 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].z;\n\t\t\t\t} else {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].w;\n\t\t\t\t}\n\t\t\t\tif ( mod( floor( shortPattern / shift ), 2.0 ) > 0.5 ) {\n\t\t\t\t\tdiffuseColor = vec4( stippleColor, opacity );\n\t\t\t\t} else if ( stipple < 1.5 ) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\tvec3 outgoingLight = ( reflectedLight.directDiffuse * diffuseIntensity ) + ( reflectedLight.indirectDiffuse * ambientIntensity ) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\t}\n}";

var meshphong_vert = "attribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float pickState[ 1 ];\nuniform float startCell;\nvarying vec3 vPickColor;\n#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n#else\n\ttransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n#else\n\ttransformed = uorientation * transformed;\n#endif\n\ttransformed += offset;\n#endif\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const ShaderChunk = {
	points_frag: points_frag,
	points_vert: points_vert,
	line_frag: line_frag,
	line_vert: line_vert,
	thickline_vert: thickline_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert
};

const ShaderLib = {

	points: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.points,
			UniformsLib$1.fog,
			UniformsLib.base
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	line: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib.base,
			UniformsLib.line
		] ),

		vertexShader: ShaderChunk.line_vert,
		fragmentShader: ShaderChunk.line_frag

	},

	thick: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib.base,
			UniformsLib.line,
			{
				linewidth: { value: 1 }
			}
		] ),

		vertexShader: ShaderChunk.thickline_vert,
		fragmentShader: ShaderChunk.line_frag

	},

	basic: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib.base,
			UniformsLib.mesh
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	phong: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib$1.lights,
			UniformsLib.base,
			UniformsLib.mesh,
			{
				ambientIntensity: { value: 0.31 },
				diffuseIntensity: { value: 0.7 },
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x1f1f1f ) },
				shininess: { value: 63.8386159788056 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	}

};

// Base class from which all our materials inherit the picking and glyph functionality

function BaseMaterial( parameters ) {

	ShaderMaterial.call( this );

	Object.defineProperties( this, {
		pickState: {
			get: function () {
				return this.uniforms.pickState.value;
			},
			set: function ( value ) {
				this.uniforms.pickState.value = value;
			}
		},
		startCell: {
			get: function () {
				return this.uniforms.startCell.value;
			},
			set: function ( value ) {
				this.uniforms.startCell.value = value;
			}
		},
		glyphs: {
			get: function () {
				return this.defines.GLYPH;
			},
			set: function ( value ) {
				this.defines.GLYPH = value;
			}
		},
		scale: {
			get: function () {
				return this.uniforms.uscale.value;
			},
			set: function ( value ) {
				this.uniforms.uscale.value = value;
			}
		},
		vertexScales: {
			get: function () {
				return this.defines.USE_SCALE;
			},
			set: function ( value ) {
				this.defines.USE_SCALE = value;
			}
		},
		orientation: {
			get: function () {
				return this.uniforms.uorientation.value;
			},
			set: function ( value ) {
				this.uniforms.uorientation.value = value;
			}
		},
		vertexOrientations: {
			get: function () {
				return this.defines.USE_ORIENTATION;
			},
			set: function ( value ) {
				this.defines.USE_ORIENTATION = value;
			}
		}
	} );

	this.color = new Color( 0xffffff );

	// Setting this populates THREE.UniformsLib.fog from the material
	this.fog = true;

	this.setValues( parameters );

}

BaseMaterial.prototype = Object.create( ShaderMaterial.prototype );
BaseMaterial.prototype.constructor = BaseMaterial;

BaseMaterial.prototype.copy = function ( source ) {

	ShaderMaterial.prototype.copy.call( this, source );

	this.color.copy( source.color );

	return this;

};

BaseMaterial.prototype.toJSON = function ( meta ) {

	const data = Material.prototype.toJSON.call( this, meta );

	// Override THREE.Material.toJSON()
	if ( this.depthFunc === LessEqualDepth ) data.depthFunc = undefined;
	if ( this.depthTest === true ) data.depthTest = undefined;
	if ( this.depthWrite === true ) data.depthWrite = undefined;
	if ( this.stencilWrite === false ) data.stencilWrite = undefined;
	if ( this.stencilWriteMask === 0xff ) data.stencilWriteMask = undefined;
	if ( this.stencilFunc === AlwaysStencilFunc ) data.stencilFunc = undefined;
	if ( this.stencilRef === 0 ) data.stencilRef = undefined;
	if ( this.stencilFuncMask === 0xff ) data.stencilFuncMask = undefined;
	if ( this.stencilFail === KeepStencilOp ) data.stencilFail = undefined;
	if ( this.stencilZFail === KeepStencilOp ) data.stencilZFail = undefined;
	if ( this.stencilZPass === KeepStencilOp ) data.stencilZPass = undefined;

	if ( this.vertexScales ) data.vertexScales = true;
	if ( this.vertexOrientations ) data.vertexOrientations = true;

	return data;

};

BaseMaterial.prototype.equals = function ( material ) {

	if ( material.color.getHex() !== this.color.getHex() ) {

		return false;

	}

	if ( material.opacity !== this.opacity ) {

		return false;

	}

	if ( material.transparent !== this.transparent ) {

		return false;

	}

	if ( material.side !== this.side ) {

		return false;

	}

	if ( material.vertexColors !== this.vertexColors ) {

		return false;

	}

	return true;

};

function PointsMaterial( parameters ) {

	BaseMaterial.call( this, {

		uniforms: UniformsUtils.clone( ShaderLib.points.uniforms ),

		vertexShader: ShaderLib.points.vertexShader,

		fragmentShader: ShaderLib.points.fragmentShader

	} );

	this.map = null;

	this.size = 1;

	Object.defineProperties( this, {
		vertexSizes: {
			get: function () {
				return this.defines.USE_SIZE;
			},
			set: function ( value ) {
				this.defines.USE_SIZE = value;
			}
		}
	} );

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( BaseMaterial.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

// Setting this populates THREE.UniformsLib.points from the material
PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	BaseMaterial.prototype.copy.call( this, source );

	this.map = source.map;

	this.size = source.size;

	return this;

};

PointsMaterial.prototype.toJSON = function ( meta ) {

	const data = BaseMaterial.prototype.toJSON.call( this, meta );

	data.type = 'PointsMaterial';

	if ( this.vertexSizes ) data.vertexSizes = true;

	return data;

};

PointsMaterial.prototype.equals = function ( material ) {

	if ( BaseMaterial.prototype.equals.call( this, material ) === false ) {

		return false;

	}

	if ( material.isPointsMaterial ) {

		return true;

	}

	return false;

};

function MeshBasicMaterial( parameters ) {

	BaseMaterial.call( this, {

		uniforms: UniformsUtils.clone( ShaderLib.basic.uniforms ),

		vertexShader: ShaderLib.basic.vertexShader,

		fragmentShader: ShaderLib.basic.fragmentShader

	} );

	this.map = null;

	Object.defineProperties( this, {
		stipple: {
			get: function () {
				return this.uniforms.stipple.value;
			},
			set: function ( value ) {
				this.uniforms.stipple.value = value;
			}
		},
		stippleColor: {
			get: function () {
				return this.uniforms.stippleColor.value;
			},
			set: function ( value ) {
				this.uniforms.stippleColor.value = value;
			}
		},
		stipplePattern: {
			get: function () {
				return this.uniforms.stipplePattern.value;
			},
			set: function ( value ) {
				this.uniforms.stipplePattern.value = value;
			}
		}
	} );

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( BaseMaterial.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

// Setting this populates THREE.UniformsLib.common from the material
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	BaseMaterial.prototype.copy.call( this, source );

	this.map = source.map;

	return this;

};

MeshBasicMaterial.prototype.toJSON = function ( meta ) {

	const data = BaseMaterial.prototype.toJSON.call( this, meta );

	data.type = 'MeshBasicMaterial';

	if ( this.stipple !== 0 ) data.stipple = this.stipple;
	if ( this.stippleColor.getHex() !== 0x000000 ) data.stippleColor = this.stippleColor.getHex();
	if ( JSON.stringify( this.stipplePattern ) !== JSON.stringify( new Float32Array( 64 ) ) ) data.stipplePattern = Array.prototype.slice.call( this.stipplePattern );

	return data;

};

MeshBasicMaterial.prototype.equals = function ( material ) {

	if ( BaseMaterial.prototype.equals.call( this, material ) === false ) {

		return false;

	}

	if ( material.isMeshBasicMaterial || material.isMeshPhongMaterial ) {

		return true;

	}

	return false;

};

function MeshPhongMaterial( parameters ) {

	MeshBasicMaterial.call( this, {

		uniforms: UniformsUtils.clone( ShaderLib.phong.uniforms ),

		vertexShader: ShaderLib.phong.vertexShader,

		fragmentShader: ShaderLib.phong.fragmentShader

	} );

	this.specular = new Color( 0x1f1f1f );
	this.shininess = 63.8386159788056;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;

	// Setting this populates THREE.UniformsLib.lights from the material
	this.lights = true;

	Object.defineProperties( this, {
		ambientIntensity: {
			get: function () {
				return this.uniforms.ambientIntensity.value;
			},
			set: function ( value ) {
				this.uniforms.ambientIntensity.value = value;
			}
		},
		diffuseIntensity: {
			get: function () {
				return this.uniforms.diffuseIntensity.value;
			},
			set: function ( value ) {
				this.uniforms.diffuseIntensity.value = value;
			}
		}
	} );

	this.setValues( parameters );

}

MeshPhongMaterial.prototype = Object.create( MeshBasicMaterial.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

// Setting these populates the common, specular and shininess uniforms from the material
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.isMeshBasicMaterial = false;

MeshPhongMaterial.prototype.copy = function ( source ) {

	MeshBasicMaterial.prototype.copy.call( this, source );

	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	return this;

};

MeshPhongMaterial.prototype.toJSON = function ( meta ) {

	const data = MeshBasicMaterial.prototype.toJSON.call( this, meta );

	data.type = 'MeshPhongMaterial';

	if ( this.ambientIntensity !== 0.31 ) data.ambientIntensity = this.ambientIntensity;
	if ( this.diffuseIntensity !== 0.7 ) data.diffuseIntensity = this.diffuseIntensity;

	// Override THREE.Material.toJSON()
	if ( this.specular.getHex() === 0x1f1f1f ) data.specular = undefined;
	if ( this.shininess === 63.8386159788056 ) data.shininess = undefined;

	return data;

};

MeshPhongMaterial.prototype.equals = function ( material ) {

	if ( MeshBasicMaterial.prototype.equals.call( this, material ) === false ) {

		return false;

	}

	if ( material.isMeshPhongMaterial ) {

		if ( material.ambientIntensity !== this.ambientIntensity ) {

			return false;

		}

		if ( material.diffuseIntensity !== this.diffuseIntensity ) {

			return false;

		}

		if ( material.specular.getHex() !== this.specular.getHex() ) {

			return false;

		}

		if ( material.shininess !== this.shininess ) {

			return false;

		}

		return true;

	}

	return false;

};

function LineMaterial( parameters ) {

	BaseMaterial.call( this, {

		uniforms: UniformsUtils.clone( ShaderLib.line.uniforms ),

		vertexShader: ShaderLib.line.vertexShader,

		fragmentShader: ShaderLib.line.fragmentShader

	} );

	Object.defineProperties( this, {
		pattern: {
			get: function () {
				return this.uniforms.linePattern.value;
			},
			set: function ( value ) {
				this.uniforms.linePattern.value = value;
			}
		},
		vertexPatterns: {
			get: function () {
				return this.defines.USE_PATTERN;
			},
			set: function ( value ) {
				this.defines.USE_PATTERN = value;
			}
		},
		resolution: {
			get: function () {
				return this.uniforms.resolution.value;
			},
			set: function ( value ) {
				this.uniforms.resolution.value = value;
			}
		}
	} );

	this.setValues( parameters );

}

LineMaterial.prototype = Object.create( BaseMaterial.prototype );
LineMaterial.prototype.constructor = LineMaterial;

// Setting this populates the diffuse and opacity uniforms from the material
LineMaterial.prototype.isLineBasicMaterial = true;

LineMaterial.prototype.toJSON = function ( meta ) {

	const data = BaseMaterial.prototype.toJSON.call( this, meta );

	data.type = 'LineMaterial';

	if ( this.pattern !== 0xffff ) data.pattern = this.pattern;
	if ( this.vertexPatterns ) data.vertexPatterns = true;

	return data;

};

LineMaterial.prototype.equals = function ( material ) {

	if ( BaseMaterial.prototype.equals.call( this, material ) === false ) {

		return false;

	}

	if ( material.isLineBasicMaterial ) {

		return true;

	}

	return false;

};

function ThickLineMaterial( parameters ) {

	LineMaterial.call( this, {

		uniforms: UniformsUtils.clone( ShaderLib.thick.uniforms ),

		vertexShader: ShaderLib.thick.vertexShader,

		fragmentShader: ShaderLib.thick.fragmentShader

	} );

	Object.defineProperties( this, {
		linewidth: {
			get: function () {
				return this.uniforms.linewidth.value;
			},
			set: function ( value ) {
				this.uniforms.linewidth.value = value;
			}
		},
		vertexLinewidths: {
			get: function () {
				return this.defines.USE_LINEWIDTH;
			},
			set: function ( value ) {
				this.defines.USE_LINEWIDTH = value;
			}
		},
		linewidthScale: {
			get: function () {
				return this.defines.LINEWIDTH_SCALE;
			},
			set: function ( value ) {
				this.defines.LINEWIDTH_SCALE = value;
			}
		}
	} );

	this.setValues( parameters );

}

ThickLineMaterial.prototype = Object.create( LineMaterial.prototype );
ThickLineMaterial.prototype.constructor = ThickLineMaterial;

ThickLineMaterial.prototype.isThickLineMaterial = true;

ThickLineMaterial.prototype.toJSON = function ( meta ) {

	const data = LineMaterial.prototype.toJSON.call( this, meta );

	data.type = 'ThickLineMaterial';

	if ( this.vertexLinewidths ) data.vertexLinewidths = true;
	if ( this.linewidthScale ) data.linewidthScale = true;

	return data;

};

ThickLineMaterial.prototype.equals = function ( material ) {

	if ( LineMaterial.prototype.equals.call( this, material ) === false ) {

		return false;

	}

	if ( material.isThickLineMaterial ) {

		if ( material.vertexLinewidths !== this.vertexLinewidths ) {

			return false;

		}

		return true;

	}

	return false;

};

var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	PointsMaterial: PointsMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	LineMaterial: LineMaterial,
	ThickLineMaterial: ThickLineMaterial
});

/**
 *  AVS Revision 1.0: Original extracted from Three.js revision 82.
 *  AVS Revision 1.1: Load clipping planes
 *  AVS Revision 1.2: Load shaders from our library
 *  AVS Revision 1.3: Update to Three.js revision 85
 *  AVS Revision 1.4: Load our own PointsMaterial and LineMaterial
 *  AVS Revision 1.5: Update to Three.js revision 86
 *  AVS Revision 1.6: Support vertex line patterns in LineMaterial
 *  AVS Revision 1.7: Load our own MeshBasicMaterial and MeshPhongMaterial with stipple pattern
 *  AVS Revision 1.8: Support line widths in ThickLineMaterial
 *  AVS Revision 1.9: Update to Three.js revision 87
 *  AVS Revision 1.10: Update to Three.js revision 89
 *  AVS Revision 1.13: Use local FileLoader - reverted
 *  AVS Revision 1.14: Update to Three.js revision 92
 *  AVS Revision 1.15: Update to Three.js revision 96
 *  AVS Revision 1.16: Add MeshPhongMaterial ambient and diffuse parameters
 *  AVS Revision 1.17: Update to Three.js revision 98
 *  AVS Revision 1.18: Support vertex sizes in PointsMaterial
 *  AVS Revision 1.19: Update to Three.js revision 102
 *  AVS Revision 1.20: Update to Three.js revision 108
 *  AVS Revision 1.21: Update to Three.js revision 109
 *  AVS Revision 1.22: Update to Three.js revision 115
 *  AVS Revision 1.23: Rename MeshPhongMaterial ambient and diffuse intensity parameters
 *  AVS Revision 1.24: Update to three.js r117
 *  AVS Revision 1.25: Update to three.js r118
 *  AVS Revision 1.26: Update to three.js r121
 *  AVS Revision 1.27: Update to three.js r122
 *  AVS Revision 1.28: Add linewidthScale to ThickLineMaterial
 */

function MaterialLoader( manager ) {

	Loader.call( this, manager );

	this.textures = {};

}

MaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				// AVS revision 1.0.  Message changed to use AVS.Three source
				console.warn( 'AVS.Three.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for BaseMaterial

		if ( json.glyphs !== undefined ) material.glyphs = json.glyphs;
		if ( json.vertexScales !== undefined ) material.vertexScales = json.vertexScales;
		// material.scale handled above
		if ( json.vertexOrientations !== undefined ) material.vertexOrientations = json.vertexOrientations;
		if ( json.orientation !== undefined ) material.orientation = json.orientation;

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
		if ( json.vertexSizes !== undefined ) material.vertexSizes = json.vertexSizes;

		// for LineMaterial / ThickLineMaterial

		if ( json.pattern !== undefined ) material.pattern = json.pattern;
		if ( json.vertexPatterns !== undefined ) material.vertexPatterns = json.vertexPatterns;

		// for ThickLineMaterial

		if ( json.vertexLinewidths !== undefined ) material.vertexLinewidths = json.vertexLinewidths;
		// material.linewidth handled above
		if ( json.linewidthScale !== undefined ) material.linewidthScale = json.linewidthScale;

		// for MeshBasicMaterial / MeshPhongMaterial

		if ( json.stipple !== undefined ) material.stipple = json.stipple;
		if ( json.stippleColor !== undefined && material.stippleColor !== undefined ) material.stippleColor.setHex( json.stippleColor );
		if ( json.stipplePattern !== undefined ) material.stipplePattern = json.stipplePattern;

		// for MeshPhongMaterial

		if ( json.ambientIntensity !== undefined ) material.ambientIntensity = json.ambientIntensity;
		if ( json.diffuseIntensity !== undefined ) material.diffuseIntensity = json.diffuseIntensity;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );

		// AVS revision 1.1.  Load clipping planes
		if ( json.clippingPlanes !== undefined ) {
				
			material.clippingPlanes = [];
				
			for ( let i = 0, l = json.clippingPlanes.length; i < l; i ++ ) {
					
				const thisPlane = json.clippingPlanes[ i ];
				const newPlane = new Plane( new Vector3 ( thisPlane.normal[0], thisPlane.normal[1], thisPlane.normal[2] ), thisPlane.constant );

				material.clippingPlanes.push( newPlane );
			}

		}

		return material;

	},

	setTextures: function ( value ) {

		this.textures = value;
		return this;

	}

} );

function LinePatternBufferGeometryLoader( bufferGeometryLoader ) {

	this.bufferGeometryLoader = bufferGeometryLoader;

}

Object.assign( LinePatternBufferGeometryLoader.prototype, {

	parse: function ( json ) {

		const geometry = this.bufferGeometryLoader.parse( json );

		const position = geometry.attributes.position;

		if ( position !== undefined ) {

			const otherPosition = new Float32BufferAttribute( position.array.length, 3 );

			const nLines = position.array.length / 6;

			for ( let i = 0, l = nLines; i < l; i ++ ) {

				otherPosition.array[ i*6 + 0 ] = position.array[ i*6 + 3 ];
				otherPosition.array[ i*6 + 1 ] = position.array[ i*6 + 4 ];
				otherPosition.array[ i*6 + 2 ] = position.array[ i*6 + 5 ];

				otherPosition.array[ i*6 + 3 ] = position.array[ i*6 + 0 ];
				otherPosition.array[ i*6 + 4 ] = position.array[ i*6 + 1 ];
				otherPosition.array[ i*6 + 5 ] = position.array[ i*6 + 2 ];

			}

			geometry.setAttribute( 'otherPosition', otherPosition );

		}

		return geometry;

	}

} );

function ThickLineSegmentsBufferGeometry () {

	InstancedBufferGeometry.call( this );

	this.type = 'ThickLineSegmentsBufferGeometry';

	// Quad representing a single line segment
	var positions = [ 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0 ];
	this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	// Cell offsets used for picking
	var cellOffsets = [ 0, 0, 0, 1, 1, 1 ];
	this.setAttribute( 'cellOffset', new Float32BufferAttribute( cellOffsets, 1 ) );

}

ThickLineSegmentsBufferGeometry.prototype = Object.assign( Object.create( InstancedBufferGeometry.prototype ), {

	constructor: ThickLineSegmentsBufferGeometry,

	isThickLineSegmentsBufferGeometry: true,

	applyMatrix4: function ( matrix ) {

		var start = this.attributes.instanceStart;
		var end = this.attributes.instanceEnd;

		if ( start !== undefined ) {

			start.applyMatrix4( matrix );

			end.applyMatrix4( matrix );

			start.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	setPositions: function ( array ) {

		var lineSegments;

		if ( array instanceof Float32Array ) {

			lineSegments = array;

		} else if ( Array.isArray( array ) ) {

			lineSegments = new Float32Array( array );

		}

		var instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz

		this.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz
		this.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz

		//

		this.computeBoundingBox();
		this.computeBoundingSphere();

		return this;

	},

	setColors: function ( array ) {

		var colors;

		if ( array instanceof Float32Array ) {

			colors = array;

		} else if ( Array.isArray( array ) ) {

			colors = new Float32Array( array );

		}

		var instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb

		this.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb
		this.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb

		return this;

	},

	setPatterns: function ( array ) {

		var patterns;

		if ( array instanceof Float32Array ) {

			patterns = array;

		} else if ( Array.isArray( array ) ) {

			patterns = new Float32Array( array );

		}
	
		var instancePatternBuffer = new InstancedInterleavedBuffer( patterns, 2, 1 );

		this.setAttribute( 'instancePattern', new InterleavedBufferAttribute( instancePatternBuffer, 1, 0 ) );

		return this;

	},

	setLinewidths: function ( array ) {

		var linewidths;

		if ( array instanceof Float32Array ) {

			linewidths = array;

		} else if ( Array.isArray( array ) ) {

			linewidths = new Float32Array( array );

		}

		const instanceLinewidthBuffer = new InstancedInterleavedBuffer( linewidths, 2, 1 );

		this.setAttribute( 'instanceLinewidthStart', new InterleavedBufferAttribute( instanceLinewidthBuffer, 1, 0 ) );
		this.setAttribute( 'instanceLinewidthEnd', new InterleavedBufferAttribute( instanceLinewidthBuffer, 1, 1 ) );

		return this;

	},

	computeBoundingBox: function () {

		var box = new Box3();

		return function computeBoundingBox() {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			var start = this.attributes.instanceStart;
			var end = this.attributes.instanceEnd;

			if ( start !== undefined && end !== undefined ) {

				this.boundingBox.setFromBufferAttribute( start );

				box.setFromBufferAttribute( end );

				this.boundingBox.union( box );

			}

		};

	}(),

	computeBoundingSphere: function () {

		var vector = new Vector3();

		return function computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			if ( this.boundingBox === null ) {

				this.computeBoundingBox();

			}

			var start = this.attributes.instanceStart;
			var end = this.attributes.instanceEnd;

			if ( start !== undefined && end !== undefined ) {

				var center = this.boundingSphere.center;

				this.boundingBox.getCenter( center );

				var maxRadiusSq = 0;

				for ( var i = 0, il = start.count; i < il; i ++ ) {

					vector.fromBufferAttribute( start, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					vector.fromBufferAttribute( end, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'AVS.Three.ThickLineSegmentsBufferGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );

				}

			}

		};

	}(),

	applyMatrix: function ( matrix ) {

		console.warn( 'AVS.Three.ThickLineSegmentsBufferGeometry: applyMatrix() has been renamed to applyMatrix4().' );

		return this.applyMatrix4( matrix );

	}

} );

function ThickLineBufferGeometryLoader () {

}

ThickLineBufferGeometryLoader.prototype = {

	parse: function ( json ) {

		const geometry = new ThickLineSegmentsBufferGeometry();

		const attributes = json.data.attributes;

		if ( attributes.position !== undefined ) {

			geometry.setPositions( attributes.position.array );

		}

		if ( attributes.color !== undefined ) {

			geometry.setColors( attributes.color.array );

		}

		if ( attributes.pattern !== undefined ) {

			geometry.setPatterns( attributes.pattern.array );

		}

		if ( attributes.linewidth !== undefined ) {

			geometry.setLinewidths( attributes.linewidth.array );

		}

		return geometry;

	}

};

// Thick lines are drawn as a mesh but raycast like lines

function ThickLineSegments ( geometry, material ) {

	Mesh.call( this, geometry, material );

	this.type = 'ThickLineSegments';

}

ThickLineSegments.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: ThickLineSegments,

	isThickLineSegments: true,

	// From THREE.Line.raycast()
	raycast: ( function () {

		const inverseMatrix = new Matrix4();
		const ray = new Ray();
		const sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
			sphere.radius += threshold;

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();

			const attributes = geometry.attributes;
			const positionsStart = attributes.positionStart.array;

			for ( let i = 0, l = positionsStart.length / 3 - 1; i < l; i += 2 ) {

				vStart.fromArray( positionsStart, 3 * i );
				vEnd.fromArray( positionsStart, 3 * i + 3 );

				const distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		};

	}() )

} );

function BillboardText() {
	
	Object3D.call( this );
	
	this.type = 'BillboardText';
	
	this.text = 'Label';
	this.fontSize = 16;
	this.fontStyle = 'normal';
	this.fontWeight = 'normal';
	this.textDecoration = '';
	this.fontFamily = 'sans-serif';
	this.color = new Color( 0x000000 );
	this.textAlign = '';
	this.transform = '';
	this.transformOrigin = '';
	
	this.div = document.createElement('div');
	this.div.style.position = 'absolute';
	this.div.style.whiteSpace = 'nowrap';
	
	this.scene = null;
	this.scaleFactor = 1.0;
	
	this.updateStyle();
	
}
	
BillboardText.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
	constructor: BillboardText,

	isBillboardText: true,

	addToScene: function( scene ) {
		
		if ( this.scene === null ) {

			this.scene = scene;
		
			scene.labels.push( this );
			scene.div.appendChild( this.div );
		
			this.updateStyle();

		}
		
	},

	updateStyle: function() {
		
		this.div.innerHTML = this.text;
		this.div.style.fontStyle = this.fontStyle;
		this.div.style.fontWeight = this.fontWeight;
		this.div.style.textDecoration = this.textDecoration;
		this.div.style.color = '#' + this.color.getHexString();
		this.div.style.textAlign = this.textAlign;
		this.div.style.transform = this.transform;
		this.div.style.transformOrigin = this.transformOrigin;
		
		// Only quote font names containing whitespace.
		// CSS requires generic names like sans-serif not be quoted.
		if ( /\s/.test( this.fontFamily ) ) {

			this.div.style.fontFamily = '\'' + this.fontFamily + '\'';

		} else {

			this.div.style.fontFamily = this.fontFamily;

		}

		if ( this.textScale ) {

			this.div.style.fontSize = ( this.fontSize * this.scaleFactor ) + 'pt';

		} else {

			this.div.style.fontSize = this.fontSize + 'pt';

		}

	},

	updatePosition: function() {
		
		this.updateMatrixWorld();
		const vector = new Vector3().setFromMatrixPosition( this.matrixWorld );
		vector.project( this.scene.camera );
		
		vector.x = ( (vector.x + 1) / 2 ) * this.scene.width;
		vector.y = ( 1 - (vector.y + 1) / 2 ) * this.scene.height;
		
		this.x = vector.x;
		this.y = vector.y;

		this.div.style.left = vector.x + 'px';
		this.div.style.top = vector.y + 'px';
		
		if ( this.textScale ) {

			this.div.style.fontSize = ( this.fontSize * this.scaleFactor ) + 'pt';

		}

	}
	
} );

/**
 *  AVS Revision 1.0: Original extracted from Three.js revision 82.
 *  AVS Revision 1.1: Added arguments to pass in arrays of existing items
 *  AVS Revision 1.2: Update to Three.js revision 85
 *  AVS Revision 1.3: Added arguments to parse function for streaming
 *  AVS Revision 1.6: Added DataMapLoader 
 *  AVS Revision 1.7: Added CellTypeEnum
 *  AVS Revision 1.8: Load BillboardText class
 *  AVS Revision 1.9: Added LinePatternBufferGeometryLoader
 *  AVS Revision 1.10: Added ThickLineBufferGeometryLoader
 *  AVS Revision 1.11: Added ThickLineSegments
 *  AVS Revision 1.12: Update to Three.js revision 87
 *  AVS Revision 1.13: Update to Three.js revision 89
 *  AVS Revision 1.14: Use local FileLoader - reverted
 *  AVS Revision 1.15: Update to Three.js revision 92
 *  AVS Revision 1.16: Update to Three.js revision 93
 *  AVS Revision 1.17: Comment out unneeded code
 *  AVS Revision 1.18: Remove DataMapLoader until later date
 *  AVS Revision 1.19: Update to Three.js revision 96
 *  AVS Revision 1.20: Remove need for metadata - reverted
 *  AVS Revision 1.21: Deal with selectionInfo being returned and no object - reverted
 *  AVS Revision 1.22: Update to Three.js revision 98
 *  AVS Revision 1.23: Update to Three.js revision 102
 *  AVS Revision 1.24: Update to Three.js revision 108
 *  AVS Revision 1.25: Update to Three.js revision 112
 *  AVS Revision 1.26: Update to Three.js revision 115
 *  AVS Revision 1.27: Restore loading of SphereBufferGeometry for VRML skybox
 *  AVS Revision 1.28: Update to Three.js revision 116
 *  AVS Revision 1.29: Update to Three.js revision 118
 *  AVS Revision 1.30: Update to Three.js revision 121
 */

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

        const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
        loader.load( url, function ( text ) {

            let json = null;

            try {

                json = JSON.parse( text );

            } catch ( error ) {

                if ( onError !== undefined ) onError( error );

                // AVS revision 1.1.  Message changed to use AVS.Three source
                console.error( 'AVS.Three.ObjectLoader: Can\'t parse ' + url + '.', error.message );

                return;

            }

            const metadata = json.metadata;

            if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

                // AVS revision 1.1.  Message changed to use AVS.Three source
                console.error( 'AVS.Three.ObjectLoader: Can\'t load ' + url );
                return;

            }

            scope.parse( json, onLoad );

        }, onProgress, onError );

    }

    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    // AVS Revision 1.6:  Added DataMapLoader 
    parse( json, onLoad, existingImages, existingTextures, existingMaterials, existingGeometries/*, existingDataMaps*/, parentGroup ) {

/* AVS Revision 1.17.  Comment out unneeded code
		const shapes = this.parseShape( json.shapes ); 
*/
        const geometries = this.parseGeometries( json.geometries, /*shapes,*/ existingGeometries );

        const images = this.parseImages( json.images, function () {

            if ( onLoad !== undefined ) onLoad( object );

        }, existingImages );

        const textures  = this.parseTextures( json.textures, images, existingTextures );
        const materials = this.parseMaterials( json.materials, textures, existingMaterials );
//        const dataMaps = this.parseDataMaps( json.dataMaps, geometries, existingDataMaps );

        const object = this.parseObject( json.object, geometries, materials/*, dataMaps*/ );

        if ( parentGroup !== undefined ) {

            parentGroup.add( object );

            object.saveVisible = object.visible;
            object.visible = false;

        }

/* AVS Revision 1.17.  Comment out unneeded code
        if ( json.animations ) {

            object.animations = this.parseAnimations( json.animations );

        }
*/
        if ( json.images === undefined || json.images.length === 0 ) {

            if ( onLoad !== undefined ) onLoad( object );

        }

        return object;

    }

/* AVS Revision 1.17.  Comment out unneeded code
	parseShape( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}
*/
    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseGeometries( json, /*shapes,*/ existingGeometries ) {

        let geometries = {};

        if ( existingGeometries !== undefined ) {

            geometries = existingGeometries;

        }

        if ( json !== undefined ) {

            const bufferGeometryLoader = new BufferGeometryLoader();

			// AVS revision 1.9.  Added LinePatternBufferGeometryLoader
			const linePatternBufferGeometryLoader = new LinePatternBufferGeometryLoader( bufferGeometryLoader );

			// AVS revision 1.10.  Added ThickLineBufferGeometryLoader
			const thickLineBufferGeometryLoader = new ThickLineBufferGeometryLoader();

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                let geometry;
                const data = json[ i ];

                switch ( data.type ) {

/* AVS Revision 1.17.  Comment out unneeded code
                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.width,
                            data.height,
                            data.widthSegments,
                            data.heightSegments
                        );

                        break;

                    case 'BoxGeometry':
                    case 'BoxBufferGeometry':
                    case 'CubeGeometry': // backwards compatible

                        geometry = new Geometries[ data.type ](
                            data.width,
                            data.height,
                            data.depth,
                            data.widthSegments,
                            data.heightSegments,
                            data.depthSegments
                        );

                        break;

                    case 'CircleGeometry':
                    case 'CircleBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.radius,
                            data.segments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'CylinderGeometry':
                    case 'CylinderBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.radiusTop,
                            data.radiusBottom,
                            data.height,
                            data.radialSegments,
                            data.heightSegments,
                            data.openEnded,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'ConeGeometry':
                    case 'ConeBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.radius,
                            data.height,
                            data.radialSegments,
                            data.heightSegments,
                            data.openEnded,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'SphereGeometry':
*/
                    case 'SphereBufferGeometry':

                        geometry = new SphereBufferGeometry(
                            data.radius,
                            data.widthSegments,
                            data.heightSegments,
                            data.phiStart,
                            data.phiLength,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;
/* AVS Revision 1.17.  Comment out unneeded code
					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.radius,
                            data.detail
                        );

                        break;

                    case 'RingGeometry':
                    case 'RingBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.innerRadius,
                            data.outerRadius,
                            data.thetaSegments,
                            data.phiSegments,
                            data.thetaStart,
                            data.thetaLength
                        );

                        break;

                    case 'TorusGeometry':
                    case 'TorusBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.radius,
                            data.tube,
                            data.radialSegments,
                            data.tubularSegments,
                            data.arc
                        );

                        break;

                    case 'TorusKnotGeometry':
                    case 'TorusKnotBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.radius,
                            data.tube,
                            data.tubularSegments,
                            data.radialSegments,
                            data.p,
                            data.q
                        );

                        break;

					case 'TubeGeometry':
					case 'TubeBufferGeometry':

						// This only works for built-in curves (e.g. CatmullRomCurve3).
						// User defined curves or instances of CurvePath will not be deserialized.
						geometry = new Geometries[ data.type ](
							new Curves[ data.path.type ]().fromJSON( data.path ),
							data.tubularSegments,
							data.radius,
							data.radialSegments,
							data.closed
						);

						break;

                    case 'LatheGeometry':
                    case 'LatheBufferGeometry':

                        geometry = new Geometries[ data.type ](
                            data.points,
                            data.segments,
                            data.phiStart,
                            data.phiLength
                        );

                        break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.curveSegments
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						const extrudePath = data.options.extrudePath;

						if ( extrudePath !== undefined ) {

							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.options
						);

						break;
*/
                    case 'BufferGeometry':
					case 'InstancedBufferGeometry':

                        geometry = bufferGeometryLoader.parse( data );

                        break;

					// AVS revision 1.9.  Added LinePatternBufferGeometryLoader
					case 'LinePatternBufferGeometry':

						geometry = linePatternBufferGeometryLoader.parse( data );

						break;

					// AVS revision 1.10.  Added ThickLineBufferGeometryLoader
					case 'ThickLineBufferGeometry':

						geometry = thickLineBufferGeometryLoader.parse( data );

						break;

/* AVS Revision 1.17.  Comment out unneeded code
                    case 'Geometry':

						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

                        break;
*/
                    default:

                        // AVS revision 1.0.  Message changed to use AVS.Three source
                        console.warn( 'AVS.Three.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

                        continue;

                }

                geometry.uuid = data.uuid;

                if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

                geometries[ data.uuid ] = geometry;

            }

        }

        return geometries;

    }

    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseMaterials( json, textures, existingMaterials ) {

		const cache = {}; // MultiMaterial
        let materials = {};

        if ( existingMaterials !== undefined ) {

            materials = existingMaterials;

        }

        if ( json !== undefined ) {

            const loader = new MaterialLoader();
            loader.setTextures( textures );

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                const data = json[ i ];

                if ( data.type === 'MultiMaterial' ) {

                    // Deprecated

                    const array = [];

                    for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

                    }

                    materials[ data.uuid ] = array;

                } else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

                }

            }

        }

        return materials;

    }

    // AVS Revision 1.6:  Added DataMapLoader 
/*
    parseDataMaps( json, existingGeometries, existingDataMaps ) {

        let dataMaps = {};

        if ( existingDataMaps !== undefined ) {

            dataMaps = existingDataMaps;

        }

        if ( json !== undefined ) {

            const loader = new DataMapLoader();

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                const data = json[ i ];

                dataMaps[ data.uuid ] = loader.parse( data, existingGeometries );

            }

        }

        return dataMaps;

    }
*/
/* AVS Revision 1.17.  Comment out unneeded code
    parseAnimations( json ) {

        const animations = [];

        for ( let i = 0; i < json.length; i ++ ) {

			const data = json[ i ];

			const clip = AnimationClip.parse( data );

			if ( data.uuid !== undefined ) clip.uuid = data.uuid;

            animations.push( clip );

        }

        return animations;

    }
*/
    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseImages( json, onLoad, existingImages ) {

        const scope = this;
        let images = {};

        if ( existingImages !== undefined ) {

            images = existingImages;

        }

		let loader;

        function loadImage( url ) {

            scope.manager.itemStart( url );

            return loader.load( url, function () {

                scope.manager.itemEnd( url );

            }, undefined, function () {

                scope.manager.itemError( url );
                scope.manager.itemEnd( url );

            } );

        }

        if ( json !== undefined && json.length > 0 ) {

            const manager = new LoadingManager( onLoad );

            loader = new ImageLoader( manager );
            loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

                const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

						images[ image.uuid ].push( loadImage( path ) );

					}

				} else {

					// load single image

					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

            }

        }

        return images;

    }

    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseTextures( json, images, existingTextures ) {

        function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

            // AVS revision 1.0.  Message changed to use AVS.Three source
            console.warn( 'AVS.Three.ObjectLoader.parseTextures: Constant should be in numeric form.', value );

            return type[ value ];

        }

        let textures = {};

        if ( existingTextures !== undefined ) {

            textures = existingTextures;

        }

        if ( json !== undefined ) {

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                const data = json[ i ];

                if ( data.image === undefined ) {

                    // AVS revision 1.0.  Message changed to use AVS.Three source
                    console.warn( 'AVS.Three.ObjectLoader: No "image" specified for', data.uuid );

                }

                if ( images[ data.image ] === undefined ) {

                    // AVS revision 1.0.  Message changed to use AVS.Three source
                    console.warn( 'AVS.Three.ObjectLoader: Undefined image', data.image );

                }

				let texture;

				if ( Array.isArray( images[ data.image ] ) ) {

					texture = new CubeTexture( images[ data.image ] );

				} else {

					texture = new Texture( images[ data.image ] );

				}

                texture.needsUpdate = true;

                texture.uuid = data.uuid;

                if ( data.name !== undefined ) texture.name = data.name;

                if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

                if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
                if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

                if ( data.wrap !== undefined ) {

                    texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
                    texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

                }

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

                if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
                if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
                if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

                if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

                textures[ data.uuid ] = texture;

            }

        }

        return textures;

    }

    // AVS Revision 1.6:  Added DataMapLoader 
    parseObject( data, geometries, materials/*, dataMaps*/ ) {

        let object;

        function getGeometry( name ) {

            if ( geometries[ name ] === undefined ) {

                // AVS revision 1.0.  Message changed to use AVS.Three source
                console.warn( 'AVS.Three.ObjectLoader: Undefined geometry', name );

            }

            return geometries[ name ];

        }

//	        function onBeforeRenderCellSet() {
//	            evaluateDataMapsCellSet( this );
//	        }
//
//	        function onBeforeRenderCell() {
//	            evaluateDataMapsCell( this );
//	        }

//	        function evaluateDataMapsCellSet( object ) {   	
//	            var dataMapSourceValues = object.userData.cellSetData.dataMapSourceValues;
//	            if (dataMapSourceValues !== undefined) {
//	                // Color map
//	                var inputValue = dataMapSourceValues.color;
//	                if ( inputValue !== undefined ) {
//	                    var curDataMap = findDataMap(object, 'color'); 
//	                    if (curDataMap !== undefined && curDataMap.isDirty()) {
//	                        var newColor = curDataMap.evaluate( inputValue );
//	                        if (newColor !== undefined) {
//	                            object.material.color = newColor;
//	                            object.material.colorWrite = true;
//	                        }
//	                        else {
//	                            object.material.colorWrite = false;
//	                        }
//	                    }
//	                }
//	            }
//	        }
//
//	        function evaluateDataMapsCell( object ) {   	
//	            var dataMapSourceValues = object.userData.cellData.dataMapSourceValues;
//	            if (dataMapSourceValues !== undefined) {
//	                // Color map
//	                var inputValues = dataMapSourceValues.color;
//	                if ( inputValues !== undefined ) {
//	                    var curDataMap = findDataMap(object, 'color'); 
//	                    if (curDataMap !== undefined && curDataMap.isDirty()) {
//	                        var count = null;
//	                        var length = null;
//	    	                var attribute = object.geometry.attributes.color;
//
//	                        for (var i = 0; i < inputValues.length; i++) {
//	                            var newColor = curDataMap.evaluate( inputValues[i] );
//			    	                
//	                            if (object.cellType === AVS.Three.CellTypeEnum.Points) { // THREE.Points
//	                                count = 3*i;
//	                                length = 1;
//	                            } else if (object.cellType === AVS.Three.CellTypeEnum.Lines) { // THREE.LineSegments
//	                                count = 6*i;
//	                                length = 2;
//	                            } else if (object.cellType === AVS.Three.CellTypeEnum.Triangles) { // THREE.Mesh tris
//	                                count = 9*i;
//	                                length = 3;
//	                            } else { // THREE.Mesh quads
//	                                count = 9*i; 
//	                                length = 3;
//	                            }
//
//	                           	if (newColor !== undefined) {
//	                           		for (var k = 0; k < length; k++) {
//		                                attribute.array[count++] = newColor.r;
//		                                attribute.array[count++] = newColor.g;
//		                                attribute.array[count++] = newColor.b;
//	                            	}
//	                           	}
//	                            else {
//	                           		for (var k = 0; k < length; k++) {
//		                                attribute.array[count++] = undefined;
//		                                attribute.array[count++] = undefined;
//		                                attribute.array[count++] = undefined;
//	                            	}
//	                            }
//	                       	}
//	                        attribute.needsUpdate = true;
//	                    }
//	                }
//	            }
//	        }
/*
        function findDataMap( object, type ) {
            var curObject = object.parent;
            while( curObject !== undefined && curObject !== null) {
                if (curObject.userData !== undefined && curObject.userData.dataMaps !== undefined) {
                    var objectDataMaps = curObject.userData.dataMaps;
                    if (objectDataMaps.hasOwnProperty( type )) {
                        return objectDataMaps[type]; 
                    }
                }
                curObject = curObject.parent;	
            }
        }
*/
        function getMaterial( name ) {

            if ( name === undefined ) return undefined;

            if ( Array.isArray( name ) ) {

                const array = [];

                for ( let i = 0, l = name.length; i < l; i ++ ) {

                    const uuid = name[ i ];

                    if ( materials[ uuid ] === undefined ) {

                        // AVS revision 1.0.  Message changed to use AVS.Three source
                        console.warn( 'AVS.Three.ObjectLoader: Undefined material', uuid );

                    }

                    array.push( materials[ uuid ] );

                }

                return array;

            }

            if ( materials[ name ] === undefined ) {

                // AVS revision 1.0.  Message changed to use AVS.Three source
                console.warn( 'AVS.Three.ObjectLoader: Undefined material', name );

            }

            return materials[ name ];

        }
/*
        function getDataMap( name ) {

            if ( dataMaps[ name ] === undefined ) {

                console.warn( 'AVS.Three.ObjectLoader: Undefined dataMap', name );

            }

            return dataMaps[ name ];

        }
*/
		let geometry, material;

        switch ( data.type ) {

            case 'Scene':

                object = new Scene();

                if ( data.background !== undefined ) {

                    if ( Number.isInteger( data.background ) ) {

                        object.background = new Color( data.background );

                    }

                }

                if ( data.fog !== undefined ) {

                    if ( data.fog.type === 'Fog' ) {

                        object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

                    } else if ( data.fog.type === 'FogExp2' ) {

                        object.fog = new FogExp2( data.fog.color, data.fog.density );

                    }

                }

                break;

            case 'PerspectiveCamera':

                object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

                if ( data.focus !== undefined ) object.focus = data.focus;
                if ( data.zoom !== undefined ) object.zoom = data.zoom;
                if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
                if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
                if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

                break;

            case 'OrthographicCamera':

                object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

                break;

            case 'AmbientLight':

                object = new AmbientLight( data.color, data.intensity );

                break;

            case 'DirectionalLight':

                object = new DirectionalLight( data.color, data.intensity );

                break;

            case 'PointLight':

                object = new PointLight( data.color, data.intensity, data.distance, data.decay );

                break;

/* AVS Revision 1.17.  Comment out unneeded code
            case 'RectAreaLight':

                object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

                break;

            case 'SpotLight':

                object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

                break;

            case 'HemisphereLight':

                object = new HemisphereLight( data.color, data.groundColor, data.intensity );

                break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

            case 'SkinnedMesh':

                console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );
*/
            case 'Mesh':
            case 'Quads':

                geometry = getGeometry( data.geometry );
                material = getMaterial( data.material );

                object = new Mesh( geometry, material );

                // AVS revision 1.7.  Add CellTypeEnum
                object.cellType = ( data.type === 'Quads' ) ? CellTypeEnum.Quads : CellTypeEnum.Triangles;

                break;

/* AVS Revision 1.17.  Comment out unneeded code
			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );

				break;

            case 'LOD':

                object = new LOD();

                break;

            case 'Line':

                object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

                break;

            case 'LineLoop':

                object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

                break;
*/
            case 'LineSegments':

                object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

                // AVS revision 1.7.  Add CellTypeEnum
                object.cellType = CellTypeEnum.Lines;

                break;

			case 'ThickLineSegments':

				object = new ThickLineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				object.cellType = CellTypeEnum.Quads;

				break;

            case 'PointCloud':
            case 'Points':

                object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

                // AVS revision 1.7.  Add CellTypeEnum
                object.cellType = CellTypeEnum.Points;

                break;

/* AVS Revision 1.17.  Comment out unneeded code
            case 'Sprite':

                object = new Sprite( getMaterial( data.material ) );

                break;
*/
            case 'Group':

                object = new Group();

                // Need to save a list of all the data maps on the top level object
//                if (data.name === 'Scenes') {
//                    object.dataMaps = dataMaps;
//                }

                break;

			// AVS revision 1.8.  Load BillboardText class
			case 'BillboardText':
                	
               	object = new BillboardText();

               	if ( data.text !== undefined ) object.text = data.text;
               	if ( data.fontSize !== undefined ) object.fontSize = data.fontSize;
               	if ( data.fontStyle !== undefined ) object.fontStyle = data.fontStyle;
               	if ( data.fontWeight !== undefined ) object.fontWeight = data.fontWeight;
               	if ( data.fontFamily !== undefined ) object.fontFamily = data.fontFamily;
               	if ( data.textDecoration !== undefined ) object.textDecoration = data.textDecoration;
               	if ( data.color !== undefined ) object.color.setHex( data.color );
               	if ( data.textAlign !== undefined ) object.textAlign = data.textAlign;
               	if ( data.transform !== undefined ) object.transform = data.transform;
               	if ( data.transformOrigin !== undefined ) object.transformOrigin = data.transformOrigin;
				if ( data.textScale !== undefined ) object.textScale = data.textScale;
                	
               	break;
                    
            default:

                object = new Object3D();

        }

        object.uuid = data.uuid;

        if ( data.name !== undefined ) object.name = data.name;

        if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

        } else {

            if ( data.position !== undefined ) object.position.fromArray( data.position );
            if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
            if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
            if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

        }

        if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
        if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

        if ( data.shadow ) {

            if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
            if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
            if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
            if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

        }

        if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
        if ( data.userData !== undefined ) {

            object.userData = data.userData;

            // Check for any datamaps and resolve references
//            if ( object.userData.dataMaps !== undefined) {
//                var objectDataMaps = object.userData.dataMaps;
//                for (var key in objectDataMaps){
//                    if (objectDataMaps.hasOwnProperty(key)) {
//                        objectDataMaps[key] = getDataMap( objectDataMaps[key] );
//                    }
//                }
//            }

            // Set a callback to evaluate the datamaps just prior to rendering
//	            if ( object.userData.cellSetData !== undefined && object.userData.cellSetData.dataMapSourceValues != undefined) {
//	                object.onBeforeRender = onBeforeRenderCellSet;
//	            }
//	            else if ( object.userData.cellData !== undefined && object.userData.cellData.dataMapSourceValues != undefined) {
//	                object.onBeforeRender = onBeforeRenderCell;
//	            }
        }
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

        if ( data.children !== undefined ) {

			const children = data.children;

			for ( let  i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials/*, dataMaps*/ ) );

            }

        }

/* AVS Revision 1.17.  Comment out unneeded code
        if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

            const levels = data.levels;

            for ( let l = 0; l < levels.length; l ++ ) {

                const level = levels[ l ];
                const child = object.getObjectByProperty( 'uuid', level.object );

                if ( child !== undefined ) {

                    object.addLevel( child, level.distance );

                }

            }

        }
*/
        return object;

	}

	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'AVS.Three.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

function Viewer(id, pixelRatio) {
    //private
    var viewerID = id;
    this.getID = function(){
        return viewerID;
    };

    this.pixelRatio = pixelRatio !== undefined ? pixelRatio : window.devicePixelRatio;

    // Top-level container
    this.container = document.createElement('div');
    this.container.style.position = 'relative';
	this.container.style.outline = 'none';
    this.container.style.overflow = 'hidden';
	this.container.style.width = '100%';
	this.container.style.height = '100%';
	this.container.id = 'avsthreeDiv';

	this.domElement = this.container;

    this.scenes = [];
    this.currentScene = null;

	this.objectLoader = new ObjectLoader();

    this.startCell = 1;

    // Interactivity
    this.interactors = [];

    // Selection
    this.raycaster = new Raycaster();
    this.raycaster.params.Line.threshold = 0.001;

	this.validPick = false;

	this.pickType = PickTypeEnum.Ray;
    this.pickDepth = PickDepthEnum.Closest;

	this.pickRayX = 0;
	this.pickRayY = 0;

	this.pickRectangleLeft = 0;
	this.pickRectangleTop = 0;
	this.pickRectangleRight = 1;
	this.pickRectangleBottom = 1;

	this.selectionListeners = [];
	this.intersects = [];
	this.highlightList = [];

	this.updateHighlight = false;
	this.highlightColor = new Color( 0xff0000 );

    this.updatePicking = false;
	this.pickState = new Float32Array( 1 ); // array so we can keep a reference to it

	this.resolution = new Vector2();

	// Streaming
	this.loading = false;
	this.firstChunk = false;

}

Viewer.prototype = {

    constructor: Viewer,

	setWebGLRenderer: function( renderer ) {

		this.renderer = renderer;

		this.renderer.autoClear = false;
		this.renderer.setPixelRatio( this.pixelRatio );
		this.renderer.localClippingEnabled = true;
		this.renderer.sortObjects = false;

	},
/*
    getDataMaps: function() {
        return this.dataMaps;
    },
*/
    updateSize: function() {

		var width = this.container.clientWidth;
		var height = this.container.clientHeight;

		if ( width === this.width && height === this.height ) {

			return;

		}

        this.width = width;
        this.height = height;

		this.pixelWidth = Math.floor( width * this.pixelRatio );
		this.pixelHeight = Math.floor( height * this.pixelRatio );

		this.updateHighlight = true;
        this.updatePicking = true;
		this.validPick = false;

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            this.updateSceneSize( this.scenes[ i ] );

        }

		this.updateInteractors();

    },

    updateSceneSize: function( scene ) {

		scene.x = scene.userData.x !== undefined ? Math.floor( this.width * scene.userData.x ) : 0;
		scene.width = scene.origWidth = scene.userData.width !== undefined ? Math.floor( this.width * scene.userData.width ) : this.width;

		scene.y = scene.userData.y !== undefined ? Math.floor( this.height * scene.userData.y ) : 0;
		scene.height = scene.origHeight = scene.userData.height !== undefined ? Math.floor( this.height * scene.userData.height ) : this.height;
		scene.top = this.height - scene.height - scene.y;

		if ( scene.widthScale !== undefined ) {

			scene.width *= scene.widthScale;

		}

		if ( scene.heightScale !== undefined ) {

			scene.height *= scene.heightScale;

		}

		scene.pixelWidth = Math.floor( scene.width * this.pixelRatio );
		scene.pixelHeight = Math.floor( scene.height * this.pixelRatio );

		if ( scene.camera.isPerspectiveCamera ) {

			scene.camera.aspect = scene.pixelWidth / scene.pixelHeight;
            scene.camera.updateProjectionMatrix();

		}

		scene.viewportX = scene.vpX !== undefined ? Math.floor( this.width * scene.vpX ) : scene.x;
		scene.viewportWidth = scene.vpWidth !== undefined ? Math.floor( this.width * scene.vpWidth + 0.5 ) : scene.width;

		scene.viewportY = scene.vpY !== undefined ? Math.floor( this.height * scene.vpY ) : scene.y;
		scene.viewportHeight = scene.vpHeight !== undefined ? Math.floor( this.height * scene.vpHeight + 0.5 ) : scene.height;
		scene.viewportTop = this.height - scene.viewportHeight - scene.viewportY;

		scene.viewportPixelX = Math.floor( scene.viewportX * this.pixelRatio );
		scene.viewportPixelWidth = Math.floor( scene.viewportWidth * this.pixelRatio );
		scene.viewportPixelY = Math.floor( scene.viewportY * this.pixelRatio );
		scene.viewportPixelHeight = Math.floor( scene.viewportHeight * this.pixelRatio );
		scene.viewportPixelTop = this.pixelHeight - scene.viewportPixelHeight - scene.viewportY;

        var viewportDiv = scene.viewportDiv;

        viewportDiv.style.left = scene.viewportX + 'px';
        viewportDiv.style.width = scene.viewportWidth + 'px';

        viewportDiv.style.top = scene.viewportTop + 'px';
        viewportDiv.style.height = scene.viewportHeight + 'px';

		var div = scene.div;

		div.style.width = scene.width + 'px';
		div.style.height = scene.height + 'px';
		div.baseLeft = scene.x - scene.viewportX;
		div.baseTop = scene.top - scene.viewportTop;
		div.style.left = div.baseLeft + 'px';
		div.style.top = div.baseTop + 'px';

		var canvas = scene.canvas;

		canvas.width = scene.pixelWidth;
		canvas.height = scene.pixelHeight;

		canvas = scene.highlightCanvas;

		canvas.width = scene.pixelWidth;
		canvas.height = scene.pixelHeight;

		if ( scene.leftLimit ) {

			div.leftLimit = Math.floor( - scene.leftLimit * scene.origWidth * ( scene.widthScale - 1 ) );
			div.rightLimit = Math.floor( - scene.rightLimit * scene.origWidth * ( scene.widthScale - 1 ) );

			div.bottomLimit = Math.floor( - scene.bottomLimit * scene.origHeight * ( scene.heightScale - 1 ) );
			div.topLimit = Math.floor( - scene.topLimit * scene.origHeight * ( scene.heightScale - 1 ) );

		}

		scene.renderTarget.setSize( scene.pixelWidth, scene.pixelHeight );
		scene.pixelBuffer = new Uint8Array( 4 * scene.pixelWidth * scene.pixelHeight );

		scene.pickingRenderTarget.setSize( scene.pixelWidth, scene.pixelHeight );
		scene.pickingPixelBuffer = new Uint8Array( 4 * scene.pixelWidth * scene.pixelHeight );

    },

    clearGeometry: function() {
    	
    	while ( this.container.lastChild ) {
    		
    		this.container.removeChild( this.container.lastChild );
    		
    	}
    	
    	this.scenes = [];
		this.currentScene = null;

		this.startCell = 1;
    	
    },

    setPickDepth: function( depth ) {

        if ( depth === undefined ) {

            depth = PickDepthEnum.Closest;

        }

		if ( this.pickDepth === depth ) {

			return;

		}

        this.pickDepth = depth;

    },

	setPickRay: function( x, y ) {

		var px = Math.floor( x * this.pixelRatio );
		var py = Math.floor( y * this.pixelRatio );

		if ( px < 0 || py < 0 || px > this.pixelWidth || py > this.pixelHeight ) {

			this.validPick = false;
			console.error( 'AVS.Three.Viewer: pick ray coordinates out of range.' );
			return;

		}

		this.pickType = PickTypeEnum.Ray;
		this.pickRayX = px;
		this.pickRayY = py;
		this.validPick = true;

	},

	setPickRectangle: function( left, top, right, bottom ) {

		var px = Math.floor( Math.min( left, right ) * this.pixelRatio );
		var pw = Math.floor( Math.max( left, right ) * this.pixelRatio ) - px;

		var py = Math.floor( Math.max( top, bottom ) * this.pixelRatio );
		var ph = Math.floor( Math.min( top, bottom ) * this.pixelRatio ) - py;

		if ( px < 0 || py < 0 || ( pw + px ) > this.pixelWidth || ( py + ph ) > this.pixelHeight ) {

			this.validPick = false;
			console.error( 'AVS.Three.Viewer: pick rectangle coordinates out of range.' );
			return;

		}

		this.pickType = PickTypeEnum.Rectangle;
		this.pickRectangleX = px;
		this.pickRectangleY = py;
		this.pickRectangleWidth = pw;
		this.pickRectangleHeight = ph;
		this.validPick = true;

	},

	interactorUpdate: function() {

		var object = this.transformInteractor.object;
		var scope = this;

		object.traverse( function( child ) {

			if ( child.isBillboardText ) {

				child.scaleFactor = scope.transformInteractor.object.scale.y;

			}

		} );

		this.updatePicking = true;
		this.render( true );

		if ( this.stats !== undefined ) {

			this.stats.update();

		}

	},

    addInteractor: function( interactor ) {

		if ( interactor.isTransformInteractor ) {

			this.transformInteractor = interactor;
			interactor.addEventListener( 'change', this.interactorUpdate.bind( this ) );

		} else if ( interactor.isPanInteractor ) {

			this.panInteractor = interactor;

		} else {

			return;

		}

        this.interactors.push( interactor );
		interactor.domElement = this.domElement;

    },

	removeInteractor: function( interactor ) {

		var index = this.interactors.indexOf( interactor );

		if ( index > -1 ) {

			this.interactors.splice( index, 1 );

			if ( interactor.isTransformInteractor ) {

				this.transformInteractor = undefined;
				interactor.removeEventListener( 'change', this.interactorUpdate.bind( this ) );

			} else if ( interactor.isPanInteractor ) {

				this.panInteractor = undefined;

			}

		}

	},

	addStats: function() {

		if ( this.stats === undefined ) {

			this.stats = new Stats();
			this.container.appendChild( this.stats.dom );

		}

	},

	updateInteractors: function() {

		for ( var i = 0; i < this.interactors.length; i ++ ) {

//			this.interactors[ i ].update();

		}

	},

    addGeometry: function( geometry ) {

		geometry.updateMatrixWorld();

		// Set the container background color from the scene root

		if ( geometry.userData.background !== undefined ) {

			this.container.style.backgroundColor = "#" + geometry.userData.background.toString( 16 ).padStart( 6, '0' );

		} else {

			this.container.style.backgroundColor = "transparent";

		}

		var scope = this;

		// Pull out all scenes from the geometry tree

		geometry.traverse( function( object ) {

			if ( object.isScene ) {

				// Find camera reference

				for ( var i = 0; i < object.children.length; i ++ ) {

					var child = object.children[ i ];

					if ( child.isPerspectiveCamera || child.isOrthographicCamera ) {

						object.camera = child;
						object.remove( child );

						break;

					}

				}

				// No camera? Add a dummy one if we need to draw the background

				if ( object.camera == undefined && object.background !== null ) {

					object.camera = new OrthographicCamera$1();

				}

				if ( object.camera !== undefined ) {

					scope.addScene( object );

				}

			}

			scope.attachInteractors( object );
			scope.addLabels( object );
			scope.createPickingInfo( object );
			scope.addMaterialReferences( object );

		} );

		scope.updateInteractors();

//            this.dataMaps = geometry.dataMaps;
//        }

		// Remove scenes from their parent so they become top-level

        for ( var i = 0; i < this.scenes.length; i ++ ) {

			var scene = this.scenes[ i ];

			if ( scene.parent ) {

				scene.parent.remove( scene );

			}

        }

    },

    addScene: function( scene, panScene ) {

        this.scenes.push( scene );
        this.currentScene = scene;

		if ( panScene === undefined ) {

			this.currentRealScene = scene;

		}

        scene.labels = [];

        var viewportDiv = document.createElement('div');
        viewportDiv.style.position = 'absolute';
        viewportDiv.style.overflow = 'hidden';
		viewportDiv.id = scene.name + "Viewport";

		var div = document.createElement('div');
		div.style.position = 'absolute';
        div.style.overflow = 'hidden';
		div.id = scene.name;
		viewportDiv.appendChild( div );

		var canvas = document.createElement('canvas');
		canvas.style.position = 'absolute';
		canvas.style.width = '100%';
		canvas.style.height = '100%';
		canvas.id = scene.name + "Canvas";
		div.appendChild( canvas );
		scene.canvas = canvas;
		scene.ctx = canvas.getContext('2d');

		var highlightCanvas = document.createElement('canvas');
		highlightCanvas.style.position = 'absolute';
		highlightCanvas.style.width = '100%';
		highlightCanvas.style.height = '100%';
		highlightCanvas.id = scene.name + "HighlightCanvas";
		div.appendChild( highlightCanvas );
		scene.highlightCanvas = highlightCanvas;
		scene.highlightCtx = highlightCanvas.getContext('2d');

		scene.div = div;
        scene.viewportDiv = viewportDiv;
        this.container.appendChild( viewportDiv );

		scene.renderTarget = new WebGLRenderTarget();
		scene.pickingRenderTarget = new WebGLRenderTarget();

        this.updateSceneSize( scene );

		scene.startCell = this.startCell;

        // Create a duplicate scene+lights for rendering just highlighted objects
        scene.highlightScene = new Scene$1();
        scene.highlightScene.add( new Group$1() );

        for ( var i = 0; i < scene.children.length; i ++ ) {

            if ( scene.children[ i ].isLight ) {

                scene.highlightScene.add( scene.children[ i ].clone() );

            }

        }

    },

	attachInteractors: function( object ) {

		if ( object.userData.attachTransformInteractor && this.transformInteractor ) {

			// Attach transform interactor to the current object

			this.transformInteractor.setObjectScene( object, this.currentScene );

		} else if ( object.userData.attachPanInteractor && this.panInteractor ) {

			// Convert the object's parent (which will either be a "ChartSceneGroup"
			// or "AxisSceneGroup" created by the OpenViz Domain component) into a scene

			var parent = object.parent;

			parent.matrix.copy( object.matrixWorld );
			parent.matrixAutoUpdate = false;

			parent.isScene = true; // pretend to be a THREE.Scene
			parent.autoUpdate = true;
			parent.overrideMaterial = null;
			parent.userData.is3D = this.currentScene.userData.is3D;

			parent.userData.x = this.currentScene.userData.x;
			parent.userData.y = this.currentScene.userData.y;
			parent.userData.width = this.currentScene.userData.width;
			parent.userData.height = this.currentScene.userData.height;

			// Re-use current camera
			object.camera = parent.camera = this.currentScene.camera;

			var width = object.camera.right - object.camera.left;
			var height = object.camera.top - object.camera.bottom;

			// Lower-left corner of the workbox

			var point = new Vector3();

			point.set( - object.userData.xSize / 2, - object.userData.ySize / 2, 0 );
			point.applyMatrix4( parent.matrix );

			// Upper-right corner of the workbox

			var point2 = new Vector3();

			point2.set( object.userData.xSize / 2, object.userData.ySize / 2, 0 );
			point2.applyMatrix4( parent.matrix );

			var leftLimit = ( point.x - object.camera.left ) / width;
			var rightLimit = ( point2.x - object.camera.left ) / width;
			var bottomLimit = ( point.y - object.camera.bottom ) / height;
			var topLimit = ( point2.y - object.camera.bottom ) / height;

			var x1 = parent.userData.x + leftLimit * parent.userData.width;
			var x2 = parent.userData.x + rightLimit * parent.userData.width;

			var y1 = parent.userData.y + bottomLimit * parent.userData.height;
			var y2 = parent.userData.y + topLimit * parent.userData.height;

			if ( object.userData.attachPanInteractor === 'center' ) {

				parent.vpX = x1;
				parent.vpWidth = x2 - x1;
				parent.vpY = y1;
				parent.vpHeight = y2 - y1;

				parent.widthScale = this.panInteractor.widthScale;
				parent.heightScale = this.panInteractor.heightScale;

				parent.leftLimit = leftLimit;
				parent.rightLimit = rightLimit;
				parent.bottomLimit = 1 - bottomLimit;
				parent.topLimit = 1 - topLimit;

			} else if ( object.userData.attachPanInteractor === 'bottom' ) {

				parent.vpX = x1;
				parent.vpWidth = x2 - x1;
				parent.vpY = 0;
				parent.vpHeight = y2;

				parent.widthScale = this.panInteractor.widthScale;

			} else if ( object.userData.attachPanInteractor === 'top' ) {

				parent.vpX = x1;
				parent.vpWidth = x2 - x1;
				parent.vpY = y1;
				parent.vpHeight = 1 - y1;

				parent.widthScale = this.panInteractor.widthScale;

			} else if ( object.userData.attachPanInteractor === 'left' ) {

				parent.vpX = 0;
				parent.vpWidth = x2;
				parent.vpY = y1;
				parent.vpHeight = y2 - y1;

				parent.heightScale = this.panInteractor.heightScale;

			} else if ( object.userData.attachPanInteractor === 'right' ) {

				parent.vpX = x1;
				parent.vpWidth = 1 - x1;
				parent.vpY = y1;
				parent.vpHeight = y2 - y1;

				parent.heightScale = this.panInteractor.heightScale;

			}

			// Reset scene offset

			parent.matrix.elements[ 12 ] = 0;
			parent.matrix.elements[ 13 ] = 0;

			this.addScene( parent, true );

			if ( object.userData.attachPanInteractor === 'center' ) {

				this.panInteractor.object = parent.div;

			} else if ( object.userData.attachPanInteractor === 'bottom' ) {

				this.panInteractor.linkObjectsBottom.push( parent.div );

			} else if ( object.userData.attachPanInteractor === 'top' ) {

				this.panInteractor.linkObjectsTop.push( parent.div );

			} else if ( object.userData.attachPanInteractor === 'left' ) {

				this.panInteractor.linkObjectsLeft.push( parent.div );

			} else if ( object.userData.attachPanInteractor === 'right' ) {

				this.panInteractor.linkObjectsRight.push( parent.div );

			}

			if ( this.loading && parent.parent ) {

				parent.parent.remove( parent );

			}

			this.panInteractor.update();

		}

	},

    createPickingInfo: function( object ) {

		if ( object.geometry !== undefined && object.material !== undefined ) {

			if ( object.geometry.attributes.cellCount === undefined ) {

				var cellCount;
				var nCells;

				if ( object.material.glyphs ) {

					var nGlyphs = object.geometry.attributes.offset.array.length / 3;
					nCells = nGlyphs;

					var cellArray = new Float32Array( nGlyphs );
					for ( var i = 0; i < nGlyphs; i ++ ) {
						cellArray[ i ] = i;
					}

					cellCount = new InstancedBufferAttribute( cellArray, 1 );

				} else if ( object.isThickLineSegments ) {

					var nVertices = object.geometry.attributes.instanceStart.array.length / 3;
					var nQuads = nVertices / 2;
					nCells = nVertices;

					var cellArray = new Float32Array( nQuads );
					for ( var i = 0; i < nQuads; i ++ ) {
						cellArray[ i ] = i * 2;
					}

					cellCount = new InstancedBufferAttribute( cellArray, 1 );

				} else {

					var step = 1;
					if ( object.isPoints ) {
						step = 1;
					} else if ( object.isLineSegments ) {
						step = 2;
					} else if ( object.isMesh ) {
						step = 3;
					}

					var nVertices = object.geometry.attributes.position.array.length / 3;
					nCells = nVertices / step;
					cellCount = new Float32BufferAttribute( nVertices, 1 );

					for ( var i = 0; i < nCells; i ++ ) {
						for ( var j = 0; j < step; j ++ ) {
							cellCount.array[ i * step + j ] = i;
						}
					}

				}

				object.geometry.setAttribute( 'cellCount', cellCount );
				object.geometry.nCells = nCells;

			}

			object.nCells = object.geometry.nCells;
			object.startCell = this.startCell;

			object.onBeforeRender = function( renderer, scene, camera, geometry, material, group ) {

				material.uniforms.startCell.value = this.startCell;

				var materialProperties = renderer.properties.get( material );

				// Material already programmed, this is currently the only way to change a uniform at this point
				if ( materialProperties.program ) {

					var gl = renderer.getContext();

					gl.useProgram( materialProperties.program.program );

					materialProperties.program.getUniforms().setValue( gl, "startCell", this.startCell );

				}

			};

			this.startCell += object.nCells;

			// Overflowed the first picking render target (2^24-1 cells) so need to use second as well
			if ( ! this.pickingRenderTarget2 && this.startCell > 16777215 ) {

				this.pickingRenderTarget2 = new WebGLRenderTarget( this.pixelWidth, this.pixelHeight );
				this.pickingPixelBuffer2 = new Uint8Array( 4 * this.pixelWidth * this.pixelHeight );

			}

			this.updatePicking = true;

		}

	},

    addLabels: function( object ) {

        if ( object.isBillboardText ) {

			// Add this label to the scene's list
			if ( object.parent.userData.attachPanInteractorStatic ) {

				object.addToScene( this.currentRealScene );

			} else {

				object.addToScene( this.currentScene );

			}

		}

    },

	addMaterialReferences: function( object ) {

		if ( object.material !== undefined ) {

			// Keep a reference to the pick state in the shaders
			object.material.pickState = this.pickState;

			if ( object.material.isLineBasicMaterial !== undefined ) {

				// Keep a reference to the screen resolution needed for the line material shaders
				object.material.resolution = this.resolution;

			}

		}

	},

    loadGeometryAsJson: function( json ) {

		var scope = this;

        var object = this.objectLoader.parse( json, function( object ) {

			scope.clearGeometry();

			scope.updateSize();

			scope.addGeometry( object );

			scope.render();

		} );

    },

	loadGeometryAsEvents: function( data ) {

        var scope = this;
        var parsedCount = 0;
        var doneCount = -1;
        var remainingCount = 0;

		if ( this.chunkId === undefined || this.chunkId !== data.chunkId ) {

			this.clearGeometry();

			// Reset state vars
			this.curGroup = null;
			this.images = [];
			this.textures = [];
			this.materials = [];
			this.geometries = [];

			this.firstChunk = true;
			this.chunkId = data.chunkId;

		}

		this.loading = true;
		this.updateSize();

        function streamCallback( item ) {

            remainingCount--;
//            console.log("doneCount = " + doneCount + ", callbackCount = " + callbackCount + ", remainingCount = " + remainingCount);

			// Place new items in layer 1 so only they will be rendered next time
			item.layers.set( 1 );

            // Wait to make geometry visible until item is completely loaded
            item.visible = item.saveVisible;

            // Check if we are done
            if ( doneCount > 0 && remainingCount == 0 ) {

//				console.log('done in streamCallback');

				scope.render();

				scope.loading = false;
				scope.firstChunk = false;

                return;

            }

        }

        function processEvent( data ) {

            if ( data.type === "Group" ) {

                var newGroup = scope.objectLoader.parse( data );

                // If it's a sub-group, add to the parent
                if ( scope.curGroup !== null ) {

                    scope.curGroup.add( newGroup );

                }

				// Set the container background color from the scene root
				if ( newGroup.name === "SceneRoot" ) {

					if ( newGroup.userData.background !== undefined ) {

						scope.container.style.backgroundColor = "#" + newGroup.userData.background.toString( 16 ).padStart( 6, '0' );

					} else {

						scope.container.style.backgroundColor = "transparent";

					}

				}

				newGroup.updateMatrixWorld( true );
				scope.attachInteractors( newGroup );

                scope.curGroup = newGroup;

            } else if ( data.type === "FinishGroup" ) {

				if ( scope.curGroup !== null ) {

					scope.curGroup = scope.curGroup.parent;

				}

            } else if ( data.type === "Geometry" ) {

                remainingCount++;
                var item = scope.objectLoader.parse( data, streamCallback, scope.images, scope.textures, scope.materials, scope.geometries/*, scope.dataMaps*/, scope.curGroup );
                parsedCount++;

			    scope.addLabels( item );
                scope.createPickingInfo( item );
				scope.addMaterialReferences( item );

            } else if ( data.type === "Layout" ) {

                var scene = scope.objectLoader.parse( data );

				// Find camera reference

				for ( var i = 0; i < scene.children.length; i ++ ) {

					var child = scene.children[ i ];

					if ( child.isPerspectiveCamera || child.isOrthographicCamera ) {

						scene.camera = child;
						scene.remove( child );
						break;

					}

				}

				// No camera? Add a dummy one if we need to draw the background

				if ( scene.camera == undefined && scene.background !== null ) {

					scene.camera = new OrthographicCamera$1();

				}

				if ( scene.camera !== undefined ) {

					scope.addScene( scene );

				}

                scope.curGroup = scene;

            } else {

                console.log("ERROR: unknown type: " + data.type);

            }

        }

        if ( data === undefined || data.events === undefined || data.events.length === 0 ) {

            console.error( 'AVS.Three.Viewer.loadGeometryAsEvents: Can\'t get events' );
            return;

        }

//        console.log( "Events in chunk = " + data.events.length );

        for ( var i = 0; i < data.events.length; i ++ ) {

            processEvent( data.events[i] );

        }

        if ( data.moreChunks === true ) {
				
//			console.log('more chunks');

			this.render();
	    
        } else {

            doneCount = parsedCount - 1;

//			console.log('no more chunks, remaining = ' + remainingCount);

			if ( remainingCount == 0 ) {

				this.render();

				this.loading = false;

			}

        }

		this.firstChunk = false;

	},

/*
    loadGeometryAsUrl: function( object ) { 

        if (object.jsonRequest.model.rendererProperties.streamProperties !== undefined && object.jsonRequest.model.rendererProperties.streamProperties.type === 'CHUNK') {
            this.loadGeometryAsUrlChunk( object );
            return;
        }
        if (object.jsonRequest.model.rendererProperties.streamProperties !== undefined && object.jsonRequest.model.rendererProperties.streamProperties.type === 'OBOE_STREAM') {
            this.loadGeometryAsUrlStream( object );
            return;
        }
        var scope = this;

		if ( this.loading === true ) {
			this.cancelLoad = true;
		}

		this.loading = true;

        // instantiate a loader
        var loader = new ObjectLoader();
        loader.load(

            // the path or URL to the scene data
            object.url,

            // onLoad  
            function ( geometry, selectionInfo ) {

				if ( scope.cancelLoad === false ) {

					scope.loading = false;

					if ( geometry !== undefined ) {

						scope.clearGeometry();
						scope.addGeometry( geometry );
						scope.render();

					}

					if ( object.success !== undefined ) {

						object.success( selectionInfo );

					}

				}

				scope.cancelLoad = false;

            },

            object.progress,
            object.error,
			object.jsonRequest
        );
    },		 
*/
/*
    loadGeometryAsUrlChunk: function( object ) { 
        var scope = this;

//        var dataMaps = {};
        var parentStack = [];
        var curGroup;
        var loader = new ObjectLoader();
        var jsonLoader = new FileLoader(scope.manager);

        var errorFlag = false;
        var images = {};
        var textures = {};
        var materials = {};
        var geometries = {};
        var parsedCount = 0;
        var doneCount = -1;
        var callbackCount = 0;
        var remainingCount = 0;

		if ( this.loading === true ) {
			return;
		}
		this.loading = true;

        function streamCallback( item ) {

            remainingCount--;
//            console.log("doneCount = " + doneCount + ", callbackCount = " + callbackCount + ", remainingCount = " + remainingCount);

			// Place new items in layer 1 so only they will be rendered next time
			item.layers.set( 1 );

            // Wait to make geometry visible until item is completely loaded
            item.visible = item.saveVisible;

            // Check if we are done
            if ( doneCount > 0 && remainingCount == 0 ) {

				if ( object.success !== undefined ) object.success();

				scope.loading = false;

                return;

            }

            callbackCount++;

        }

        function processEvent( data ) {
           if (data.type === "Group") {
                var newGroup = loader.parse( data );

                // If it's a sub-group, add to the parent
                if (curGroup !== undefined) {
                    curGroup.add(newGroup);
//                    scope.connectInteractor(newGroup);
                }
                else {
                    errorFlag = true;
                }
                parentStack.push(newGroup);
                curGroup = newGroup;
           }
           else if (data.type === "FinishGroup") {
               var previousCurGroup = parentStack.pop();
               if (parentStack.length > 0) {
                   curGroup = parentStack[parentStack.length-1];
               }
               else {
                   curGroup = previousCurGroup;
               }
           }
           else if (data.type === "Geometry") {
               remainingCount++;
               var item = loader.parse( data, streamCallback, images, textures, materials, geometries//, dataMaps
										, curGroup );
               parsedCount++;

			   scope.addLabels( item );
               scope.createPickingInfo( item );
           }
           else if (data.type === "Layout") {
               var scene = loader.parse( data );

				// Find camera reference

				for ( var i = 0; i < scene.children.length; i ++ ) {

					var child = scene.children[ i ];

					if ( child.isPerspectiveCamera || child.isOrthographicCamera ) {

						scene.camera = child;
						break;

					}

				}

				// No camera? Add a dummy one if we need to draw the background

				if ( scene.camera == undefined && scene.background !== null ) {

					scene.camera = new THREE.OrthographicCamera();

				}

				if ( scene.camera !== undefined ) {

					scope.addScene( scene );

				}

               curGroup = scene;
           }
           else {
               console.log("ERROR: unknown type: " + data.type);
               errorFlag = true;
           }

           if ( object.progress !== undefined ) object.progress();

        }

        function loadNextChunk( url, jsonRequest ) {

			jsonLoader.setRequestHeader({'Content-type':'application/json'});
            jsonLoader.load( url, function ( text ) {

                var json = null;
                try {
                    json = JSON.parse( text );
                } catch ( error ) {
                    if ( object.error !== undefined ) object.error( error );
                    console.error( 'AVS.Three.Viewer.loadGeometryAsUrlChunk: Can\'t parse chunk ' + url + '.', error.message );
                    return;
                }

                if (json.events === undefined) {
                    console.error( 'AVS.Three.Viewer.loadGeometryAsUrlChunk: Can\'t get events from ' + url );
                    return;
                }

                console.log("Events in chunk = " + json.events.length);
                for (var i = 0; i < json.events.length; i++) {
                    processEvent( json.events[i] );
                }

				if ( jsonRequest.model.rendererProperties.streamProperties.streamUpdate !== undefined ) jsonRequest.model.rendererProperties.streamProperties.streamUpdate( callbackCount );

                if ( json.moreChunks === true ) {
				
					jsonRequest.model.rendererProperties.streamProperties.chunkId = json.chunkId;				
	                loadNextChunk( url, jsonRequest );
	    
                } else {

                    doneCount = parsedCount - 1;

					if ( remainingCount == 0 ) {

						if ( object.success !== undefined ) object.success();

						scope.loading = false;

					}

                }

            }, undefined, object.error, jsonRequest );
        }

		this.clearGeometry();

        loadNextChunk( object.url, object.jsonRequest );

    },		 
*/
/*
    loadGeometryAsUrlStream: function( object ) {
        var scope = this;

//        var dataMaps = {};
        var parentStack = [];
        var curGroup;
        var loader = new ObjectLoader();

        var errorFlag = false;
        var images = {};
        var textures = {};
        var materials = {};
        var geometries = {};
        var parsedCount = 0;
        var doneCount = -1;
        var callbackCount = 0;
        var remainingCount = 0;

        function streamCallback(item) {
            remainingCount--;
//            console.log("doneCount = " + doneCount + ", callbackCount = " + callbackCount + ", remainingCount = " + remainingCount);

            // Wait to make geometry visible until item is completely loaded
            item.visible = item.saveVisible;

            scope.addLabels( item );

            scope.createPickingInfo( item );

            // Check if we are done
            if (object.success != undefined) {
                if (doneCount > 0 && remainingCount == 0) {
                    object.success();
                    return;
                }
            }

            // Intermediate update event
            if (object.streamUpdate != undefined && object.streamUpdateStep !== undefined) {
                if (callbackCount === object.streamUpdateFirst || (callbackCount > 0 && callbackCount % object.streamUpdateStep === 0)) {
                    object.streamUpdate( callbackCount );
                }
            }

            callbackCount++;
        }

        oboe( object.url )
            .fail( function( error ) {
                if (object.error != undefined) {
                    object.error();
                }
            })
           .done( function() {
                doneCount = parsedCount - 1;
                if (object.success != undefined && remainingCount == 0) {
                    object.success();
                }
           })
           .node('events.*', function( data ){
               if (data.type === "Group") {
                    var newGroup = loader.parse( data );

                    // If this is a sceneRoot add it to a scene
                    if (newGroup.userData.type === "SceneRoot") {
                        scope.connectSceneRoot( newGroup );
                    }
                    // Otherwise it's a sub-group, add to the parent
                    else if (curGroup !== undefined) {
                        curGroup.add(newGroup);
                        scope.connectInteractor(newGroup);
                    }
                    else {
                        errorFlag = true;
                    }
                    parentStack.push(newGroup);
                    curGroup = newGroup;
               }
               else if (data.type === "FinishGroup") {
                   var previousCurGroup = parentStack.pop();
                   if (parentStack.length > 0) {
                       curGroup = parentStack[parentStack.length-1];
                   }
                   else {
                       curGroup = previousCurGroup;
                   }
               }
               else if (data.type === "Geometry") {
                   remainingCount++;
                   loader.parse( data, streamCallback, images, textures, materials, geometries//, dataMaps
								, curGroup );
                   parsedCount++;
               }
               else if (data.type === "Layout") {
                   var scene = loader.parse( data );
                   scope.addScene( scene );
                   curGroup = scene;
               }
               else {
                   console.log("ERROR: unknown type: " + data.type);
                   errorFlag = true;
               }

               if (object.progress != undefined) {
                   object.progress();
               }

               // Remove node from oboe's tree. We are saving the parent stack and 
               // that is all we need for now
               return oboe.drop;
           }); 
    },
*/
/*
    findDataMap : function( object, type ) {
        var curObject = object.parent;
        while( curObject !== undefined && curObject !== null) {
            if (curObject.userData !== undefined && curObject.userData.dataMaps !== undefined) {
                var objectDataMaps = curObject.userData.dataMaps;
                if (objectDataMaps.hasOwnProperty( type )) {
                    return objectDataMaps[type]; 
                }
            }
            curObject = curObject.parent;	
        }
    },

    cleanDataMaps: function( dataMaps ) {
        if ( dataMaps !== undefined) {
            for (var dataMap in dataMaps) {
                if ( dataMaps.hasOwnProperty(dataMap)) {
                    dataMaps[dataMap].setDirty(false);
                }
            }
        }
    },

    // Data map update works in onBeforeRender for material level changes but not for vertex based changes (one render behind)
    evaluateDataMaps: function( object ) {
        // Set a callback to evaluate the datamaps just prior to rendering
        if ( object.userData.cellSetData !== undefined && object.userData.cellSetData.dataMapSourceValues != undefined) {
            var dataMapSourceValues = object.userData.cellSetData.dataMapSourceValues;
            if (dataMapSourceValues !== undefined) {

                // color map
                var colorValue = dataMapSourceValues.color;
                if ( colorValue !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'color'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var newColor = curDataMap.evaluate( colorValue );
                        if (newColor !== undefined) {
                            object.material.color = newColor;
                            object.material.colorWrite = true;
                        }
                        else {
                            object.material.colorWrite = false;
                        }
                    }
                }

                // size map
                var sizeValue = dataMapSourceValues.size;
                if ( sizeValue !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'size'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var newSize = curDataMap.evaluate( sizeValue );
                        if (newSize !== undefined) {
                            // update object matrix size here

                            object.material.colorWrite = true;
                        }
                        else {
                            object.material.colorWrite = false;
                        }
                    }
                }

                // shape map
                var shapeValue = dataMapSourceValues.shape;
                if ( shapeValue !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'shape'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var newShape = curDataMap.evaluate( shapeValue );
                        if (newShape !== undefined) {
                            object.geometry = newShape;
                            object.material.colorWrite = true;
                        }
                        else {
                            object.material.colorWrite = false;
                        }
                    }
                }
            }
        }
        else if ( object.userData.cellData !== undefined && object.userData.cellData.dataMapSourceValues != undefined) {
            var dataMapSourceValues = object.userData.cellData.dataMapSourceValues;
            if (dataMapSourceValues !== undefined) {
                // Color map
                var colorValues = dataMapSourceValues.color;
                if ( colorValues !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'color'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var count = null;
                        var length = null;
                        var attribute = object.geometry.attributes.color;

                        for (var i = 0; i < colorValues.length; i++) {
                            var newColor = curDataMap.evaluate( colorValues[i] );

                            if (object.cellType === AVS.Three.CellTypeEnum.Points) { // THREE.Points
                                count = 3*i;
                                length = 1;
                            } else if (object.cellType === AVS.Three.CellTypeEnum.Lines) { // THREE.LineSegments
                                count = 6*i;
                                length = 2;
                            } else if (object.cellType === AVS.Three.CellTypeEnum.Triangles) { // THREE.Mesh tris
                                count = 9*i;
                                length = 3;
                            } else { // THREE.Mesh quads
                                count = 9*i; 
                                length = 3;
                            }

                            if (newColor !== undefined) {
                                for (var k = 0; k < length; k++) {
                                    attribute.array[count++] = newColor.r;
                                    attribute.array[count++] = newColor.g;
                                    attribute.array[count++] = newColor.b;
                                }
                            }
                            else {
                                for (var k = 0; k < length; k++) {
                                    attribute.array[count++] = undefined;
                                    attribute.array[count++] = undefined;
                                    attribute.array[count++] = undefined;
                                }
                            }
                        }
                        attribute.needsUpdate = true;
                    }
                }
            }
        }

        for (var i = 0; i < object.children.length; i++) {
            this.evaluateDataMaps(object.children[i]);
        }
    },
*/
	highlightRender: function() {

		if ( this.renderer === undefined ) {

			console.error( 'AVS.Three.Viewer: WebGLRenderer not set.' );
			return;

		}

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            var scene = this.scenes[ i ];         

			this.resolution.x = scene.pixelWidth;
			this.resolution.y = scene.pixelHeight;

			this.renderer.setSize( scene.width, scene.height );
			this.renderer.setClearColor( 0x000000, 0 );
			this.renderer.clear();

            this.renderer.render( scene.highlightScene, scene.camera );

			// Copy the renderer's canvas pixel buffer to the highlight canvas
			scene.highlightCtx.clearRect( 0, 0, scene.pixelWidth, scene.pixelHeight );
			scene.highlightCtx.drawImage( this.renderer.domElement, 0, 0 );

        }

	},

	pickRender: function() {

		if ( this.renderer === undefined ) {

			console.error( 'AVS.Three.Viewer: WebGLRenderer not set.' );
			return;

		}

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            var scene = this.scenes[ i ];         

			this.resolution.x = scene.pixelWidth;
			this.resolution.y = scene.pixelHeight;

			// Render to the scene's picking render target
			this.renderer.setRenderTarget( scene.pickingRenderTarget );
			this.pickState[ 0 ] = 1;

			this.renderer.setClearColor( 0x000000, 0 );
			this.renderer.clear();

			this.renderer.render( scene, scene.camera );

			// Read the pixels from the primary render target to the primary pixel buffer
			this.renderer.readRenderTargetPixels( scene.pickingRenderTarget, 0, 0, scene.pixelWidth, scene.pixelHeight, scene.pickingPixelBuffer );

			if ( scene.pickingRenderTarget2 ) {

				// Render to the scene's secondary picking target
				this.renderer.setRenderTarget( scene.pickingRenderTarget2 );
				this.pickState[ 0 ] = 2;

				this.renderer.clear();

				this.renderer.render( scene, scene.camera );

				// Read the pixels from the secondary render target to the secondary pixel buffer
				this.renderer.readRenderTargetPixels( scene.pickingRenderTarget2, 0, 0, scene.pixelWidth, scene.pixelHeight, scene.pickingPixelBuffer2 );

			}

        }

		this.pickState[ 0 ] = 0;
		this.renderer.setRenderTarget( null );

	},

    render: function( forceFull ) {

		if ( this.renderer === undefined ) {

			console.error( 'AVS.Three.Viewer: WebGLRenderer not set.' );
			return;

		}

		// Don't try to render if we are hidden
		if ( this.domElement.offsetParent === null ) {

			return;

		}

		this.updateSize();

		var chunkRender = this.loading;
		var fullRender = forceFull || ! chunkRender;

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            var scene = this.scenes[ i ];         

//            this.evaluateDataMaps( scene );

			this.resolution.x = scene.pixelWidth;
			this.resolution.y = scene.pixelHeight;

			if ( fullRender ) {

				this.renderer.setSize( scene.width, scene.height );

			} else {

				this.renderer.setRenderTarget( scene.renderTarget );

			}

			if ( fullRender || this.firstChunk ) {

				if ( scene.userData.background ) {

					this.renderer.setClearColor( scene.userData.background, 1 );

				} else {

					this.renderer.setClearColor( 0x000000, 0 );

				}

				this.renderer.clear();

			}

			// Per-chunk rendering: place the camera+lights in layer 1, then draw to renderTarget
			if ( ! fullRender ) {

				scene.camera.layers.set( 1 );

				for ( var j = 0; j < scene.children.length; j ++ ) {

					if ( scene.children[ j ].isLight ) {

						scene.children[ j ].layers.set( 1 );

					}

				}

			}

			this.renderer.render( scene, scene.camera );

			if ( fullRender ) {

				// Copy the renderer's canvas contents to the scene's canvas

				scene.ctx.clearRect( 0, 0, scene.pixelWidth, scene.pixelHeight );
				scene.ctx.drawImage( this.renderer.domElement, 0, 0 );

			} else {

				// Copy the renderTarget's pixel buffer to the scene's canvas (with vertical flip)

				this.renderer.readRenderTargetPixels( scene.renderTarget, 0, 0, scene.pixelWidth, scene.pixelHeight, scene.pixelBuffer );
				var imgData = scene.ctx.createImageData( scene.pixelWidth, scene.pixelHeight );

				var row, col, rowLength = 4 * scene.pixelWidth;
				for ( var k = 0; k < scene.pixelBuffer.length; k ++ ) {

					row = Math.floor( k / rowLength );
					col = k % rowLength;
					imgData.data[ ( scene.pixelHeight - row - 1 ) * rowLength + col ] = scene.pixelBuffer[ k ];

				}

				scene.ctx.putImageData( imgData, 0, 0 );

				this.renderer.setRenderTarget( null );

				// Place just rendered camera+lights+objects back in layer 0

				scene.camera.layers.set( 0 );

				scene.traverse( function( child ) {

					child.layers.set( 0 );

				} );

			}

            for ( var j = 0; j < scene.labels.length; j ++ ) {

                scene.labels[ j ].updatePosition();

            }

		}

        // Wait to clean data maps until all scene have been rendered because they 
        // may be shared between scenes.
//        this.cleanDataMaps( this.getDataMaps() );

		// Finally render the highlight layer
		if ( this.updateHighlight ) {

			this.highlightRender();
			this.updateHighlight = false;

		}

    },

	addSelectionListener: function( listener ) {

		if ( listener !== undefined ) {

			this.selectionListeners.push( listener );

		}

	},

    concatObjectsFromCellNums : function( intersects, object, cellNums, startCell ) {

        // No cells remaining to find
        if ( cellNums === undefined || cellNums.length === 0 || cellNums[ 0 ] === 0 ) {

            return undefined;

        }

        // Start with scene's first cell and sort the cell numbers into increasing order
        if ( startCell === undefined ) {

            startCell = object.startCell;

            cellNums.sort( function( a, b ) {

				return a - b;

			} );

        }

        // Check if this object has a cell matching cellNums[ 0 ]
        while ( object.nCells !== undefined && cellNums[ 0 ] >= startCell && cellNums[ 0 ] < startCell + object.nCells ) {

			if ( object.isMesh ) {

				intersects.push( {

					object: object,
					faceIndex: cellNums[ 0 ] - startCell

				} );

			} else {

				intersects.push( {

					object: object,
					index: ( object.isLineSegments ? 2 : 1 ) * ( cellNums[ 0 ] - startCell )

				} );

			}

            // Remove cellNums[ 0 ] and test this object again with new cellNums[ 0 ]
            cellNums.splice( 0, 1 );

            // No cells remaining to find
            if ( cellNums.length === 0 ) {

                return undefined;

            }
        }

		// Done with current object, increment startCell and start checking the children
        if ( object.nCells !== undefined ) {

            startCell += object.nCells;

        }

        for ( var i = 0; i < object.children.length; i ++ ) {

            startCell = this.concatObjectsFromCellNums( intersects, object.children[ i ], cellNums, startCell );

            if ( startCell === undefined ) {

                break;

            }

        }

        return startCell;

    },
/*
    getDataMapSourceCellValue : function( object, primitiveIndex, type ) {
        var cellIndex = undefined;
        var count = 1;

        if (object !== undefined) {
            if (object.cellType === AVS.Three.CellTypeEnum.Points) { // THREE.Points
                cellIndex = primitiveIndex;
            } else if (object.cellType === AVS.Three.CellTypeEnum.Lines) { // THREE.LineSegments
                cellIndex = primitiveIndex/2;
            } else if (object.cellType === AVS.Three.CellTypeEnum.Triangles) { // THREE.Mesh tris
                cellIndex = primitiveIndex/3;
            } else { // THREE.Mesh quads
                cellIndex = Math.floor(primitiveIndex/6); // highlight this tri and its pair
                count = 2;
            }
        }

        var values = object.userData.cellData.dataMapSourceValues[type];
        return values[cellIndex * count];
    },
*/
	/**
	 * Pick objects using a ray or rectangle
	 */
    pick : function() {

		if ( this.validPick === false ) {

			console.error( 'AVS.Three.Viewer: invalid pick ray or rectangle.' );
			return;

		}

		// Update the picking render targets if needed
		if ( this.pickDepth === PickDepthEnum.Closest && this.updatePicking ) {

			this.pickRender();
			this.updatePicking = false;

		}

		this.intersects = [];

        for ( var s = 0; s < this.scenes.length; s ++ ) {

            var scene = this.scenes[ s ];

            if ( this.pickType === PickTypeEnum.Rectangle ) {

				// Calculate intersection of the pick rectangle and this scene's viewport
				var startX = Math.max( this.pickRectangleX, scene.viewportPixelX );
				var startY = Math.max( this.pickRectangleY, scene.viewportPixelTop );

				var endX = Math.min( this.pickRectangleX + this.pickRectangleWidth, scene.viewportPixelX + scene.viewportPixelWidth );
				var endY = Math.min( this.pickRectangleY + this.pickRectangleHeight, scene.viewportPixelTop + scene.viewportPixelHeight );

				// Translate pixel on viewport to pixel on canvas
				startX -= scene.viewportPixelX;
				startY -= scene.viewportPixelTop;
				endX -= scene.viewportPixelX;
				endY -= scene.viewportPixelTop;

				// Offset due to panned scene
				if ( scene.div.panOffsetX ) {

					startX -= ( scene.div.panOffsetX + scene.div.baseLeft );
					endX -= ( scene.div.panOffsetX + scene.div.baseLeft );

				}

				if ( scene.div.panOffsetY ) {

					startY -= ( scene.div.panOffsetY + scene.div.baseTop );
					endY -= ( scene.div.panOffsetY + scene.div.baseTop );

				}

                var cellNums = [];

				// Loop through every pixel in the intersection
                for ( var x = startX; x < endX; x ++ ) {

                    for ( var y = endY; y < startY; y ++ ) {

						// Pick all objects using CPU (THREE.Raycaster)
						if ( this.pickDepth === PickDepthEnum.All ) {

							var rayX = ( x / scene.pixelWidth ) * 2 - 1;
							var rayY = ( ( scene.pixelHeight - y - 1 ) / scene.pixelHeight ) * 2 - 1;

							this.raycaster.setFromCamera( new Vector2( rayX, rayY ), scene.camera );

                            var rayIntersects = this.raycaster.intersectObjects( scene.children, true );

							this.intersects = this.intersects.concat( rayIntersects );

						// Pick closest object using GPU (picking render target)
						} else {

							var index = ( x + ( ( scene.pixelHeight - y - 1 ) * scene.pixelWidth ) ) * 4;

							var cellNum = ( scene.pickingPixelBuffer[ index     ] * 255 * 255 ) +
							              ( scene.pickingPixelBuffer[ index + 1 ] * 255 ) +
							              ( scene.pickingPixelBuffer[ index + 2 ] );

							if ( scene.pickingPixelBuffer2 ) {

								cellNum += ( scene.pickingPixelBuffer2[ index     ] * 255 * 255 * 255 * 255 * 255 ) +
								           ( scene.pickingPixelBuffer2[ index + 1 ] * 255 * 255 * 255 * 255 ) +
								           ( scene.pickingPixelBuffer2[ index + 2 ] * 255 * 255 * 255 );

							}

                            // Save unique cell nums
                            if ( cellNum > 0 && cellNums.indexOf( cellNum ) === -1 ) {

                                cellNums.push( cellNum );

                            }

                        }

                    }

                }

                if ( this.pickDepth === PickDepthEnum.Closest ) {

					// Convert from cellNum to object+index
                    this.concatObjectsFromCellNums( this.intersects, scene, cellNums );

                }

            } else {

				// Skip if ray missed this scene's viewport
				if ( this.pickRayX < scene.viewportPixelX ||
				     this.pickRayX > ( scene.viewportPixelX + scene.viewportPixelWidth ) ||
				     this.pickRayY < scene.viewportPixelTop ||
				     this.pickRayY > ( scene.viewportPixelTop + scene.viewportPixelHeight ) ) {

					continue;

				}

				// Translate pixel on viewport to pixel on canvas
				var pickX = this.pickRayX - scene.viewportPixelX;
				var pickY = this.pickRayY - scene.viewportPixelTop;

				// Offset due to panned scene
				if ( scene.div.panOffsetX ) { pickX -= ( scene.div.panOffsetX + scene.div.baseLeft ); }
				if ( scene.div.panOffsetY ) { pickY -= ( scene.div.panOffsetY + scene.div.baseTop ); }

				// Pick all objects using CPU (THREE.Raycaster)
                if ( this.pickDepth === PickDepthEnum.All ) {

					var rayX = ( pickX / scene.pixelWidth ) * 2 - 1;
					var rayY = ( ( scene.pixelHeight - pickY - 1 ) / scene.pixelHeight ) * 2 - 1;

                    this.raycaster.setFromCamera( new Vector2( rayX, rayY ), scene.camera );

					// Additions for custom point raycasting (see Points.js)
					this.raycaster.scene = scene;
					this.raycaster.x = pickX;
					this.raycaster.y = pickY;

                    var rayIntersects = this.raycaster.intersectObjects( scene.children, true );

					this.intersects = this.intersects.concat( rayIntersects );

				// Pick closest object using GPU (picking render target)
                } else {

                    var index = ( pickX + ( ( scene.pixelHeight - pickY - 1 ) * scene.pixelWidth ) ) * 4;

					var cellNum = ( scene.pickingPixelBuffer[ index     ] * 255 * 255 ) +
					              ( scene.pickingPixelBuffer[ index + 1 ] * 255 ) +
					              ( scene.pickingPixelBuffer[ index + 2 ] );

					if ( scene.pickingPixelBuffer2 ) {

						cellNum += ( scene.pickingPixelBuffer2[ index     ] * 255 * 255 * 255 * 255 * 255 ) +
						           ( scene.pickingPixelBuffer2[ index + 1 ] * 255 * 255 * 255 * 255 ) +
						           ( scene.pickingPixelBuffer2[ index + 2 ] * 255 * 255 * 255 );

					}

					// Convert from cellNum to object+index
                    this.concatObjectsFromCellNums( this.intersects, scene, [ cellNum ] );

                }

            }

        }

		// Send event to any listeners
		for ( var s = 0; s < this.selectionListeners.length; s ++ ) {

			this.selectionListeners[ s ]();

		}

	},

	getPickedCells: function() {

		var selectionList = [];

        for ( var i = 0; i < this.intersects.length; i ++ ) {

			var object = this.intersects[ i ].object;

			if ( object.userData.pickable === false ) {

				continue;

			}

            // Select this object (and its cells) if it isn't already
			var index = object.isMesh ? this.intersects[ i ].faceIndex : this.intersects[ i ].index;
			var objectAlreadySelected = false;

			for ( var j = 0; j < selectionList.length; j ++ ) {

				// Add new index if the object has already been selected
				if ( object === selectionList[ j ].object ) {

					objectAlreadySelected = true;
					var indexAlreadySelected = false;

					for ( var k = 0; k < selectionList[ j ].indices.length; k ++ ) {

						if ( index === selectionList[ j ].indices[ k ] ) {

							indexAlreadySelected = true;
							break;

						}

					}

					// But only if the index hasn't been added already
					if ( ! indexAlreadySelected ) {

						selectionList[ j ].indices.push( index );

					}

					break;

				}

			}

			if ( ! objectAlreadySelected ) {

				selectionList.push( {

					object: object,
					indices: [ index ]

				} );

			}

		}

		return selectionList;

	},

	getPickedCellSets: function() {

		var selectionList = [];

        for ( var i = 0; i < this.intersects.length; i ++ ) {

			var object = this.intersects[ i ].object;

			if ( object.userData.pickable === false ) {

				continue;

			}

            // Select this object if it isn't already
            var alreadySelected = false;

            for ( var j = 0; j < selectionList.length; j ++ ) {

                if ( selectionList[ j ].object === object ) {

                    alreadySelected = true;
                    break;

                }

            }

            if ( ! alreadySelected ) {

				selectionList.push( { object: object } );

			}

		}

		return selectionList;

	},

	getPickedSceneNodes: function() {

		var selectionList = [];

        for ( var i = 0; i < this.intersects.length; i ++ ) {

			var object = this.intersects[ i ].object;

			if ( object.userData.pickable === false ) {

				continue;

			}

            // Select this object's parent if it isn't already
            var parent = object.parent;
			var alreadySelected = false;

			for ( var k = 0; k < selectionList.length; k ++ ) {

				if ( selectionList[ k ].object === parent ) {

					alreadySelected = true;
					break;

				}

			}

			if ( ! alreadySelected ) {

				selectionList.push( { object: parent } );

			}

		}

		return selectionList;

	},

	getSelectionInfo: function( selectionList ) {

		var selectionInfo = [];

        for ( var i = 0; i < selectionList.length; i ++ ) {

            var object = selectionList[ i ].object;
			var indices = selectionList[ i ].indices;

			// If selecting cells need one selectionInfo entry for every cell
			if ( indices !== undefined ) {

				for ( var j = 0; j < indices.length; j ++ ) {

					selectionInfo.push( getSelectionInfoObject( object, {}, indices[ j ] ) );

				}

			} else {

				selectionInfo.push( getSelectionInfoObject( object, {} ) );

			}

		}

		function getSelectionInfoObject( object, info, index ) {

			// Check us then each of our parents until we find all the info we need
			var checkParent = false;

			if ( info.seriesIndex === undefined ) {

				if ( object.userData.seriesIndex !== undefined ) {

					info.seriesIndex = object.userData.seriesIndex;

				} else {

					checkParent = true;

				}

			}

			if ( info.itemIndex === undefined ) {

				if ( object.userData.itemIndex !== undefined ) {

					if ( index !== undefined && Array.isArray( object.userData.itemIndex ) ) {

						info.itemIndex = object.userData.itemIndex[ index ];

					} else {

						info.itemIndex = object.userData.itemIndex;

					}

				} else {

					checkParent = true;

				}

			}

			if ( info.componentInfo === undefined ) {

				if ( object.userData.componentInfo !== undefined ) {

					if ( index !== undefined && Array.isArray( object.userData.componentInfo ) ) {

						info.componentInfo = decodeURIComponent( object.userData.componentInfo[ index ] );

					} else if ( Array.isArray( object.userData.componentInfo ) ) {

						info.componentInfo = decodeURIComponent( '[' + object.userData.componentInfo + ']' );

					} else {

						info.componentInfo = decodeURIComponent( object.userData.componentInfo );

					}

				} else {

					checkParent = true;

				}

			}

			if ( checkParent && object.parent ) {

				return getSelectionInfoObject( object.parent, info );

			}

			return info;

		}

		return selectionInfo;

	},

	highlightObjects: function( selectionList, highlightLayer ) {

		var fullRender = false;

		// Restore highlighted objects to their regular state
		for ( var i = 0; i < this.highlightList.length; i ++ ) {

			var object = this.highlightList[ i ];

			// Restore original material
			if ( object.saveMaterial !== undefined ) {

				object.material = object.saveMaterial;
				object.saveMaterial = undefined;

				fullRender = true;

			}

			// Restore original geometry
			if ( object.saveGeometry !== undefined ) {

				object.geometry = object.saveGeometry;
				object.saveGeometry = undefined;

				fullRender = true;

			}

		}

		// Clear out the cloned objects from each highlight scene
        for ( var i = 0; i < this.scenes.length; i ++ ) {

			var highlightObjects = this.scenes[ i ].highlightScene.children[ 0 ].children;

			if ( highlightObjects.length > 0 ) {

				highlightObjects.length = 0;

				this.updateHighlight = true;

			}

		}

        this.highlightList.length = 0;

		var scope = this;

        // Highlight selected objects, either by changing color in-place
		// or cloning and rendering them in front
        for ( var i = 0; i < selectionList.length; i ++ ) {

            var object = selectionList[ i ].object;
			var indices = selectionList[ i ].indices;

			highlightObject( object, indices );

        }

		function highlightObject( object, indices ) {

			if ( object.isMesh || object.isLineSegments || object.isPoints ) {

				scope.highlightList.push( object );

				// Clone the material
				var highlightMaterial = object.material.clone();
				highlightMaterial.opacity = 1.0;

				var highlightGeometry;

				// If selecting cells need to process color attribute
				if ( indices !== undefined ) {

					var geometry = object.geometry;

					highlightMaterial.vertexColors = true;
					highlightMaterial.color = new Color( 0xffffff );

					if ( object.isThickLineSegments ) {

						highlightGeometry = new InstancedBufferGeometry();

						var oldInstancedColorStart = geometry.attributes.instancedColorStart;
						var colorBuffer;

						if ( oldColorStart === undefined ) {

							// Create new color buffer
							colorBuffer = new InstancedInterleavedBuffer( new Float32Array( geometry.attributes.instanceStart.array.length ), 6, 1 );

							// Color all cells with material color
							var count = 0;
							for ( var j = 0; j < colorBuffer.array.length / 3; j ++ ) {

								colorBuffer.array[ count ++ ] = object.material.color.r;
								colorBuffer.array[ count ++ ] = object.material.color.g;
								colorBuffer.array[ count ++ ] = object.material.color.b;

							}

						} else {

							// Clone existing color buffer
							colorBuffer = oldColorStart.data.clone();

						}

						// Update the selected cells
						var count = null;
						var length = null;

						for ( var j = 0; j < indices.length; j ++ ) {

							count = 6 * Math.floor( indices[ j ] / 6 );
							length = 2;

							for ( var k = 0; k < length; k ++ ) {

								colorBuffer.array[ count ++ ] = scope.highlightColor.r;
								colorBuffer.array[ count ++ ] = scope.highlightColor.g;
								colorBuffer.array[ count ++ ] = scope.highlightColor.b;

							}

						}

						highlightGeometry.setAttribute( 'instancedColorStart', new InterleavedBufferAttribute( colorBuffer, 3, 0 ) );
						highlightGeometry.setAttribute( 'instancedColorEnd', new InterleavedBufferAttribute( colorBuffer, 3, 3 ) );

						// Copy attributes other than instancedColorStart/instancedColorEnd over as-is
						for ( var name in geometry.attributes ) {

							if ( name !== 'instancedColorStart' && name !== 'instancedColorEnd' ) {

								highlightGeometry.setAttribute( name, geometry.attributes[ name ] );

							}

						}

					} else { // ! isThickLineSegments

						highlightGeometry = object.material.glyphs ? new InstancedBufferGeometry() : new BufferGeometry();

						var oldAttribute = geometry.attributes.color;
						var attribute = null;

						if ( oldAttribute === undefined ) {

							// Create new color attribute
							if ( object.material.glyphs ) {

								attribute = new InstancedBufferAttribute( new Float32Array( geometry.attributes.offset.array.length ), 3 );

							} else {
							
								attribute = new Float32BufferAttribute( geometry.attributes.position.array.length, 3 );

							}

							// Color all cells with material color
							var count = 0;
							for ( var j = 0; j < attribute.array.length / 3; j ++ ) {

								attribute.array[ count ++ ] = object.material.color.r;
								attribute.array[ count ++ ] = object.material.color.g;
								attribute.array[ count ++ ] = object.material.color.b;

							}

						} else {

							// Clone existing color attribute
							attribute = oldAttribute.clone();

						}

						// Update the selected cells
						var count = null;
						var length = null;

						for ( var j = 0; j < indices.length; j ++ ) {

							if ( object.material.glyphs || object.cellType === CellTypeEnum.Points ) { // THREE.Points or glyphs

								count = 3 * indices[ j ];
								length = 1;

							} else if ( object.cellType === CellTypeEnum.Lines ) { // THREE.LineSegments

								count = 3 * indices[ j ];
								length = 2;

							} else if ( object.cellType === CellTypeEnum.Triangles ) { // THREE.Mesh tris

								count = 9 * indices[ j ];
								length = 3;

							} else { // THREE.Mesh quads

								count = 18 * Math.floor( indices[ j ] / 2 ); // highlight this tri and its pair
								length = 6;

							}

							for ( var k = 0; k < length; k ++ ) {

								attribute.array[ count ++ ] = scope.highlightColor.r;
								attribute.array[ count ++ ] = scope.highlightColor.g;
								attribute.array[ count ++ ] = scope.highlightColor.b;

							}

						}

						highlightGeometry.setAttribute( 'color', attribute );

						// Copy attributes other than color over as-is
						for ( var name in geometry.attributes ) {

							if ( name !== 'color' ) {

								highlightGeometry.setAttribute( name, geometry.attributes[ name ] );

							}

						}

					}

				// Selecting cellSets or sceneNodes, use material color
				} else {

					highlightMaterial.vertexColors = false;
					highlightMaterial.color = scope.highlightColor;

					// No change to geometry
					highlightGeometry = object.geometry;

				}

				var scene = scope.getObjectScene( object );

				// Clone object and add it to the highlight scene to be rendered separately
				if ( scene.userData.is3D !== undefined && scene.userData.is3D === false &&
				     highlightLayer !== undefined && highlightLayer === true ) {

					var clonedObj = object.clone();

					clonedObj.material = highlightMaterial;
					clonedObj.geometry = highlightGeometry;

					clonedObj.matrixAutoUpdate = false;
					clonedObj.matrix.copy( object.matrixWorld );

					scene.highlightScene.children[ 0 ].add( clonedObj );

					scope.updateHighlight = true;

				// Change the object's color in-place and re-render everything
				} else {

					object.saveMaterial = object.material;
					object.material = highlightMaterial;

					object.saveGeometry = object.geometry;
					object.geometry = highlightGeometry;

					fullRender = true;

				}

			}

			for ( var i = 0; i < object.children.length; i ++ ) {

				highlightObject( object.children[ i ] );

			}

		}

		// Re-render everything or just the highlight scenes
		if ( fullRender ) {

			this.render( true );

		} else if ( this.updateHighlight ) {

			this.highlightRender();
			this.updateHighlight = false;

		}

    },

	/**
	 * Traverse up this object's parents to find the scene it belongs to.
	 */
    getObjectScene: function( object ) {

        if ( object.isScene ) {

            return object;

        }

        return this.getObjectScene( object.parent );

    }

};

// This set of controls performs rotation, scaling, and panning.

function TransformInteractor( domElement ) {

	if ( domElement === undefined ) console.warn( 'AVS.Three.TransformInteractor: The first parameter "domElement" is now mandatory.' );
	if ( domElement === document ) console.error( 'AVS.Three.TransformInteractor: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

	this.domElement = domElement;

	// Empty object, scene until we set something
	this.object = new Object3D();
	this.scene = null;

	// Set to false to disable this control
	this.enabled = true;

	// Set to false to disable scaling
	this.enableScale = true;

	// Set to false to disable rotating
	this.enableRotate = true;

	// Set to false to disable panning
	this.enablePan = true;

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

	// Touch fingers
	this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.SCALE_PAN };

	// for reset
	this.rotation0 = this.object.rotation.clone();
	this.scale0 = this.object.scale.clone();
	this.position0 = this.object.position.clone();

	//
	// public methods
	//
		
	this.setObjectScene = function( object, scene ) {

		scope.object = object;
		scope.scene = scene;

		scope.rotation0.copy( scope.object.rotation );
		scope.scale0.copy( scope.object.scale );
		scope.position0.copy( scope.object.position );

		if ( object.userData.mouseWheelScrollActions ) {

			mouseWheelScrollActions = JSON.parse( object.userData.mouseWheelScrollActions );

		}

		if ( object.userData.pointerTriggers ) {

			pointerTriggers = JSON.parse( object.userData.pointerTriggers );

		}

	};

	this.reset = function () {

		scope.object.rotation.copy( scope.rotation0 );
		scope.object.scale.copy( scope.scale0 );
		scope.object.position.copy( scope.position0 );

		scope.dispatchEvent( changeEvent );

		state = STATE.NONE;

	};

	this.zoomIn = function () {
		
		if ( scaleToPoint( 1.05, 0.0, 0.0 ) ) {

			scope.dispatchEvent( changeEvent );

		}

	};

	this.zoomOut = function () {
		
		if ( scaleToPoint( 1 / 1.05, 0.0, 0.0 ) ) {

			scope.dispatchEvent( changeEvent );

		}

	};

	this.dispose = function () {

		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );

		scope.domElement.removeEventListener( 'pointerdown', onPointerDown, false );
		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

		scope.domElement.removeEventListener( 'keydown', onKeyDown, false );

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = {
		NONE: - 1,
		ROTATE: 0,
		SCALE: 1,
		PAN: 2,
		TOUCH_ROTATE: 3,
		TOUCH_PAN: 4,
		TOUCH_SCALE_PAN: 5,
		TOUCH_SCALE_ROTATE: 6
	};

	var state = STATE.NONE;

	var mouseWheelScrollActions = [ { "modifiers": 0, "param": "ZOOM_AT_POINTER" } ];

	var pointerTriggers = [
		{ "buttons": 1, "modifiers": 0, "param": "ROTATE" },
		{ "buttons": 2, "modifiers": 0, "param": "SCALE" },
		{ "buttons": 4, "modifiers": 0, "param": "TRANSLATE" }
	];

	var rotateStart = new Vector2();
	var rotateEnd = new Vector2();

	var panStart = new Vector2();
	var panEnd = new Vector2();

	var scaleStart = new Vector2();
	var scaleEnd = new Vector2();

	function ndcClientX( event ) {

		var adjustX = event.clientX - scope.scene.viewportDiv.getBoundingClientRect().left;

		return ( ( adjustX - scope.scene.viewportX ) / ( scope.scene.viewportWidth / 2.0 ) ) - 1.0;

	}

	function ndcClientY( event ) {

		var adjustY = event.clientY - scope.scene.viewportDiv.getBoundingClientRect().top;

		return 1.0 - ( ( adjustY - scope.scene.viewportTop ) / ( scope.scene.viewportHeight / 2.0 ) );

	}

	var rotate = function () {

		var total = new Matrix4();
		var origin = new Vector3();
		var s3 = new Vector3();
		var e3 = new Vector3();
		var invTotal = new Matrix4();
		var axis = new Vector3();
		var len, theta;
		var quat = new Quaternion();

		return function rotate() {

			if ( scope.object === null || scope.object.parent === null ) return false;

			total.multiplyMatrices( scope.scene.camera.matrixWorldInverse, scope.object.parent.matrixWorld ); // parent's modelViewMatrix
			
			origin.set( 0, 0, 0 );
			s3.set( rotateStart.x, rotateStart.y, 1 );
			e3.set( rotateEnd.x, rotateEnd.y, 1 );

			invTotal.getInverse( total );

			origin.applyMatrix4( invTotal );
			s3.applyMatrix4( invTotal );
			e3.applyMatrix4( invTotal );

			s3.sub( origin ).normalize();
			e3.sub( origin ).normalize();

			if ( scope.scene.userData.is3D !== undefined && scope.scene.userData.is3D === false ) {

				axis.set( 0, 0, 1 );

				len = s3.x * e3.y - s3.y * e3.x;
				if ( len < 0 ) {

					axis.negate();
					len = -len;

				}

			} else {

				axis.crossVectors( s3, e3 );

				len = axis.length();

			}

			if ( len < 0.00001 ) return false;

			if ( Math.abs( len ) < 1 ) {

				theta = 2 * Math.sin( len );

			} else {

				theta = Math.PI;

			}

			if ( s3.dot( e3 ) < 0 ) {

				theta += ( 0.5 * Math.PI );

			}

			quat.setFromAxisAngle( axis.normalize(), theta );
			scope.object.quaternion.premultiply( quat );

			return true;

		};

	}();

	var pan = function () {

		var total = new Matrix4();
		var origin = new Vector4();
		var o3 = new Vector3();
		var invTotal = new Matrix4();
		var start = new Vector4();
		var end = new Vector4();
		var s3 = new Vector3();
		var e3 = new Vector3();
		var delta = new Vector3();

		return function pan() {

			if ( scope.object === null || scope.object.parent === null ) return false;

			total.multiplyMatrices( scope.scene.camera.matrixWorldInverse, scope.object.parent.matrixWorld ); // parent's modelViewMatrix
			total.premultiply( scope.scene.camera.projectionMatrix );

			origin.set( 0, 0, 0, 1 ).applyMatrix4( total );

			o3.set( origin.x / origin.w, origin.y / origin.w, origin.z / origin.w );

			invTotal.getInverse( total );

			// Place the 2 mouse points on the same plane as the
			// projection of the origin. This does the Z scaling
			// as if the 2 points were in the XY plane. That isn't
			// really correct. We should project them into a plane
			// that is parallel to the screen
			start.set( panStart.x, panStart.y, o3.z, 1 );
			end.set( panEnd.x, panEnd.y, o3.z, 1 );

			// back transform
			start.applyMatrix4( invTotal );
			end.applyMatrix4( invTotal );

			s3.set( start.x / start.w, start.y / start.w, start.z / start.w );
			e3.set( end.x / end.w, end.y / end.w, end.z / end.w );

			// Calculate the translation in model coordinates.
			delta.subVectors( e3, s3 );

			scope.object.position.add( delta );

			return true;

		};

	}();

	function scale( scaleDelta ) {

		if ( scope.object === null ) return false;

		scope.object.scale.multiplyScalar( scaleDelta );

		return true;

	}

	var scaleToPoint = function() {

		var total = new Matrix4();
		var invTotal = new Matrix4();
		var origin = new Vector4();
		var zoomPt = new Vector4();
		var pt3 = new Vector3();
		var v3 = new Vector3();

		return function( scaleDelta, ndcX, ndcY ) {

			if ( scope.object === null || scope.object.parent === null ) return false;

			total.multiplyMatrices( scope.scene.camera.matrixWorldInverse, scope.object.parent.matrixWorld ); // parent's modelViewMatrix
			total.premultiply( scope.scene.camera.projectionMatrix );

			origin.set( 0, 0, 0, 1 ).applyMatrix4( total );

			invTotal.getInverse( total );

			zoomPt.set( ndcX, ndcY, origin.z / origin.w, 1 ).applyMatrix4( invTotal );

			pt3.set( zoomPt.x / zoomPt.w, zoomPt.y / zoomPt.w, zoomPt.z / zoomPt.w );

			pt3.sub( scope.object.position );

			v3.copy( pt3 ).multiplyScalar( scaleDelta ).add( pt3.negate() );

			scope.object.scale.multiplyScalar( scaleDelta );
			scope.object.position.sub( v3 );

			return true;

		};

	}();

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate( event ) {

		rotateStart.set( ndcClientX( event ), ndcClientY( event ) );

	}

	function handleMouseDownScale( event ) {

		scaleStart.set( ndcClientX( event ), ndcClientY( event ) );

	}

	function handleMouseDownPan( event ) {

		panStart.set( ndcClientX( event ), ndcClientY( event ) );

	}

	function handleMouseMoveRotate( event ) {
		
		rotateEnd.set( ndcClientX( event ), ndcClientY( event ) );

		if ( rotate() ) {

			scope.dispatchEvent( changeEvent );

		}

		rotateStart.copy( rotateEnd );

	}

	function handleMouseMoveScale( event ) {
		
		scaleEnd.set( ndcClientX( event ), ndcClientY( event ) );

		var dx = scaleEnd.x - scaleStart.x;
		var dy = scaleEnd.y - scaleStart.y;

		var offset = ( Math.abs( dx ) > Math.abs( dy ) ) ? dx : dy;

		var scaleDelta;
		if ( offset > 0 ) {

			scaleDelta = 1 + 0.5 * offset;

		} else {

			scaleDelta = 1 / ( 1 - 0.5 * offset );

		}

		if ( scale( scaleDelta ) ) {

			scope.dispatchEvent( changeEvent );

		}

		scaleStart.copy( scaleEnd );

	}

	function handleMouseMovePan( event ) {
		
		panEnd.set( ndcClientX( event ), ndcClientY( event ) );

		if ( pan() ) {

			scope.dispatchEvent( changeEvent );

		}

		panStart.copy( panEnd );

	}

	function handleMouseWheelScale( event ) {

		var scaleDelta = event.deltaY > 0 ? 1 / 1.05 : 1.05;

		if ( scale( scaleDelta ) ) {

			scope.dispatchEvent( changeEvent );

		}

	}

	function handleMouseWheelScaleToPointer( event ) {

		var scaleDelta = event.deltaY > 0 ? 1 / 1.05 : 1.05;
		
		if ( scaleToPoint( scaleDelta, ndcClientX( event ), ndcClientY( event ) ) ) {

			scope.dispatchEvent( changeEvent );

		}

	}

	function handleKeyDown( event ) {

		var needsUpdate = false;

		panStart.set( 0, 0 );
		panEnd.set( 0, 0 );

		switch ( event.keyCode ) {

			case scope.keys.UP:
				panEnd.y = scope.keyPanSpeed / ( scope.scene.height / 2.0 );
				needsUpdate = true;
				break;

			case scope.keys.BOTTOM:
				panEnd.y = - scope.keyPanSpeed / ( scope.scene.height / 2.0 );
				needsUpdate = true;
				break;

			case scope.keys.LEFT:
				panEnd.x = scope.keyPanSpeed / ( scope.scene.width / 2.0 );
				needsUpdate = true;
				break;

			case scope.keys.RIGHT:
				panEnd.x = - scope.keyPanSpeed / ( scope.scene.width / 2.0 );
				needsUpdate = true;
				break;

		}

		if ( needsUpdate ) {

			pan();

			// prevent the browser from scrolling on cursor keys
			event.preventDefault();

			scope.dispatchEvent( changeEvent );

		}


	}

	function handleTouchStartRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateStart.set( x, y );

		}

	}

	function handleTouchStartPan( event ) {

		if ( event.touches.length == 1 ) {

			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panStart.set( x, y );

		}

	}

	function handleTouchStartScale( event ) {

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		scaleStart.set( 0, distance );

	}

	function handleTouchStartScalePan( event ) {

		if ( scope.enableScale ) handleTouchStartScale( event );

		if ( scope.enablePan ) handleTouchStartPan( event );

	}

	function handleTouchStartScaleRotate( event ) {

		if ( scope.enableScale ) handleTouchStartScale( event );

		if ( scope.enableRotate ) handleTouchStartRotate( event );

	}

	function handleTouchMoveRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateEnd.set( x, y );

		}

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

	}

	function handleTouchMovePan( event ) {

		if ( event.touches.length == 1 ) {

			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panEnd.set( x, y );

		}

		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

	}

	function handleTouchMoveScale( event ) {

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		scaleEnd.set( 0, distance );

		scaleDelta.set( 0, Math.pow( scaleEnd.y / scaleStart.y, scope.zoomSpeed ) );

		scaleOut( scaleDelta.y );

		scaleStart.copy( scaleEnd );

	}

	function handleTouchMoveScalePan( event ) {

		if ( scope.enableScale ) handleTouchMoveScale( event );

		if ( scope.enablePan ) handleTouchMovePan( event );

	}

	function handleTouchMoveScaleRotate( event ) {

		if ( scope.enableScale ) handleTouchMoveScale( event );

		if ( scope.enableRotate ) handleTouchMoveRotate( event );

	}

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onPointerDown( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseDown( event );
				break;

			// TODO touch

		}

	}

	function onPointerMove( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseMove( event );
				break;

			// TODO touch

		}

	}

	function onPointerUp( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseUp();
				break;

			// TODO touch

		}

	}

	function onMouseDown( event ) {

		// Prevent the browser from scrolling.
		event.preventDefault();

		// Manually set the focus since calling preventDefault above
		// prevents the browser from setting it automatically.

		scope.domElement.focus ? scope.domElement.focus() : window.focus();

		var modifiers = 0;

		modifiers += ( event.shiftKey ? 1 : 0 );
		modifiers += ( event.ctrlKey ? 2 : 0 );
		modifiers += ( event.metaKey ? 4 : 0 );

		var mouseButton = 0;

		switch ( event.button ) {

			case 0: // LEFT

				mouseButton = 1;
				break;

			case 1: // MIDDLE

				mouseButton = 2;
				break;

			case 2: // RIGHT

				mouseButton = 4;
				break;

		}

		for ( var i = 0, l = pointerTriggers.length; i < l; i ++ ) {

			if ( ( modifiers === pointerTriggers[ i ].modifiers ) && ( mouseButton & pointerTriggers[ i ].buttons ) ) {

				switch ( pointerTriggers[ i ].param ) {

					case 0:
					case "ROTATE":

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

						scope.domElement.ownerDocument.body.style.cursor = 'move';

						break;

					case 1:
					case "SCALE":

						if ( scope.enableScale === false ) return;

						handleMouseDownScale( event );

						state = STATE.SCALE;

						scope.domElement.ownerDocument.body.style.cursor = 'ne-resize';

						break;

					case 2:
					case "TRANSLATE":

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

						scope.domElement.ownerDocument.body.style.cursor = 'move';

						break;

					default:

						state = STATE.NONE;

				}

				if ( state !== STATE.NONE ) {

					scope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove, false );
					scope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp, false );

					scope.dispatchEvent( startEvent );

				}

				return;

			}

		}

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( state ) {

			case STATE.ROTATE:

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

				break;

			case STATE.SCALE:

				if ( scope.enableScale === false ) return;

				handleMouseMoveScale( event );

				break;

			case STATE.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

				break;

		}

	}

	function onMouseUp( event ) {

		if ( scope.enabled === false ) return;

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

		scope.domElement.ownerDocument.body.style.cursor = 'default';

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onMouseWheel( event ) {

		if ( scope.enabled === false || state !== STATE.NONE ) return;

		var modifiers = 0;

		modifiers += ( event.shiftKey ? 1 : 0 );
		modifiers += ( event.ctrlKey ? 2 : 0 );
		modifiers += ( event.metaKey ? 4 : 0 );

		for ( var i = 0, l = mouseWheelScrollActions.length; i < l; i ++ ) {

			if ( modifiers === mouseWheelScrollActions[ i ].modifiers ) {

				event.preventDefault();
				event.stopPropagation();

				switch ( mouseWheelScrollActions[ i ].param ) {

					case 0:
					case "ZOOM":

						scope.dispatchEvent( startEvent );

						handleMouseWheelScale( event );
						
						scope.dispatchEvent( endEvent );

						break;

					case 1:
					case "ZOOM_AT_POINTER":
		
						scope.dispatchEvent( startEvent );

						handleMouseWheelScaleToPointer( event );

						scope.dispatchEvent( endEvent );

						break;

				}

				return;

			}

		}

	}

	function onKeyDown( event ) {

		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

		handleKeyDown( event );

	}

	function onTouchStart( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling

		switch ( event.touches.length ) {

			case 1:

				switch ( scope.touches.ONE ) {

					case TOUCH.ROTATE:

						if ( scope.enableRotate === false ) return;

						handleTouchStartRotate( event );

						state = STATE.TOUCH_ROTATE;

						break;

					case TOUCH.PAN:

						if ( scope.enablePan === false ) return;

						handleTouchStartPan( event );

						state = STATE.TOUCH_PAN;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			case 2:

				switch ( scope.touches.TWO ) {

					case TOUCH.SCALE_PAN:

						if ( scope.enableScale === false && scope.enablePan === false ) return;

						handleTouchStartScalePan( event );

						state = STATE.TOUCH_SCALE_PAN;

						break;

					case TOUCH.SCALE_ROTATE:

						if ( scope.enableScale === false && scope.enableRotate === false ) return;

						handleTouchStartScaleRotate( event );

						state = STATE.TOUCH_SCALE_ROTATE;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.dispatchEvent( startEvent );

		}

	}

	function onTouchMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling
		event.stopPropagation();

		switch ( state ) {

			case STATE.TOUCH_ROTATE:

				if ( scope.enableRotate === false ) return;

				handleTouchMoveRotate( event );

				scope.update();

				break;

			case STATE.TOUCH_PAN:

				if ( scope.enablePan === false ) return;

				handleTouchMovePan( event );

				scope.update();

				break;

			case STATE.TOUCH_SCALE_PAN:

				if ( scope.enableScale === false && scope.enablePan === false ) return;

				handleTouchMoveScalePan( event );

				scope.update();

				break;

			case STATE.TOUCH_SCALE_ROTATE:

				if ( scope.enableScale === false && scope.enableRotate === false ) return;

				handleTouchMoveScaleRotate( event );

				scope.update();

				break;

			default:

				state = STATE.NONE;

		}

	}

	function onTouchEnd( event ) {

		if ( scope.enabled === false ) return;

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onContextMenu( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

	}

	//

	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

	scope.domElement.addEventListener( 'pointerdown', onPointerDown, false );
	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

	scope.domElement.addEventListener( 'keydown', onKeyDown, false );

}
TransformInteractor.prototype = Object.create( EventDispatcher.prototype );
TransformInteractor.prototype.constructor = TransformInteractor;

TransformInteractor.prototype.isTransformInteractor = true;

// This set of controls performs panning of a domain.
//
//    Pan - left mouse / touch: one-finger move

function PanInteractor( domElement ) {

	if ( domElement === undefined ) console.warn( 'AVS.Three.PanInteractor: The first parameter "domElement" is now mandatory.' );
	if ( domElement === document ) console.error( 'AVS.Three.PanInteractor: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

	// Dummy object until we set something
//	this.object = new Object3D();

	this.linkObjectsBottom = [];
	this.linkObjectsTop = [];
	this.linkObjectsLeft = [];
	this.linkObjectsRight = [];

	this.domElement = domElement;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new Vector3();

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = false;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = false;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.panSpeed = 1.0;
	this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.NONE, RIGHT: MOUSE.NONE };

	// Touch fingers
	this.touches = { ONE: TOUCH.PAN, TWO: TOUCH.NONE };

	// for reset
//	this.target0 = this.target.clone();
//	this.position0 = this.object.position.clone();
//	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.saveState = function () {

		scope.target0.copy( scope.target );
		scope.position0.copy( scope.object.position );
		scope.zoom0 = scope.object.zoom;

	};

	this.reset = function () {

		scope.target.copy( scope.target0 );
		scope.object.position.copy( scope.position0 );
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent( changeEvent );

		scope.update();

		state = STATE.NONE;

	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = function () {

		var obj = null;

		return function update() {

			if ( scope.object === undefined || scope.object.style === undefined ) {

				return;

			}

			// Check limits

			if ( panOffset.x > scope.object.leftLimit ) {

				panOffset.x = scope.object.leftLimit;

			} else if ( panOffset.x < scope.object.rightLimit ) {

				panOffset.x = scope.object.rightLimit;

			}

			if ( panOffset.y < scope.object.bottomLimit ) {

				panOffset.y = scope.object.bottomLimit;

			} else if ( panOffset.y > scope.object.topLimit ) {

				panOffset.y = scope.object.topLimit;

			}

			// Main object

			scope.object.panOffsetX = panOffset.x;
			scope.object.panOffsetY = panOffset.y;

			scope.object.style.left = ( scope.object.baseLeft + panOffset.x ) + 'px';
			scope.object.style.top = ( scope.object.baseTop + panOffset.y ) + 'px';

			// Bottom objects

			for ( var i = 0; i < scope.linkObjectsBottom.length; i ++ ) {

				obj = scope.linkObjectsBottom[ i ];

				obj.style.left = ( obj.baseLeft + panOffset.x ) + 'px';

			}

			// Top objects

			for ( var i = 0; i < scope.linkObjectsTop.length; i ++ ) {

				obj = scope.linkObjectsTop[ i ];

				obj.style.left = ( obj.baseLeft + panOffset.x ) + 'px';

			}

			// Left objects

			for ( var i = 0; i < scope.linkObjectsLeft.length; i ++ ) {

				obj = scope.linkObjectsLeft[ i ];

				obj.style.top = ( obj.baseTop + panOffset.y ) + 'px';

			}

			// Right objects

			for ( var i = 0; i < scope.linkObjectsRight.length; i ++ ) {

				obj = scope.linkObjectsRight[ i ];

				obj.style.top = ( obj.baseTop + panOffset.y ) + 'px';

			}

			scope.dispatchEvent( changeEvent );

		};

	}();

	this.dispose = function () {

		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );

		scope.domElement.removeEventListener( 'pointerdown', onPointerDown, false );
		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

		scope.domElement.removeEventListener( 'keydown', onKeyDown, false );

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = {
		NONE: - 1,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2,
		TOUCH_ROTATE: 3,
		TOUCH_PAN: 4,
		TOUCH_DOLLY_PAN: 5,
		TOUCH_DOLLY_ROTATE: 6
	};

	var state = STATE.NONE;

	// current rotation in spherical coordinates
	var sphericalDelta = new Spherical();

	var panOffset = new Vector3();

	var rotateStart = new Vector2();
	var rotateEnd = new Vector2();
	var rotateDelta = new Vector2();

	var panStart = new Vector2();
	var panEnd = new Vector2();
	var panDelta = new Vector2();

	var dollyStart = new Vector2();
	var dollyEnd = new Vector2();
	var dollyDelta = new Vector2();

	function getZoomScale() {

		return Math.pow( 0.95, scope.zoomSpeed );

	}

	function rotateLeft( angle ) {

		sphericalDelta.theta += angle;

	}

	function rotateUp( angle ) {

		sphericalDelta.phi += angle;

	}

	var panLeft = function () {

		var v = new Vector3(1, 0, 0);

		return function panLeft( distance, objectMatrix ) {

			v.set( 1, 0, 0 );
			v.multiplyScalar( distance );

			panOffset.add( v );

		};

	}();

	var panUp = function () {

		var v = new Vector3(0, 1, 0);

		return function panUp( distance, objectMatrix ) {

			v.set( 0, 1, 0 );
			v.multiplyScalar( - distance );

			panOffset.add( v );

		};

	}();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = function () {

		var offset = new Vector3();

		return function pan( deltaX, deltaY ) {

//			var element = scope.domElement;

//			if ( scope.object.camera.isOrthographicCamera ) {

//				var changeX = ( deltaX / element.clientWidth ) * ( scope.object.camera.right - scope.object.camera.left ) / scope.object.camera.zoom;

				panOffset.x += deltaX;
/*
				if ( changeX < 0 ) {

					var xLimit = scope.object.leftLimit;

					if ( panOffset.x < xLimit ) {

						panOffset.x = xLimit;

					}

				} else if ( changeX > 0 ) {

					var xLimit = scope.object.rightLimit;

					if ( panOffset.x > xLimit ) {

						panOffset.x = xLimit;

					}

				}
*/
//				var changeY = ( deltaY / element.clientHeight ) * ( scope.object.camera.top - scope.object.camera.bottom ) / scope.object.camera.zoom;

				panOffset.y += deltaY;
/*
				if ( changeY > 0 ) {

					var yLimit = scope.object.bottomLimit;

					if ( panOffset.y < yLimit ) {

						panOffset.y = yLimit;

					}

				} else if ( changeY < 0 ) {

					var yLimit = scope.object.topLimit;

					if ( panOffset.y > yLimit ) {

						panOffset.y = yLimit;

					}

				}
*/
//			} else {

				// camera not orthographic
//				console.warn( 'WARNING: AVS.Three.PanInteractor encountered an unknown camera type - pan disabled.' );
//				scope.enablePan = false;

//			}

		};

	}();

	function dollyOut( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) ; else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: AVS.Three.PanInteractor encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	function dollyIn( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) ; else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: AVS.Three.PanInteractor encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate( event ) {

		rotateStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownDolly( event ) {

		dollyStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownPan( event ) {

		panStart.set( event.clientX, event.clientY );

	}

	function handleMouseMoveRotate( event ) {

		rotateEnd.set( event.clientX, event.clientY );

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleMouseMoveDolly( event ) {

		dollyEnd.set( event.clientX, event.clientY );

		dollyDelta.subVectors( dollyEnd, dollyStart );

		if ( dollyDelta.y > 0 ) {

			dollyOut( getZoomScale() );

		} else if ( dollyDelta.y < 0 ) {

			dollyIn( getZoomScale() );

		}

		dollyStart.copy( dollyEnd );

		scope.update();

	}

	function handleMouseMovePan( event ) {

		panEnd.set( event.clientX, event.clientY );

		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

		scope.update();

	}

	function handleMouseWheel( event ) {

		if ( event.deltaY < 0 ) {

			dollyIn( getZoomScale() );

		} else if ( event.deltaY > 0 ) {

			dollyOut( getZoomScale() );

		}

		scope.update();

	}

	function handleKeyDown( event ) {

		var needsUpdate = false;

		switch ( event.keyCode ) {

			case scope.keys.UP:
				pan( 0, scope.keyPanSpeed );
				needsUpdate = true;
				break;

			case scope.keys.BOTTOM:
				pan( 0, - scope.keyPanSpeed );
				needsUpdate = true;
				break;

			case scope.keys.LEFT:
				pan( scope.keyPanSpeed, 0 );
				needsUpdate = true;
				break;

			case scope.keys.RIGHT:
				pan( - scope.keyPanSpeed, 0 );
				needsUpdate = true;
				break;

		}

		if ( needsUpdate ) {

			// prevent the browser from scrolling on cursor keys
			event.preventDefault();

			scope.update();

		}


	}

	function handleTouchStartRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateStart.set( x, y );

		}

	}

	function handleTouchStartPan( event ) {

		if ( event.touches.length == 1 ) {

			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panStart.set( x, y );

		}

	}

	function handleTouchStartDolly( event ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

	function handleTouchStartDollyPan( event ) {

		if ( scope.enableZoom ) handleTouchStartDolly( event );

		if ( scope.enablePan ) handleTouchStartPan( event );

	}

	function handleTouchStartDollyRotate( event ) {

		if ( scope.enableZoom ) handleTouchStartDolly( event );

		if ( scope.enableRotate ) handleTouchStartRotate( event );

	}

	function handleTouchMoveRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateEnd.set( x, y );

		}

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

	}

	function handleTouchMovePan( event ) {

		if ( event.touches.length == 1 ) {

			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panEnd.set( x, y );

		}

		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

	}

	function handleTouchMoveDolly( event ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

	function handleTouchMoveDollyPan( event ) {

		if ( scope.enableZoom ) handleTouchMoveDolly( event );

		if ( scope.enablePan ) handleTouchMovePan( event );

	}

	function handleTouchMoveDollyRotate( event ) {

		if ( scope.enableZoom ) handleTouchMoveDolly( event );

		if ( scope.enableRotate ) handleTouchMoveRotate( event );

	}

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onPointerDown( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseDown( event );
				break;

			// TODO touch

		}

	}

	function onPointerMove( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseMove( event );
				break;

			// TODO touch

		}

	}

	function onPointerUp( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseUp();
				break;

			// TODO touch

		}

	}

	function onMouseDown( event ) {

		// Prevent the browser from scrolling.
		event.preventDefault();

		// Manually set the focus since calling preventDefault above
		// prevents the browser from setting it automatically.

		scope.domElement.focus ? scope.domElement.focus() : window.focus();

		var mouseAction;

		switch ( event.button ) {

			case 0:

				mouseAction = scope.mouseButtons.LEFT;
				break;

			case 1:

				mouseAction = scope.mouseButtons.MIDDLE;
				break;

			case 2:

				mouseAction = scope.mouseButtons.RIGHT;
				break;

			default:

				mouseAction = - 1;

		}

		switch ( mouseAction ) {

			case MOUSE.DOLLY:

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

				break;

			case MOUSE.ROTATE:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( scope.enablePan === false ) return;

					handleMouseDownPan( event );

					state = STATE.PAN;

				} else {

					if ( scope.enableRotate === false ) return;

					handleMouseDownRotate( event );

					state = STATE.ROTATE;

				}

				break;

			case MOUSE.PAN:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( scope.enableRotate === false ) return;

					handleMouseDownRotate( event );

					state = STATE.ROTATE;

				} else {

					if ( scope.enablePan === false ) return;

					handleMouseDownPan( event );

					state = STATE.PAN;

					scope.domElement.ownerDocument.body.style.cursor = 'move';

				}

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove, false );
			scope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp, false );

			scope.dispatchEvent( startEvent );

		}

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( state ) {

			case STATE.ROTATE:

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

				break;

			case STATE.DOLLY:

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

				break;

			case STATE.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

				break;

		}

	}

	function onMouseUp( event ) {

		if ( scope.enabled === false ) return;

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

		scope.domElement.ownerDocument.body.style.cursor = 'default';

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onMouseWheel( event ) {

		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

		event.preventDefault();
		event.stopPropagation();

		scope.dispatchEvent( startEvent );

		handleMouseWheel( event );

		scope.dispatchEvent( endEvent );

	}

	function onKeyDown( event ) {

		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

		handleKeyDown( event );

	}

	function onTouchStart( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling

		switch ( event.touches.length ) {

			case 1:

				switch ( scope.touches.ONE ) {

					case TOUCH.ROTATE:

						if ( scope.enableRotate === false ) return;

						handleTouchStartRotate( event );

						state = STATE.TOUCH_ROTATE;

						break;

					case TOUCH.PAN:

						if ( scope.enablePan === false ) return;

						handleTouchStartPan( event );

						state = STATE.TOUCH_PAN;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			case 2:

				switch ( scope.touches.TWO ) {

					case TOUCH.DOLLY_PAN:

						if ( scope.enableZoom === false && scope.enablePan === false ) return;

						handleTouchStartDollyPan( event );

						state = STATE.TOUCH_DOLLY_PAN;

						break;

					case TOUCH.DOLLY_ROTATE:

						if ( scope.enableZoom === false && scope.enableRotate === false ) return;

						handleTouchStartDollyRotate( event );

						state = STATE.TOUCH_DOLLY_ROTATE;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.dispatchEvent( startEvent );

		}

	}

	function onTouchMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling
		event.stopPropagation();

		switch ( state ) {

			case STATE.TOUCH_ROTATE:

				if ( scope.enableRotate === false ) return;

				handleTouchMoveRotate( event );

				scope.update();

				break;

			case STATE.TOUCH_PAN:

				if ( scope.enablePan === false ) return;

				handleTouchMovePan( event );

				scope.update();

				break;

			case STATE.TOUCH_DOLLY_PAN:

				if ( scope.enableZoom === false && scope.enablePan === false ) return;

				handleTouchMoveDollyPan( event );

				scope.update();

				break;

			case STATE.TOUCH_DOLLY_ROTATE:

				if ( scope.enableZoom === false && scope.enableRotate === false ) return;

				handleTouchMoveDollyRotate( event );

				scope.update();

				break;

			default:

				state = STATE.NONE;

		}

	}

	function onTouchEnd( event ) {

		if ( scope.enabled === false ) return;

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onContextMenu( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

	}

	//

	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

	scope.domElement.addEventListener( 'pointerdown', onPointerDown, false );
	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

	scope.domElement.addEventListener( 'keydown', onKeyDown, false );

	// make sure element can receive keys.

	if ( scope.domElement.tabIndex === - 1 ) {

		scope.domElement.tabIndex = 0;

	}

	// force an update at start

	this.update();

}
PanInteractor.prototype = Object.create( EventDispatcher.prototype );
PanInteractor.prototype.constructor = PanInteractor;

PanInteractor.prototype.isPanInteractor = true;

export { CellTypeEnum, DEFAULT_VIEWER_HEIGHT, DEFAULT_VIEWER_WIDTH, PanInteractor, PickDepthEnum, PickLevelEnum, PickTypeEnum, RAYCASTER_LINE_PRECISION, REVISION, TransformInteractor, Viewer };
