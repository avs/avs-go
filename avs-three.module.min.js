import { Group as Group$1, Matrix4, Vector3, Points as Points$1, LineSegments as LineSegments$1, Mesh as Mesh$1, PointLight as PointLight$1, DirectionalLight as DirectionalLight$1, AmbientLight as AmbientLight$1, OrthographicCamera as OrthographicCamera$1, PerspectiveCamera as PerspectiveCamera$1, Scene as Scene$1, Matrix3, Vector2, Color, UniformsUtils, UniformsLib as UniformsLib$1, ShaderMaterial, LessEqualDepth, AlwaysStencilFunc, KeepStencilOp, Loader, FileLoader, Vector4, Plane, Float32BufferAttribute, Box3, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Ray, Object3D, LoaderUtils, BufferGeometryLoader, LoadingManager, ImageLoader, CubeTexture, Texture, Fog, FogExp2, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, Raycaster, WebGLRenderTarget, InstancedBufferAttribute, BufferGeometry, EventDispatcher, TOUCH, Quaternion, MOUSE, Spherical } from 'three';

var REVISION = '1';
var DEFAULT_VIEWER_WIDTH = 400;
var DEFAULT_VIEWER_HEIGHT = 400;
var RAYCASTER_LINE_PRECISION = 0.03;
var PickDepthEnum = {
		All : 0,    
		Closest : 1 
	};
var PickTypeEnum = {
		Ray : 0,
		Rectangle : 1
	};
var PickLevelEnum = {
		Cell : 0,    
		CellSet : 1,
		SceneNode : 2
	};
var CellTypeEnum = {
		Points : 1,
		Lines : 2,
		Triangles : 3,
		Quads : 4
	};

class Group extends Group$1 {

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

}

const _position = new Vector3();

class Points extends Points$1 {

	constructor( geometry, material ) {

		super( geometry, material );

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

    /*
     * GO-165
     * Custom point raycasting by projecting each point position through the camera
     * and expanding by the pixel size (either from material or attribute).
     * Instead of using the Raycaster directly and the Points threshold.
     */
	raycast( raycaster, intersects ) {

		const attributes = this.geometry.attributes;
		const positions = attributes.position.array;

		let size = 0.5;
		if ( this.material.vertexSizes === undefined ) size = this.material.size / 2;

		let x, y;
		let minx, maxx, miny, maxy;

		// Assume non-indexed BufferGeometry
		for ( let i = 0, l = positions.length / 3; i < l; i ++ ) {

			_position.fromArray( positions, i * 3 );
			_position.applyMatrix4( this.matrixWorld );
			_position.project( raycaster.camera );

			x = ( ( _position.x + 1 ) / 2 ) * raycaster.scene.width;
			y = ( 1 - ( _position.y + 1 ) / 2 ) * raycaster.scene.height;
			
			if ( this.material.vertexSizes ) size = attributes.vsize.array[ i ] / 2;

			minx = x - size; maxx = x + size;
			miny = y - size; maxy = y + size;

			if ( raycaster.x >= minx && raycaster.x <= maxx && raycaster.y >= miny && raycaster.y <= maxy ) {

				intersects.push( {

					distance: null,
					distanceToRay: null,
					point: null,
					index: i,
					face: null,
					object: this

				} );

			}

		}

	}

}

class LineSegments extends LineSegments$1 {

	constructor( geometry, material ) {

		super( geometry, material );

	}

	toJSON( meta ) {

		const data = super.toJSON( this, meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

}

const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceOrientationMatrix = new Matrix4();

const _instanceIntersects = [];

const _mesh = new Mesh$1();

class Mesh extends Mesh$1 {

	constructor( geometry, material ) {

		super( geometry, material );

	}

	raycast( raycaster, intersects ) {

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined || _mesh.geometry === undefined ) return;

		// No glyphs, raycast normally
		if ( ! _mesh.material.glyphs ) return super.raycast( raycaster, intersects );

		const matrixWorld = this.matrixWorld;
		const offsetArray = _mesh.geometry.attributes.offset.array;
		const nInstances = offsetArray.length / 3;
		let vec3Index, scaleArray, orientationArray0, orientationArray1, orientationArray2;

		for ( let i = 0; i < nInstances; i ++ ) {

			vec3Index = 3 * i;

			// Calculate the world matrix for each instance

			if ( _mesh.material.vertexScales ) {

				scaleArray = _mesh.geometry.attributes.scale.array;
				_instanceLocalMatrix.makeScale( scaleArray[ vec3Index ], scaleArray[ vec3Index + 1 ], scaleArray[ vec3Index + 2 ] );

			} else {

				_instanceLocalMatrix.makeScale( _mesh.material.scale.x, _mesh.material.scale.y, _mesh.material.scale.z );

			}

			if ( _mesh.material.vertexOrientations ) {

				orientationArray0 = _mesh.geometry.attributes.orientation0.array;
				orientationArray1 = _mesh.geometry.attributes.orientation1.array;
				orientationArray2 = _mesh.geometry.attributes.orientation2.array;

				_instanceOrientationMatrix.set( orientationArray0[ vec3Index     ], orientationArray1[ vec3Index     ], orientationArray2[ vec3Index ], 0,
				                                orientationArray0[ vec3Index + 1 ], orientationArray1[ vec3Index + 1 ], orientationArray2[ vec3Index + 1 ], 0,
				                                orientationArray0[ vec3Index + 2 ], orientationArray1[ vec3Index + 2 ], orientationArray2[ vec3Index + 2 ], 0,
				                                0, 0, 0, 1 );

				_instanceLocalMatrix.multiply( _instanceOrientationMatrix );

			}

			_instanceLocalMatrix.setPosition( offsetArray[ vec3Index ], offsetArray[ vec3Index + 1 ], offsetArray[ vec3Index + 2 ] );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// _mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// Process the result of raycast

			if ( _instanceIntersects.length > 0 ) {

				const intersect = _instanceIntersects[ 0 ];
				intersect.faceIndex = i;
				intersect.object = this;
				intersects.push( intersect );


			}

			_instanceIntersects.length = 0;

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

}

class PointLight extends PointLight$1 {

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.Light.toJSON()
		if ( this.color.getHex() === 16777215 ) data.object.color = undefined;
		if ( this.intensity === 1 ) data.object.intensity = undefined;
		data.object.shadow = undefined;

		return data;

	}

}

class DirectionalLight extends DirectionalLight$1 {

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.Light.toJSON()
		if ( this.color.getHex() === 16777215 ) data.object.color = undefined;
		if ( this.intensity === 1 ) data.object.intensity = undefined;
		data.object.shadow = undefined;

		return data;

	}

}

class AmbientLight extends AmbientLight$1 {

	toJSON( meta ) {

		const data = super.toJSON( meta );
		
		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.Light.toJSON()
		if ( this.color.getHex() === 16777215 ) data.object.color = undefined;
		if ( this.intensity === 1 ) data.object.intensity = undefined;

		return data;

	}

}

class OrthographicCamera extends OrthographicCamera$1 {

	constructor( left, right, top, bottom, near, far ) {

		super( left, right, top, bottom, near, far );

		this.keepAspectRatio = false;

		this.origLeft = left;
		this.origRight = right;

		this.origTop = top;
		this.origBottom = bottom;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.OrthographicCamera.toJSON()
		if ( this.zoom === 1 ) data.object.zoom = undefined;
		if ( this.left === - 1 ) data.object.left = undefined;
		if ( this.right === 1 ) data.object.right = undefined;
		if ( this.top === 1 ) data.object.top = undefined;
		if ( this.bottom === - 1 ) data.object.bottom = undefined;
		if ( this.near === 0.1 ) data.object.near = undefined;
		if ( this.far === 2000 ) data.object.far = undefined;

		if ( this.keepAspectRatio ) data.object.keepAspectRatio = true;

		return data;

	}

}

class PerspectiveCamera extends PerspectiveCamera$1 {

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		// Override THREE.PerspectiveCamera.toJSON()
		if ( this.fov === 50 ) data.object.fov = undefined;
		if ( this.zoom === 1 ) data.object.zoom = undefined;
		if ( this.near === 0.1 ) data.object.near = undefined;
		if ( this.far === 2000 ) data.object.far = undefined;
		if ( this.focus === 10 ) data.object.focus = undefined;
		if ( this.aspect === 1 ) data.object.aspect = undefined;
		if ( this.filmGauge === 35 ) data.object.filmGauge = undefined;
		if ( this.filmOffset === 0 ) data.object.filmOffset = undefined;

		return data;

	}

}

class Scene extends Scene$1 {

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Object3D.toJSON()
		data.metadata = undefined;
		if ( this.layers.mask === 1 ) data.object.layers = undefined;
		if ( this.matrix.equals( new Matrix4() ) ) data.object.matrix = undefined;

		return data;

	}

}

const UniformsLib = {

	base: {

		pickState: { value: new Float32Array( 1 ) },
		startCell: { value: 0 },
		uscale: { value: new Vector3( 1, 1, 1 ) },
		uorientation: { value: new Matrix3() }

	},

	line: {

		linePattern: { value: 0xffff },
		resolution: { value: new Vector2( 1, 1 ) }

	},

	mesh: {

		stipple: { value: 0 },
		stippleColor: { value: new Color( 0x000000 ) },
		stipplePattern: { value: new Float32Array( 64 ) }

	}

};

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t}\n}";

var points_vert = "attribute float vsize;\nattribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float size;\nuniform float pickState[ 1 ];\nuniform float startCell;\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <color_vertex>\n\t#include <begin_vertex>\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n#else\n\ttransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n#else\n\ttransformed = uorientation * transformed;\n#endif\n\ttransformed += offset;\n#endif\n\t#include <project_vertex>\n#ifdef USE_SIZE\n\tgl_PointSize = vsize;\n#else\n\tgl_PointSize = size;\n#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var line_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float linePattern;\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#ifdef USE_PATTERN\nvarying float vPattern;\n#endif\nvarying float vDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tfloat pattern;\n#ifdef USE_PATTERN\n\tpattern = floor( vPattern );\n#else\n\tpattern = linePattern;\n#endif\n\tfloat shift = pow( 2.0, floor( mod( vDistance, 16.0 ) ) );\n\tif( mod( floor( pattern / shift ), 2.0 ) < 0.5 ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t}\n}";

var line_vert = "attribute vec3 otherPosition;\nattribute float pattern;\nattribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float pickState[ 1 ];\nuniform float startCell;\nuniform vec2 resolution;\n#ifdef USE_PATTERN\nvarying float vPattern;\n#endif\nvarying float vDistance;\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <color_vertex>\n\tvec3 transformed = vec3( position );\n\tvec3 otherTransformed = vec3( otherPosition );\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n\totherTransformed *= scale;\n#else\n\ttransformed *= uscale;\n\totherTransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n\totherTransformed = orientation * otherTransformed;\n#else\n\ttransformed = uorientation * transformed;\n\totherTransformed = uorientation * otherTransformed;\n#endif\n\ttransformed += offset;\n\totherTransformed += offset;\n#endif\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\tvec2 ndcPos1 = gl_Position.xy / gl_Position.w;\n\tvec4 other_Position = projectionMatrix * modelViewMatrix * vec4( otherTransformed, 1.0 );\n\tvec2 ndcPos2 = other_Position.xy / other_Position.w;\n\tfloat aspect = resolution.x / resolution.y;\n\tvec2 dir = ndcPos2 - ndcPos1;\n\tdir.x *= aspect;\n\tbool end = false;\n\tif ( dir.y < -EPSILON ) {\n\t\tend = true;\n\t}\n\telse if ( dir.y > EPSILON ) {\n\t\tend = false;\n\t}\n\telse if ( dir.x < -EPSILON ) {\n\t\tend = true;\n\t}\n\tvDistance = end ? 0.0 : length( dir * resolution ) / 2.0;\n#ifdef USE_PATTERN\n\tvPattern = pattern + 0.5;\n#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var thickline_vert = "attribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nattribute float instancePattern;\nattribute float instanceLinewidthStart;\nattribute float instanceLinewidthEnd;\nattribute float cellCount;\nuniform float pickState[ 1 ];\nuniform float startCell;\nuniform float linewidth;\nuniform vec2 resolution;\n#ifdef USE_PATTERN\nvarying float vPattern;\n#endif\nvarying float vDistance;\nvarying vec3 vPickColor;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n#ifdef USE_COLOR\n\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart.xyz : instanceColorEnd.xyz;\n#endif\n#ifdef USE_PATTERN\n\tvPattern = instancePattern + 0.5;\n#endif\n\tfloat widthFactor, avgWidthFactor;\n#ifdef USE_LINEWIDTH\n\twidthFactor = ( position.y < 0.5 ) ? instanceLinewidthStart : instanceLinewidthEnd;\n\tavgWidthFactor = ( instanceLinewidthStart + instanceLinewidthEnd ) / 2.0;\n#else\n\twidthFactor = avgWidthFactor = linewidth;\n#endif\n\tfloat aspect = resolution.x / resolution.y;\n\tvec4 start = vec4( instanceStart, 1.0 );\n\tvec4 end = vec4( instanceEnd, 1.0 );\n#ifdef LINEWIDTH_SCALE\n\tvec2 xyStart = start.xy;\n\tvec2 xyEnd = end.xy;\n\tvec2 scaleDir = xyEnd - xyStart;\n\tscaleDir = normalize( scaleDir );\n\tvec2 scaleOffset = vec2( scaleDir.y, -scaleDir.x );\n\tscaleOffset.y /= aspect;\n\tif ( position.x < 0.5 ) scaleOffset *= -1.0;\n\tscaleOffset *= ( widthFactor * 0.5 );\n\tvec4 startEnd = ( position.y < 0.5 ) ? start : end;\n\tvec4 scaleClip = vec4( startEnd );\n\tscaleClip.xy += scaleOffset;\n\tvec4 scalePosition = projectionMatrix * modelViewMatrix * scaleClip;\n\tvec4 scalePosition2 = projectionMatrix * modelViewMatrix * startEnd;\n\twidthFactor = length( scalePosition2.xy - scalePosition.xy ) * resolution.y * 2.0;\n#endif\n\tif ( widthFactor < 1.0 ) {\n\t\twidthFactor = 1.0;\n\t}\n\tif ( avgWidthFactor < 1.0 ) {\n\t\tavgWidthFactor = 1.0;\n\t}\n\tvec4 mvStart = modelViewMatrix * start;\n\tvec4 mvEnd = modelViewMatrix * end;\n\tvec4 clipStart = projectionMatrix * mvStart;\n\tvec4 clipEnd = projectionMatrix * mvEnd;\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\tvec2 dir = ndcEnd - ndcStart;\n\tvec2 dirOrig = dir;\n\tdir.x *= aspect;\n\tdir = normalize( dir );\n\tvec2 offset = vec2( dir.y, -dir.x );\n\tdir.x /= aspect;\n\toffset.x /= aspect;\n\tif ( position.x < 0.5 ) offset *= -1.0;\n\toffset += ( position.y < 0.5 ) ? -dir * 0.3 : dir * 0.3;\n\toffset *= widthFactor;\n\tdir *= widthFactor;\n\toffset /= resolution.y;\n\tdir /= resolution.y;\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\toffset *= clip.w;\n\tclip.xy += offset;\n\tif ( clip.z > -1.0 ) {\n\t\tclip.z -= 5.0e-4;\n\t\tif ( clip.z < -1.0 ) clip.z = -1.0;\n\t}\n\tgl_Position = clip;\n\tvDistance = ( position.y < 0.5 ) ? 0.0 : ( length( dirOrig * resolution ) + 2.0 * length( dir * resolution ) ) / avgWidthFactor / 2.0;\n\tvec4 mvPosition = ( position.y < 0.5 ) ? mvStart : mvEnd;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag = "uniform float stipple;\nuniform vec3 stippleColor;\nuniform vec4 stipplePattern[ 16 ];\nuniform vec3 diffuse;\nuniform float opacity;\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tif ( stipple > 0.5 ) {\n\t\tvec2 coord = floor( mod( gl_FragCoord.xy, 32.0 ) );\n\t\tint index = int( floor( coord.x / 64.0 ) + ( coord.y / 2.0 ) );\n\t\tint comp = int( floor( coord.x / 16.0 ) + mod( coord.y , 2.0 ) * 2.0 );\n\t\tfor ( int i = 0; i < 16; i ++ ) {\n\t\t\tif ( i == index ) {\n\t\t\t\tfloat shift = pow( 2.0, floor( mod( gl_FragCoord.x, 16.0 ) ) );\n\t\t\t\tfloat shortPattern;\n\t\t\t\tif ( comp == 0 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].x;\n\t\t\t\t} else if ( comp == 1 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].y;\n\t\t\t\t} else if ( comp == 2 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].z;\n\t\t\t\t} else {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].w;\n\t\t\t\t}\n\t\t\t\tif ( mod( floor( shortPattern / shift ), 2.0 ) > 0.5 ) {\n\t\t\t\t\tdiffuseColor = vec4( stippleColor, opacity );\n\t\t\t\t} else if ( stipple < 1.5 ) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\t}\n}";

var meshbasic_vert = "attribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float pickState[ 1 ];\nuniform float startCell;\nvarying vec3 vPickColor;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n#else\n\ttransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n#else\n\ttransformed = uorientation * transformed;\n#endif\n\ttransformed += offset;\n#endif\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphong_frag = "uniform float ambientIntensity;\nuniform float diffuseIntensity;\nuniform float stipple;\nuniform vec3 stippleColor;\nuniform vec4 stipplePattern[ 16 ];\nuniform float pickState[ 1 ];\nvarying vec3 vPickColor;\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tgl_FragColor = vec4( vPickColor, 1.0 );\n\t} else {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\tif ( stipple > 0.5 ) {\n\t\tvec2 coord = floor( mod( gl_FragCoord.xy, 32.0 ) );\n\t\tint index = int( floor( coord.x / 64.0 ) + ( coord.y / 2.0 ) );\n\t\tint comp = int( floor( coord.x / 16.0 ) + mod( coord.y , 2.0 ) * 2.0 );\n\t\tfor ( int i = 0; i < 16; i ++ ) {\n\t\t\tif ( i == index ) {\n\t\t\t\tfloat shift = pow( 2.0, floor( mod( gl_FragCoord.x, 16.0 ) ) );\n\t\t\t\tfloat shortPattern;\n\t\t\t\tif ( comp == 0 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].x;\n\t\t\t\t} else if ( comp == 1 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].y;\n\t\t\t\t} else if ( comp == 2 ) {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].z;\n\t\t\t\t} else {\n\t\t\t\t\tshortPattern = stipplePattern[ i ].w;\n\t\t\t\t}\n\t\t\t\tif ( mod( floor( shortPattern / shift ), 2.0 ) > 0.5 ) {\n\t\t\t\t\tdiffuseColor = vec4( stippleColor, opacity );\n\t\t\t\t} else if ( stipple < 1.5 ) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\tvec3 outgoingLight = ( reflectedLight.directDiffuse * diffuseIntensity ) + ( reflectedLight.indirectDiffuse * ambientIntensity ) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\t}\n}";

var meshphong_vert = "attribute float cellCount;\nattribute vec3 offset;\nattribute vec3 scale;\nuniform vec3 uscale;\nattribute vec3 orientation0;\nattribute vec3 orientation1;\nattribute vec3 orientation2;\nuniform mat3 uorientation;\nuniform float pickState[ 1 ];\nuniform float startCell;\nvarying vec3 vPickColor;\n#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tif ( pickState[ 0 ] > 0.5 ) {\n\t\tfloat cellNum = startCell + cellCount;\n\t\t\n\t\tfloat red = fract( cellNum / (255.0*255.0*255.0) );\n\t\tif ( pickState[ 0 ] > 1.5 ) {\n\t\n\t\t\tfloat red2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat green2 = fract( cellNum / (255.0*255.0*255.0*255.0*255.0) );\n\t\t\tfloat blue2 = fract( cellNum / (255.0*255.0*255.0*255.0) );\n\t\n\t\t\tred2 -= green2 / 255.0;\n\t\t\tgreen2 -= blue2 / 255.0;\n\t\t\tblue2 -= red / 255.0;\n\t\t\tvPickColor = vec3( red2, green2, blue2 );\n\t\t} else {\n\t\t\tfloat green = fract( cellNum / (255.0*255.0) );\n\t\t\tfloat blue = fract( cellNum / 255.0 );\n\t\t\tred -= green / 255.0;\n\t\t\tgreen -= blue / 255.0;\n\t\t\tvPickColor = vec3( red, green, blue );\n\t\t}\n\t}\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n#ifdef GLYPH\n#ifdef USE_SCALE\n\ttransformed *= scale;\n#else\n\ttransformed *= uscale;\n#endif\n#ifdef USE_ORIENTATION\n\tmat3 orientation = mat3( orientation0, orientation1, orientation2 );\n\ttransformed = orientation * transformed;\n#else\n\ttransformed = uorientation * transformed;\n#endif\n\ttransformed += offset;\n#endif\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const ShaderChunk = {
	points_frag: points_frag,
	points_vert: points_vert,
	line_frag: line_frag,
	line_vert: line_vert,
	thickline_vert: thickline_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert
};

const ShaderLib = {

	points: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.points,
			UniformsLib$1.fog,
			UniformsLib.base
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	line: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib.base,
			UniformsLib.line
		] ),

		vertexShader: ShaderChunk.line_vert,
		fragmentShader: ShaderChunk.line_frag

	},

	thick: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib.base,
			UniformsLib.line,
			{
				linewidth: { value: 1 }
			}
		] ),

		vertexShader: ShaderChunk.thickline_vert,
		fragmentShader: ShaderChunk.line_frag

	},

	basic: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib.base,
			UniformsLib.mesh
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	phong: {

		uniforms: UniformsUtils.merge( [
			UniformsLib$1.common,
			UniformsLib$1.fog,
			UniformsLib$1.lights,
			UniformsLib.base,
			UniformsLib.mesh,
			{
				ambientIntensity: { value: 0.31 },
				diffuseIntensity: { value: 0.7 },
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x1f1f1f ) },
				shininess: { value: 63.8386159788056 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	}

};

// Base class from which all our materials inherit the picking and glyph functionality

class BaseMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super();

		Object.defineProperties( this, {

			pickState: {

				get: function () {

					return this.uniforms.pickState.value;

				},

				set: function ( value ) {

					this.uniforms.pickState.value = value;

				}

			},

			startCell: {

				get: function () {

					return this.uniforms.startCell.value;

				},

				set: function ( value ) {

					this.uniforms.startCell.value = value;

				}

			},

			glyphs: {

				get: function () {

					return this.defines.GLYPH;

				},

				set: function ( value ) {

					this.defines.GLYPH = value;

				}

			},

			scale: {

				get: function () {

					return this.uniforms.uscale.value;

				},

				set: function ( value ) {

					this.uniforms.uscale.value = value;

				}

			},

			vertexScales: {

				get: function () {

					return this.defines.USE_SCALE;

				},

				set: function ( value ) {

					this.defines.USE_SCALE = value;

				}

			},

			orientation: {

				get: function () {

					return this.uniforms.uorientation.value;

				},

				set: function ( value ) {

					this.uniforms.uorientation.value = value;

				}

			},

			vertexOrientations: {

				get: function () {

					return this.defines.USE_ORIENTATION;

				},

				set: function ( value ) {

					this.defines.USE_ORIENTATION = value;

				}

			}

		} );

		this.color = new Color( 0xffffff );

		// Setting this populates THREE.UniformsLib.fog from the material
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		// Override THREE.Material.toJSON()
		if ( this.depthFunc === LessEqualDepth ) data.depthFunc = undefined;
		if ( this.depthTest === true ) data.depthTest = undefined;
		if ( this.depthWrite === true ) data.depthWrite = undefined;
		if ( this.stencilWrite === false ) data.stencilWrite = undefined;
		if ( this.stencilWriteMask === 0xff ) data.stencilWriteMask = undefined;
		if ( this.stencilFunc === AlwaysStencilFunc ) data.stencilFunc = undefined;
		if ( this.stencilRef === 0 ) data.stencilRef = undefined;
		if ( this.stencilFuncMask === 0xff ) data.stencilFuncMask = undefined;
		if ( this.stencilFail === KeepStencilOp ) data.stencilFail = undefined;
		if ( this.stencilZFail === KeepStencilOp ) data.stencilZFail = undefined;
		if ( this.stencilZPass === KeepStencilOp ) data.stencilZPass = undefined;

		if ( this.vertexScales ) data.vertexScales = true;
		if ( this.vertexOrientations ) data.vertexOrientations = true;

		return data;

	}

	equals( material ) {

		if ( material.color.getHex() !== this.color.getHex() ) {

			return false;

		}

		if ( material.opacity !== this.opacity ) {

			return false;

		}

		if ( material.transparent !== this.transparent ) {

			return false;

		}

		if ( material.side !== this.side ) {

			return false;

		}

		if ( material.vertexColors !== this.vertexColors ) {

			return false;

		}

		return true;

	}

}

class PointsMaterial extends BaseMaterial {

	constructor( parameters ) {

		super( {

			uniforms: UniformsUtils.clone( ShaderLib.points.uniforms ),

			vertexShader: ShaderLib.points.vertexShader,

			fragmentShader: ShaderLib.points.fragmentShader

		} );

		Object.defineProperties( this, {

			vertexSizes: {

				get: function () {

					return this.defines.USE_SIZE;

				},

				set: function ( value ) {

					this.defines.USE_SIZE = value;

				}

			}

		} );

		this.map = null;

		this.size = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.map = source.map;

		this.size = source.size;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.type = 'PointsMaterial';

		if ( this.vertexSizes ) data.vertexSizes = true;

		return data;

	}

	equals( material ) {

		if ( super.equals( material ) === false ) {

			return false;

		}

		if ( material.isPointsMaterial ) {

			return true;

		}

		return false;

	}

}

// Setting this populates THREE.UniformsLib.points from the material
PointsMaterial.prototype.isPointsMaterial = true;

class MeshBasicMaterial extends BaseMaterial {

	constructor( parameters ) {

		super( {

			uniforms: UniformsUtils.clone( ShaderLib.basic.uniforms ),

			vertexShader: ShaderLib.basic.vertexShader,

			fragmentShader: ShaderLib.basic.fragmentShader

		} );

		Object.defineProperties( this, {

			stipple: {

				get: function () {

					return this.uniforms.stipple.value;

				},

				set: function ( value ) {

					this.uniforms.stipple.value = value;

				}

			},

			stippleColor: {

				get: function () {

					return this.uniforms.stippleColor.value;

				},

				set: function ( value ) {

					this.uniforms.stippleColor.value = value;

				}

			},

			stipplePattern: {

				get: function () {

					return this.uniforms.stipplePattern.value;

				},

				set: function ( value ) {

					this.uniforms.stipplePattern.value = value;

				}

			}

		} );

		this.map = null;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( this, source );

		this.map = source.map;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.type = 'MeshBasicMaterial';

		if ( this.stipple !== 0 ) data.stipple = this.stipple;
		if ( this.stippleColor.getHex() !== 0x000000 ) data.stippleColor = this.stippleColor.getHex();
		if ( JSON.stringify( this.stipplePattern ) !== JSON.stringify( new Float32Array( 64 ) ) ) data.stipplePattern = Array.prototype.slice.call( this.stipplePattern );

		return data;

	}

	equals( material ) {

		if ( super.equals( material ) === false ) {

			return false;

		}

		if ( material.isMeshBasicMaterial || material.isMeshPhongMaterial ) {

			return true;

		}

		return false;

	}

}

// Setting this populates THREE.UniformsLib.common from the material
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

class MeshPhongMaterial extends MeshBasicMaterial {

	constructor( parameters ) {

		super( {

			uniforms: UniformsUtils.clone( ShaderLib.phong.uniforms ),

			vertexShader: ShaderLib.phong.vertexShader,

			fragmentShader: ShaderLib.phong.fragmentShader

		} );

		Object.defineProperties( this, {

			ambientIntensity: {

				get: function () {

					return this.uniforms.ambientIntensity.value;

				},

				set: function ( value ) {

					this.uniforms.ambientIntensity.value = value;

				}

			},
			diffuseIntensity: {


				get: function () {

					return this.uniforms.diffuseIntensity.value;

				},

				set: function ( value ) {

					this.uniforms.diffuseIntensity.value = value;

				}

			}

		} );

		this.specular = new Color( 0x1f1f1f );
		this.shininess = 63.8386159788056;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;

		// Setting this populates THREE.UniformsLib.lights from the material
		this.lights = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.type = 'MeshPhongMaterial';

		if ( this.ambientIntensity !== 0.31 ) data.ambientIntensity = this.ambientIntensity;
		if ( this.diffuseIntensity !== 0.7 ) data.diffuseIntensity = this.diffuseIntensity;

		// Override THREE.Material.toJSON()
		if ( this.specular.getHex() === 0x1f1f1f ) data.specular = undefined;
		if ( this.shininess === 63.8386159788056 ) data.shininess = undefined;

		return data;

	}

	equals( material ) {

		if ( super.equals( material ) === false ) {

			return false;

		}

		if ( material.isMeshPhongMaterial ) {

			if ( material.ambientIntensity !== this.ambientIntensity ) {

				return false;

			}

			if ( material.diffuseIntensity !== this.diffuseIntensity ) {

				return false;

			}

			if ( material.specular.getHex() !== this.specular.getHex() ) {

				return false;

			}

			if ( material.shininess !== this.shininess ) {

				return false;

			}

			return true;

		}

		return false;

	}

}

// Setting these populates the common, specular and shininess uniforms from the material
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.isMeshBasicMaterial = false;

class LineMaterial extends BaseMaterial {

	constructor( parameters ) {

		super( {

			uniforms: UniformsUtils.clone( ShaderLib.line.uniforms ),

			vertexShader: ShaderLib.line.vertexShader,

			fragmentShader: ShaderLib.line.fragmentShader

		} );

		Object.defineProperties( this, {

			pattern: {

				get: function () {

					return this.uniforms.linePattern.value;

				},

				set: function ( value ) {

					this.uniforms.linePattern.value = value;

				}

			},

			vertexPatterns: {

				get: function () {

					return this.defines.USE_PATTERN;

				},

				set: function ( value ) {

					this.defines.USE_PATTERN = value;

				}

			},

			resolution: {

				get: function () {

					return this.uniforms.resolution.value;

				},

				set: function ( value ) {

					this.uniforms.resolution.value = value;

				}

			}

		} );

		this.setValues( parameters );

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.type = 'LineMaterial';

		if ( this.pattern !== 0xffff ) data.pattern = this.pattern;
		if ( this.vertexPatterns ) data.vertexPatterns = true;

		return data;

	}

	equals( material ) {

		if ( super.equals( material ) === false ) {

			return false;

		}

		if ( material.isLineBasicMaterial ) {

			return true;

		}

		return false;

	}

}

// Setting this populates the diffuse and opacity uniforms from the material
LineMaterial.prototype.isLineBasicMaterial = true;

class ThickLineMaterial extends LineMaterial {

	constructor( parameters ) {

		super( {

			uniforms: UniformsUtils.clone( ShaderLib.thick.uniforms ),

			vertexShader: ShaderLib.thick.vertexShader,

			fragmentShader: ShaderLib.thick.fragmentShader

		} );

		Object.defineProperties( this, {

			linewidth: {

				get: function () {

					return this.uniforms.linewidth.value;

				},

				set: function ( value ) {

					this.uniforms.linewidth.value = value;

				}

			},

			vertexLinewidths: {

				get: function () {

					return this.defines.USE_LINEWIDTH;

				},

				set: function ( value ) {

					this.defines.USE_LINEWIDTH = value;

				}

			},

			linewidthScale: {

				get: function () {

					return this.defines.LINEWIDTH_SCALE;

				},

				set: function ( value ) {

					this.defines.LINEWIDTH_SCALE = value;

				}

			}

		} );

		this.setValues( parameters );

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.type = 'ThickLineMaterial';

		if ( this.vertexLinewidths ) data.vertexLinewidths = true;
		if ( this.linewidthScale ) data.linewidthScale = true;

		return data;

	}

	equals( material ) {

		if ( super.equals( material ) === false ) {

			return false;

		}

		if ( material.isThickLineMaterial ) {

			if ( material.vertexLinewidths !== this.vertexLinewidths ) {

				return false;

			}

			return true;

		}

		return false;

	}

}

ThickLineMaterial.prototype.isThickLineMaterial = true;

var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	PointsMaterial: PointsMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	LineMaterial: LineMaterial,
	ThickLineMaterial: ThickLineMaterial
});

/**
 *  AVS Revision 1.0: Original extracted from Three.js revision 82.
 *  AVS Revision 1.1: Load clipping planes
 *  AVS Revision 1.2: Load shaders from our library
 *  AVS Revision 1.3: Update to Three.js revision 85
 *  AVS Revision 1.4: Load our own PointsMaterial and LineMaterial
 *  AVS Revision 1.5: Update to Three.js revision 86
 *  AVS Revision 1.6: Support vertex line patterns in LineMaterial
 *  AVS Revision 1.7: Load our own MeshBasicMaterial and MeshPhongMaterial with stipple pattern
 *  AVS Revision 1.8: Support line widths in ThickLineMaterial
 *  AVS Revision 1.9: Update to Three.js revision 87
 *  AVS Revision 1.10: Update to Three.js revision 89
 *  AVS Revision 1.13: Use local FileLoader - reverted
 *  AVS Revision 1.14: Update to Three.js revision 92
 *  AVS Revision 1.15: Update to Three.js revision 96
 *  AVS Revision 1.16: Add MeshPhongMaterial ambient and diffuse parameters
 *  AVS Revision 1.17: Update to Three.js revision 98
 *  AVS Revision 1.18: Support vertex sizes in PointsMaterial
 *  AVS Revision 1.19: Update to Three.js revision 102
 *  AVS Revision 1.20: Update to Three.js revision 108
 *  AVS Revision 1.21: Update to Three.js revision 109
 *  AVS Revision 1.22: Update to Three.js revision 115
 *  AVS Revision 1.23: Rename MeshPhongMaterial ambient and diffuse intensity parameters
 *  AVS Revision 1.24: Update to three.js r117
 *  AVS Revision 1.25: Update to three.js r118
 *  AVS Revision 1.26: Update to three.js r121
 *  AVS Revision 1.27: Update to three.js r122
 *  AVS Revision 1.28: Add linewidthScale to ThickLineMaterial
 *  AVS Revision 1.29: Save transparent flag for GPU picking usage
 *  AVS Revision 1.30: Update to three.js r126
 *  AVS Revision 1.31: Update to three.js r131
 */

class MaterialLoader extends Loader {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				// AVS revision 1.0.  Message changed to use AVS.Three source
				console.warn( 'AVS.Three.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
		if ( json.specularTint !== undefined && material.specularTint !== undefined ) material.specularTint.setHex( json.specularTint );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.thickness !== undefined ) material.thickness = json.thickness;
		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
		if ( json.attenuationTint !== undefined && material.attenuationTint !== undefined ) material.attenuationTint.setHex( json.attenuationTint );
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		//if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		//if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		//if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for BaseMaterial

		if ( json.glyphs !== undefined ) material.glyphs = json.glyphs;
		if ( json.vertexScales !== undefined ) material.vertexScales = json.vertexScales;
		if ( json.scale !== undefined ) material.scale.fromArray( json.scale );
		if ( json.vertexOrientations !== undefined ) material.vertexOrientations = json.vertexOrientations;
		if ( json.orientation !== undefined ) material.orientation.fromArray( json.orientation );

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
		if ( json.vertexSizes !== undefined ) material.vertexSizes = json.vertexSizes;

		// for LineMaterial / ThickLineMaterial

		if ( json.pattern !== undefined ) material.pattern = json.pattern;
		if ( json.vertexPatterns !== undefined ) material.vertexPatterns = json.vertexPatterns;

		// for ThickLineMaterial

		if ( json.vertexLinewidths !== undefined ) material.vertexLinewidths = json.vertexLinewidths;
		// material.linewidth handled above
		if ( json.linewidthScale !== undefined ) material.linewidthScale = json.linewidthScale;

		// for MeshBasicMaterial / MeshPhongMaterial

		if ( json.stipple !== undefined ) material.stipple = json.stipple;
		if ( json.stippleColor !== undefined && material.stippleColor !== undefined ) material.stippleColor.setHex( json.stippleColor );
		if ( json.stipplePattern !== undefined ) material.stipplePattern = json.stipplePattern;

		// for MeshPhongMaterial

		if ( json.ambientIntensity !== undefined ) material.ambientIntensity = json.ambientIntensity;
		if ( json.diffuseIntensity !== undefined ) material.diffuseIntensity = json.diffuseIntensity;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
		if ( json.specularTintMap !== undefined ) material.specularTintMap = getTexture( json.specularTintMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

		// AVS revision 1.1.  Load clipping planes
		if ( json.clippingPlanes !== undefined ) {
				
			material.clippingPlanes = [];
				
			for ( let i = 0, l = json.clippingPlanes.length; i < l; i ++ ) {
					
				const thisPlane = json.clippingPlanes[ i ];
				const newPlane = new Plane( new Vector3 ( thisPlane.normal[0], thisPlane.normal[1], thisPlane.normal[2] ), thisPlane.constant );

				material.clippingPlanes.push( newPlane );
			}

		}

		// AVS revision 1.29.  Save transparent flag for GPU picking usage
		material.origTransparent = material.transparent;

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

}

class LinePatternBufferGeometryLoader {

	constructor( bufferGeometryLoader ) {

		this.bufferGeometryLoader = bufferGeometryLoader;

	}

	parse( json ) {

		const geometry = this.bufferGeometryLoader.parse( json );

		const position = geometry.attributes.position;

		if ( position !== undefined ) {

			const otherPosition = new Float32BufferAttribute( position.array.length, 3 );

			const nLines = position.array.length / 6;

			for ( let i = 0, l = nLines; i < l; i ++ ) {

				otherPosition.array[ i*6 + 0 ] = position.array[ i*6 + 3 ];
				otherPosition.array[ i*6 + 1 ] = position.array[ i*6 + 4 ];
				otherPosition.array[ i*6 + 2 ] = position.array[ i*6 + 5 ];

				otherPosition.array[ i*6 + 3 ] = position.array[ i*6 + 0 ];
				otherPosition.array[ i*6 + 4 ] = position.array[ i*6 + 1 ];
				otherPosition.array[ i*6 + 5 ] = position.array[ i*6 + 2 ];

			}

			geometry.setAttribute( 'otherPosition', otherPosition );

		}

		return geometry;

	}

}

const _box = new Box3();

const _vector = new Vector3();

class ThickLineSegmentsBufferGeometry extends InstancedBufferGeometry {

	constructor() {

		super();

		this.type = 'ThickLineSegmentsBufferGeometry';

		// Quad representing a single line segment
		const positions = [ 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0 ];
		this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	}

	applyMatrix4( matrix ) {

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined ) {

			start.applyMatrix4( matrix );
			end.applyMatrix4( matrix );
			start.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	setPositions( array ) {

		let lineSegments;

		if ( array instanceof Float32Array ) {

			lineSegments = array;

		} else if ( Array.isArray( array ) ) {

			lineSegments = new Float32Array( array );

		}

		const instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz

		this.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz
		this.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz

		//

		this.computeBoundingBox();
		this.computeBoundingSphere();

		return this;

	}

	setColors( array ) {

		let colors;

		if ( array instanceof Float32Array ) {

			colors = array;

		} else if ( Array.isArray( array ) ) {

			colors = new Float32Array( array );

		}

		const instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb

		this.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb
		this.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb

		return this;

	}

	setPatterns( array ) {

		let patterns;

		if ( array instanceof Float32Array ) {

			patterns = array;

		} else if ( Array.isArray( array ) ) {

			patterns = new Float32Array( array );

		}
	
		const instancePatternBuffer = new InstancedInterleavedBuffer( patterns, 2, 1 );

		this.setAttribute( 'instancePattern', new InterleavedBufferAttribute( instancePatternBuffer, 1, 0 ) );

		return this;

	}

	setLinewidths( array ) {

		let linewidths;

		if ( array instanceof Float32Array ) {

			linewidths = array;

		} else if ( Array.isArray( array ) ) {

			linewidths = new Float32Array( array );

		}

		const instanceLinewidthBuffer = new InstancedInterleavedBuffer( linewidths, 2, 1 );

		this.setAttribute( 'instanceLinewidthStart', new InterleavedBufferAttribute( instanceLinewidthBuffer, 1, 0 ) );
		this.setAttribute( 'instanceLinewidthEnd', new InterleavedBufferAttribute( instanceLinewidthBuffer, 1, 1 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined && end !== undefined ) {

			this.boundingBox.setFromBufferAttribute( start );

			_box.setFromBufferAttribute( end );

			this.boundingBox.union( _box );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		if ( this.boundingBox === null ) {

			this.computeBoundingBox();

		}

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined && end !== undefined ) {

			const center = this.boundingSphere.center;

			this.boundingBox.getCenter( center );

			let maxRadiusSq = 0;

			for ( let i = 0, il = start.count; i < il; i ++ ) {

				_vector.fromBufferAttribute( start, i );
				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

				_vector.fromBufferAttribute( end, i );
				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'AVS.Three.ThickLineSegmentsBufferGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );

			}

		}

	}

	applyMatrix( matrix ) {

		console.warn( 'AVS.Three.ThickLineSegmentsBufferGeometry: applyMatrix() has been renamed to applyMatrix4().' );

		return this.applyMatrix4( matrix );

	}

}

ThickLineSegmentsBufferGeometry.prototype.isThickLineSegmentsBufferGeometry = true;

class ThickLineBufferGeometryLoader {

	parse( json ) {

		const geometry = new ThickLineSegmentsBufferGeometry();

		const attributes = json.data.attributes;

		if ( attributes.position !== undefined ) {

			geometry.setPositions( attributes.position.array );

		}

		if ( attributes.color !== undefined ) {

			geometry.setColors( attributes.color.array );

		}

		if ( attributes.pattern !== undefined ) {

			geometry.setPatterns( attributes.pattern.array );

		}

		if ( attributes.linewidth !== undefined ) {

			geometry.setLinewidths( attributes.linewidth.array );

		}

		return geometry;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();

// Thick lines are drawn as a mesh but raycast like lines

class ThickLineSegments extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'ThickLineSegments';

	}

	// From THREE.Line.raycast()
	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = 2;

		const attributes = geometry.attributes;
		const positionsStart = attributes.instanceStart.array;

		// Assume non-indexed BufferGeometry
		for ( let i = 0, l = positionsStart.length / 3 - 1; i < l; i += step ) {

			vStart.fromArray( positionsStart, 3 * i );
			vEnd.fromArray( positionsStart, 3 * i + 3 );

			const distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

			if ( distSq > localThresholdSq ) continue;

			interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

			const distance = raycaster.ray.origin.distanceTo( interRay );

			if ( distance < raycaster.near || distance > raycaster.far ) continue;

			intersects.push( {

				distance: distance,
				// What do we want? intersection point on the ray or on the segment??
				// point: raycaster.ray.at( distance ),
				point: interSegment.clone().applyMatrix4( this.matrixWorld ),
				index: i,
				face: null,
				faceIndex: null,
				object: this

			} );

		}

	}

}

ThickLineSegments.prototype.isThickLineSegments = true;

class BillboardText extends Object3D {

	constructor() {

		super();

		this.type = 'BillboardText';
		
		this.text = 'Label';
		this.fontSize = 16;
		this.fontStyle = 'normal';
		this.fontWeight = 'normal';
		this.textDecoration = '';
		this.fontFamily = 'sans-serif';
		this.color = new Color( 0x000000 );
		this.textAlign = '';
		this.transform = '';
		this.transformOrigin = '';
		
		this.div = document.createElement('div');
		this.div.style.position = 'absolute';
		this.div.style.whiteSpace = 'nowrap';
		this.div.style.lineHeight = 'normal';
		this.div.style.userSelect = 'none';
		
		this.scene = null;
		this.scaleFactor = 1.0;
		
		this.updateStyle();
		
	}
	
	addToScene( scene ) {
		
		if ( this.scene === null ) {

			this.scene = scene;
		
			scene.labels.push( this );
			scene.div.appendChild( this.div );
		
			this.updateStyle();

		}
		
	}

	updateStyle() {
		
		this.div.innerHTML = this.text;
		this.div.style.fontStyle = this.fontStyle;
		this.div.style.fontWeight = this.fontWeight;
		this.div.style.textDecoration = this.textDecoration;
		this.div.style.color = '#' + this.color.getHexString();
		this.div.style.textAlign = this.textAlign;
		this.div.style.transform = this.transform;
		this.div.style.transformOrigin = this.transformOrigin;
		
		// Formatted text: apply float:left to the inner span
		if ( this.div.firstChild.style !== undefined ) {

			this.div.firstChild.style.float = 'left';

		}

		// Only quote font names containing whitespace.
		// CSS requires generic names like sans-serif not be quoted.
		if ( /\s/.test( this.fontFamily ) ) {

			this.div.style.fontFamily = '\'' + this.fontFamily + '\'';

		} else {

			this.div.style.fontFamily = this.fontFamily;

		}

		if ( ! this.textScale ) {

			this.div.style.fontSize = this.fontSize + 'px';

		}

	}

	updatePosition() {
		
		this.updateMatrixWorld();
		const worldPos = new Vector3().setFromMatrixPosition( this.matrixWorld );
		worldPos.project( this.scene.camera );
		
		const left = ( ( worldPos.x + 1 ) / 2 ) * this.scene.width;
		const top = ( 1 - ( worldPos.y + 1 ) / 2 ) * this.scene.height;

		this.div.style.left = left + 'px';
		this.div.style.top = top + 'px';
		
		if ( this.textScale ) {

			const upPos = new Vector3( 0, 1, 0 ).multiplyScalar( this.fontSize ).add( this.position );

			upPos.applyMatrix4( this.parent.matrixWorld );
			upPos.project( this.scene.camera );

			const upTop = ( 1 - ( upPos.y + 1 ) / 2 ) * this.scene.height;

			this.div.style.fontSize = ( Math.abs( upTop - top ) ) + 'px';

		}

	}

}

BillboardText.prototype.isBillboardText = true;

/**
 *  AVS Revision 1.0: Original extracted from Three.js revision 82.
 *  AVS Revision 1.1: Added arguments to pass in arrays of existing items
 *  AVS Revision 1.2: Update to Three.js revision 85
 *  AVS Revision 1.3: Added arguments to parse function for streaming
 *  AVS Revision 1.6: Added DataMapLoader 
 *  AVS Revision 1.7: Added CellTypeEnum
 *  AVS Revision 1.8: Load BillboardText class
 *  AVS Revision 1.9: Added LinePatternBufferGeometryLoader
 *  AVS Revision 1.10: Added ThickLineBufferGeometryLoader
 *  AVS Revision 1.11: Added ThickLineSegments
 *  AVS Revision 1.12: Update to Three.js revision 87
 *  AVS Revision 1.13: Update to Three.js revision 89
 *  AVS Revision 1.14: Use local FileLoader - reverted
 *  AVS Revision 1.15: Update to Three.js revision 92
 *  AVS Revision 1.16: Update to Three.js revision 93
 *  AVS Revision 1.17: Comment out unneeded code
 *  AVS Revision 1.18: Remove DataMapLoader until later date
 *  AVS Revision 1.19: Update to Three.js revision 96
 *  AVS Revision 1.20: Remove need for metadata - reverted
 *  AVS Revision 1.21: Deal with selectionInfo being returned and no object - reverted
 *  AVS Revision 1.22: Update to Three.js revision 98
 *  AVS Revision 1.23: Update to Three.js revision 102
 *  AVS Revision 1.24: Update to Three.js revision 108
 *  AVS Revision 1.25: Update to Three.js revision 112
 *  AVS Revision 1.26: Update to Three.js revision 115
 *  AVS Revision 1.27: Restore loading of SphereBufferGeometry for VRML skybox
 *  AVS Revision 1.28: Update to Three.js revision 116
 *  AVS Revision 1.29: Update to Three.js revision 118
 *  AVS Revision 1.30: Update to Three.js revision 121
 *  AVS Revision 1.31: Update to Three.js revision 126
 *  AVS Revision 1.32: Add OrthographicCamera.keepAspectRatio
 *  AVS Revision 1.33: Update to Three.js revision 131
 */

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

        const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
        loader.load( url, function ( text ) {

            let json = null;

            try {

                json = JSON.parse( text );

            } catch ( error ) {

                if ( onError !== undefined ) onError( error );

                // AVS revision 1.1.  Message changed to use AVS.Three source
                console.error( 'AVS.Three.ObjectLoader: Can\'t parse ' + url + '.', error.message );

                return;

            }

            const metadata = json.metadata;

            if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

                // AVS revision 1.1.  Message changed to use AVS.Three source
                console.error( 'AVS.Three.ObjectLoader: Can\'t load ' + url );
                return;

            }

            scope.parse( json, onLoad );

        }, onProgress, onError );

    }
/*
	async loadAsync( url, onProgress ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		const text = await loader.loadAsync( url, onProgress );

		const json = JSON.parse( text );

		const metadata = json.metadata;

		if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

			throw new Error( 'AVS.Three.ObjectLoader: Can\'t load ' + url );

		}

		return await scope.parseAsync( json );

	}
*/
    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    // AVS Revision 1.6:  Added DataMapLoader 
    parse( json, onLoad, existingImages, existingTextures, existingMaterials, existingGeometries/*, existingDataMaps*/, parentGroup ) {

/* AVS Revision 1.17.  Comment out unneeded code
		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
*/
        const geometries = this.parseGeometries( json.geometries, /*shapes,*/ existingGeometries );

        const images = this.parseImages( json.images, function () {

            if ( onLoad !== undefined ) onLoad( object );

        }, existingImages );

        const textures  = this.parseTextures( json.textures, images, existingTextures );
        const materials = this.parseMaterials( json.materials, textures, existingMaterials );
//        const dataMaps = this.parseDataMaps( json.dataMaps, geometries, existingDataMaps );

        const object = this.parseObject( json.object, geometries, materials, textures/*, animations*//*, dataMaps*/ );
/* AVS Revision 1.17.  Comment out unneeded code
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );
*/
        if ( parentGroup !== undefined ) {

            parentGroup.add( object );

            object.saveVisible = object.visible;
            object.visible = false;

        }

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ] instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

        }

        return object;

    }

/* AVS Revision 1.17.  Comment out unneeded code
	async parseAsync( json ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = await this.parseImagesAsync( json.images );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}
*/
    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseGeometries( json, /*shapes,*/ existingGeometries ) {

        let geometries = {};

        if ( existingGeometries !== undefined ) {

            geometries = existingGeometries;

        }

        if ( json !== undefined ) {

            const bufferGeometryLoader = new BufferGeometryLoader();

			// AVS revision 1.9.  Added LinePatternBufferGeometryLoader
			const linePatternBufferGeometryLoader = new LinePatternBufferGeometryLoader( bufferGeometryLoader );

			// AVS revision 1.10.  Added ThickLineBufferGeometryLoader
			const thickLineBufferGeometryLoader = new ThickLineBufferGeometryLoader();

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                let geometry;
                const data = json[ i ];

                switch ( data.type ) {

                    case 'BufferGeometry':
					case 'InstancedBufferGeometry':

                        geometry = bufferGeometryLoader.parse( data );

                        break;

					// AVS revision 1.9.  Added LinePatternBufferGeometryLoader
					case 'LinePatternBufferGeometry':

						geometry = linePatternBufferGeometryLoader.parse( data );

						break;

					// AVS revision 1.10.  Added ThickLineBufferGeometryLoader
					case 'ThickLineBufferGeometry':

						geometry = thickLineBufferGeometryLoader.parse( data );

						break;

                    case 'Geometry':

						console.error( 'AVS.Three.ObjectLoader: The legacy Geometry type is no longer supported.' );

                        break;

                    default:

                        // AVS revision 1.0.  Message changed to use AVS.Three source
						if ( data.type in Geometries ) {

							geometry = Geometries[ data.type ].fromJSON( data, shapes );

						} else {

							console.warn( `AVS.Three.ObjectLoader: Unsupported geometry type "${ data.type }"` );

						}

                        continue;

                }

                geometry.uuid = data.uuid;

                if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

                geometries[ data.uuid ] = geometry;

            }

        }

        return geometries;

    }

    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseMaterials( json, textures, existingMaterials ) {

		const cache = {}; // MultiMaterial
        let materials = {};

        if ( existingMaterials !== undefined ) {

            materials = existingMaterials;

        }

        if ( json !== undefined ) {

            const loader = new MaterialLoader();
            loader.setTextures( textures );

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                const data = json[ i ];

                if ( data.type === 'MultiMaterial' ) {

                    // Deprecated

                    const array = [];

                    for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

                    }

                    materials[ data.uuid ] = array;

                } else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

                }

            }

        }

        return materials;

    }

    // AVS Revision 1.6:  Added DataMapLoader 
/*
    parseDataMaps( json, existingGeometries, existingDataMaps ) {

        let dataMaps = {};

        if ( existingDataMaps !== undefined ) {

            dataMaps = existingDataMaps;

        }

        if ( json !== undefined ) {

            const loader = new DataMapLoader();

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                const data = json[ i ];

                dataMaps[ data.uuid ] = loader.parse( data, existingGeometries );

            }

        }

        return dataMaps;

    }
*/
/* AVS Revision 1.17.  Comment out unneeded code
    parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

        }

        return animations;

    }
*/
    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseImages( json, onLoad, existingImages ) {

        const scope = this;
        let images = {};

        if ( existingImages !== undefined ) {

            images = existingImages;

        }

		let loader;

        function loadImage( url ) {

            scope.manager.itemStart( url );

            return loader.load( url, function () {

                scope.manager.itemEnd( url );

            }, undefined, function () {

                scope.manager.itemError( url );
                scope.manager.itemEnd( url );

            } );

        }

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

        if ( json !== undefined && json.length > 0 ) {

            const manager = new LoadingManager( onLoad );

            loader = new ImageLoader( manager );
            loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

                const image = json[ i ];
				image.url;

/* AVS Revision 1.17.  Comment out unneeded code
				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else*/ {

					// load single image

					const deserializedImage = deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

            }

        }

        return images;

    }
/*
	async parseImagesAsync( json ) {

		const scope = this;
		const images = {};

		let loader;

		async function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return await loader.loadAsync( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = await deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else {

					// load single image

					const deserializedImage = await deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

			}

		}

		return images;

	}
*/
    // AVS revision 1.1.  Added arguments to pass in arrays of existing items
    parseTextures( json, images, existingTextures ) {

        function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

            // AVS revision 1.0.  Message changed to use AVS.Three source
            console.warn( 'AVS.Three.ObjectLoader.parseTextures: Constant should be in numeric form.', value );

            return type[ value ];

        }

        let textures = {};

        if ( existingTextures !== undefined ) {

            textures = existingTextures;

        }

        if ( json !== undefined ) {

            for ( let i = 0, l = json.length; i < l; i ++ ) {

                const data = json[ i ];

                if ( data.image === undefined ) {

                    // AVS revision 1.0.  Message changed to use AVS.Three source
                    console.warn( 'AVS.Three.ObjectLoader: No "image" specified for', data.uuid );

                }

                if ( images[ data.image ] === undefined ) {

                    // AVS revision 1.0.  Message changed to use AVS.Three source
                    console.warn( 'AVS.Three.ObjectLoader: Undefined image', data.image );

                }

				let texture;
				const image = images[ data.image ];

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture( image );

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture( image.data, image.width, image.height );

					} else {

						texture = new Texture( image );

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

                texture.uuid = data.uuid;

                if ( data.name !== undefined ) texture.name = data.name;

                if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

                if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
                if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

                if ( data.wrap !== undefined ) {

                    texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
                    texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

                }

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

                if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
                if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
                if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

                if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

                textures[ data.uuid ] = texture;

            }

        }

        return textures;

    }

    // AVS Revision 1.6:  Added DataMapLoader 
    parseObject( data, geometries, materials, textures/*, animations*//*, dataMaps*/ ) {

        let object;

        function getGeometry( name ) {

            if ( geometries[ name ] === undefined ) {

                // AVS revision 1.0.  Message changed to use AVS.Three source
                console.warn( 'AVS.Three.ObjectLoader: Undefined geometry', name );

            }

            return geometries[ name ];

        }

//	        function onBeforeRenderCellSet() {
//	            evaluateDataMapsCellSet( this );
//	        }
//
//	        function onBeforeRenderCell() {
//	            evaluateDataMapsCell( this );
//	        }

//	        function evaluateDataMapsCellSet( object ) {   	
//	            var dataMapSourceValues = object.userData.cellSetData.dataMapSourceValues;
//	            if (dataMapSourceValues !== undefined) {
//	                // Color map
//	                var inputValue = dataMapSourceValues.color;
//	                if ( inputValue !== undefined ) {
//	                    var curDataMap = findDataMap(object, 'color'); 
//	                    if (curDataMap !== undefined && curDataMap.isDirty()) {
//	                        var newColor = curDataMap.evaluate( inputValue );
//	                        if (newColor !== undefined) {
//	                            object.material.color = newColor;
//	                            object.material.colorWrite = true;
//	                        }
//	                        else {
//	                            object.material.colorWrite = false;
//	                        }
//	                    }
//	                }
//	            }
//	        }
//
//	        function evaluateDataMapsCell( object ) {   	
//	            var dataMapSourceValues = object.userData.cellData.dataMapSourceValues;
//	            if (dataMapSourceValues !== undefined) {
//	                // Color map
//	                var inputValues = dataMapSourceValues.color;
//	                if ( inputValues !== undefined ) {
//	                    var curDataMap = findDataMap(object, 'color'); 
//	                    if (curDataMap !== undefined && curDataMap.isDirty()) {
//	                        var count = null;
//	                        var length = null;
//	    	                var attribute = object.geometry.attributes.color;
//
//	                        for (var i = 0; i < inputValues.length; i++) {
//	                            var newColor = curDataMap.evaluate( inputValues[i] );
//			    	                
//	                            if (object.cellType === AVS.Three.CellTypeEnum.Points) { // THREE.Points
//	                                count = 3*i;
//	                                length = 1;
//	                            } else if (object.cellType === AVS.Three.CellTypeEnum.Lines) { // THREE.LineSegments
//	                                count = 6*i;
//	                                length = 2;
//	                            } else if (object.cellType === AVS.Three.CellTypeEnum.Triangles) { // THREE.Mesh tris
//	                                count = 9*i;
//	                                length = 3;
//	                            } else { // THREE.Mesh quads
//	                                count = 9*i; 
//	                                length = 3;
//	                            }
//
//	                           	if (newColor !== undefined) {
//	                           		for (var k = 0; k < length; k++) {
//		                                attribute.array[count++] = newColor.r;
//		                                attribute.array[count++] = newColor.g;
//		                                attribute.array[count++] = newColor.b;
//	                            	}
//	                           	}
//	                            else {
//	                           		for (var k = 0; k < length; k++) {
//		                                attribute.array[count++] = undefined;
//		                                attribute.array[count++] = undefined;
//		                                attribute.array[count++] = undefined;
//	                            	}
//	                            }
//	                       	}
//	                        attribute.needsUpdate = true;
//	                    }
//	                }
//	            }
//	        }
/*
        function findDataMap( object, type ) {
            var curObject = object.parent;
            while( curObject !== undefined && curObject !== null) {
                if (curObject.userData !== undefined && curObject.userData.dataMaps !== undefined) {
                    var objectDataMaps = curObject.userData.dataMaps;
                    if (objectDataMaps.hasOwnProperty( type )) {
                        return objectDataMaps[type]; 
                    }
                }
                curObject = curObject.parent;	
            }
        }
*/
        function getMaterial( name ) {

            if ( name === undefined ) return undefined;

            if ( Array.isArray( name ) ) {

                const array = [];

                for ( let i = 0, l = name.length; i < l; i ++ ) {

                    const uuid = name[ i ];

                    if ( materials[ uuid ] === undefined ) {

                        // AVS revision 1.0.  Message changed to use AVS.Three source
                        console.warn( 'AVS.Three.ObjectLoader: Undefined material', uuid );

                    }

                    array.push( materials[ uuid ] );

                }

                return array;

            }

            if ( materials[ name ] === undefined ) {

                // AVS revision 1.0.  Message changed to use AVS.Three source
                console.warn( 'AVS.Three.ObjectLoader: Undefined material', name );

            }

            return materials[ name ];

        }

		function getTexture( uuid ) {

			if ( textures[ uuid ] === undefined ) {

				console.warn( 'AVS.Three.ObjectLoader: Undefined texture', uuid );

			}

			return textures[ uuid ];

		}
/*
        function getDataMap( name ) {

            if ( dataMaps[ name ] === undefined ) {

                console.warn( 'AVS.Three.ObjectLoader: Undefined dataMap', name );

            }

            return dataMaps[ name ];

        }
*/
		let geometry, material;

        switch ( data.type ) {

            case 'Scene':

                object = new Scene();

                if ( data.background !== undefined ) {

                    if ( Number.isInteger( data.background ) ) {

                        object.background = new Color( data.background );

					} else {

						object.background = getTexture( data.background );

                    }

                }

				if ( data.environment !== undefined ) {

					object.environment = getTexture( data.environment );

				}

                if ( data.fog !== undefined ) {

                    if ( data.fog.type === 'Fog' ) {

                        object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

                    } else if ( data.fog.type === 'FogExp2' ) {

                        object.fog = new FogExp2( data.fog.color, data.fog.density );

                    }

                }

                break;

            case 'PerspectiveCamera':

                object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

                if ( data.focus !== undefined ) object.focus = data.focus;
                if ( data.zoom !== undefined ) object.zoom = data.zoom;
                if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
                if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
                if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

                break;

            case 'OrthographicCamera':

                object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				// AVS Revision 1.32.  Add OrthographicCamera.keepAspectRatio
				if ( data.keepAspectRatio !== undefined ) object.keepAspectRatio = data.keepAspectRatio;

                break;

            case 'AmbientLight':

                object = new AmbientLight( data.color, data.intensity );

                break;

            case 'DirectionalLight':

                object = new DirectionalLight( data.color, data.intensity );

                break;

            case 'PointLight':

                object = new PointLight( data.color, data.intensity, data.distance, data.decay );

                break;

/* AVS Revision 1.17.  Comment out unneeded code
            case 'RectAreaLight':

                object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

                break;

            case 'SpotLight':

                object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

                break;

            case 'HemisphereLight':

                object = new HemisphereLight( data.color, data.groundColor, data.intensity );

                break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

            case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;
*/
            case 'Mesh':
            case 'Quads':

                geometry = getGeometry( data.geometry );
                material = getMaterial( data.material );

                object = new Mesh( geometry, material );

                // AVS revision 1.7.  Add CellTypeEnum
                object.cellType = ( data.type === 'Quads' ) ? CellTypeEnum.Quads : CellTypeEnum.Triangles;

                break;

/* AVS Revision 1.17.  Comment out unneeded code
			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new BufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

            case 'LOD':

                object = new LOD();

                break;

            case 'Line':

                object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

                break;

            case 'LineLoop':

                object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

                break;
*/
            case 'LineSegments':

                object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

                // AVS revision 1.7.  Add CellTypeEnum
                object.cellType = CellTypeEnum.Lines;

                break;

			case 'ThickLineSegments':

				object = new ThickLineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				object.cellType = CellTypeEnum.Quads;

				break;

            case 'PointCloud':
            case 'Points':

                object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

                // AVS revision 1.7.  Add CellTypeEnum
                object.cellType = CellTypeEnum.Points;

                break;

/* AVS Revision 1.17.  Comment out unneeded code
            case 'Sprite':

                object = new Sprite( getMaterial( data.material ) );

                break;
*/
            case 'Group':

                object = new Group();

                // Need to save a list of all the data maps on the top level object
//                if (data.name === 'Scenes') {
//                    object.dataMaps = dataMaps;
//                }

                break;

/* AVS Revision 1.17.  Comment out unneeded code
			case 'Bone':

				object = new Bone();

				break;
*/
			// AVS revision 1.8.  Load BillboardText class
			case 'BillboardText':
                	
               	object = new BillboardText();

               	if ( data.text !== undefined ) object.text = data.text;
               	if ( data.fontSize !== undefined ) object.fontSize = data.fontSize;
               	if ( data.fontStyle !== undefined ) object.fontStyle = data.fontStyle;
               	if ( data.fontWeight !== undefined ) object.fontWeight = data.fontWeight;
               	if ( data.fontFamily !== undefined ) object.fontFamily = data.fontFamily;
               	if ( data.textDecoration !== undefined ) object.textDecoration = data.textDecoration;
               	if ( data.color !== undefined ) object.color.setHex( data.color );
               	if ( data.textAlign !== undefined ) object.textAlign = data.textAlign;
               	if ( data.transform !== undefined ) object.transform = data.transform;
               	if ( data.transformOrigin !== undefined ) object.transformOrigin = data.transformOrigin;
				if ( data.textScale !== undefined ) object.textScale = data.textScale;
                	
               	break;
                    
            default:

                object = new Object3D();

        }

        object.uuid = data.uuid;

        if ( data.name !== undefined ) object.name = data.name;

        if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

        } else {

            if ( data.position !== undefined ) object.position.fromArray( data.position );
            if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
            if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
            if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

        }

        if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
        if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

        if ( data.shadow ) {

            if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
            if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
            if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
            if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

        }

        if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
        if ( data.userData !== undefined ) {

            object.userData = data.userData;

            // Check for any datamaps and resolve references
//            if ( object.userData.dataMaps !== undefined) {
//                var objectDataMaps = object.userData.dataMaps;
//                for (var key in objectDataMaps){
//                    if (objectDataMaps.hasOwnProperty(key)) {
//                        objectDataMaps[key] = getDataMap( objectDataMaps[key] );
//                    }
//                }
//            }

            // Set a callback to evaluate the datamaps just prior to rendering
//	            if ( object.userData.cellSetData !== undefined && object.userData.cellSetData.dataMapSourceValues != undefined) {
//	                object.onBeforeRender = onBeforeRenderCellSet;
//	            }
//	            else if ( object.userData.cellData !== undefined && object.userData.cellData.dataMapSourceValues != undefined) {
//	                object.onBeforeRender = onBeforeRenderCell;
//	            }
        }
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

        if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, textures/*, animations*//*, dataMaps*/ ) );

            }

        }

		object.internalData = {};
		if ( data.internalData !== undefined ) object.internalData = data.internalData;

/* AVS Revision 1.17.  Comment out unneeded code
		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

        if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

            const levels = data.levels;

            for ( let l = 0; l < levels.length; l ++ ) {

                const level = levels[ l ];
                const child = object.getObjectByProperty( 'uuid', level.object );

                if ( child !== undefined ) {

                    object.addLevel( child, level.distance );

                }

            }

        }
*/
        return object;

	}

/* AVS Revision 1.17.  Comment out unneeded code
	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}
*/
	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'AVS.Three.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class Viewer {

	constructor( id, pixelRatio ) {

		//private
		var viewerID = id;
		this.getID = function(){
			return viewerID;
		};

		this.pixelRatio = pixelRatio !== undefined ? pixelRatio : window.devicePixelRatio;

		// Top-level container
		this.container = document.createElement('div');
		this.container.style.position = 'relative';
		this.container.style.outline = 'none';
		this.container.style.overflow = 'hidden';
		this.container.style.width = '100%';
		this.container.style.height = '100%';
		this.container.id = 'avsthreeDiv';

		this.domElement = this.container;

		this.scenes = [];
		this.currentScene = null;

		this.objectLoader = new ObjectLoader();

		this.startCell = 1;

		// Selection
		this.raycaster = new Raycaster();
		this.raycaster.params.Line.threshold = 0.001;

		this.validPick = false;

		this.pickType = PickTypeEnum.Ray;
		this.pickDepth = PickDepthEnum.Closest;

		this.pickRayX = 0;
		this.pickRayY = 0;

		this.pickRectangleLeft = 0;
		this.pickRectangleTop = 0;
		this.pickRectangleRight = 1;
		this.pickRectangleBottom = 1;

		this.selectionListeners = [];
		this.intersects = [];
		this.highlightList = [];

		this.updateHighlight = false;
		this.highlightColor = new Color( 0xff0000 );

		this.updatePicking = false;
		this.pickState = new Float32Array( 1 ); // array so we can keep a reference to it

		this.resolution = new Vector2();

		// Streaming
		this.loading = false;
		this.firstChunk = false;

	}

	setWebGLRenderer( renderer ) {

		this.renderer = renderer;

		this.renderer.autoClear = false;
		this.renderer.setPixelRatio( this.pixelRatio );
		this.renderer.localClippingEnabled = true;
		this.renderer.sortObjects = false;

	}
/*
    getDataMaps() {

        return this.dataMaps;

    }
*/
    updateSize() {

		var width = this.container.clientWidth;
		var height = this.container.clientHeight;

		if ( width === this.width && height === this.height ) {

			return;

		}

        this.width = width;
        this.height = height;

		this.pixelWidth = Math.floor( width * this.pixelRatio );
		this.pixelHeight = Math.floor( height * this.pixelRatio );

		this.updateHighlight = true;
        this.updatePicking = true;
		this.validPick = false;

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            this.updateSceneSize( this.scenes[ i ] );

        }

    }

    updateSceneSize( scene ) {

		scene.x = scene.internalData.x !== undefined ? Math.floor( this.width * scene.internalData.x ) : 0;
		scene.width = scene.origWidth = scene.internalData.width !== undefined ? Math.floor( this.width * scene.internalData.width ) : this.width;

		scene.y = scene.internalData.y !== undefined ? Math.floor( this.height * scene.internalData.y ) : 0;
		scene.height = scene.origHeight = scene.internalData.height !== undefined ? Math.floor( this.height * scene.internalData.height ) : this.height;
		scene.top = this.height - scene.height - scene.y;

		if ( scene.widthScale !== undefined ) {

			scene.width *= scene.widthScale;

		}

		if ( scene.heightScale !== undefined ) {

			scene.height *= scene.heightScale;

		}

		scene.pixelWidth = Math.floor( scene.width * this.pixelRatio );
		scene.pixelHeight = Math.floor( scene.height * this.pixelRatio );

		if ( scene.camera.isPerspectiveCamera ) {

			scene.camera.aspect = scene.pixelWidth / scene.pixelHeight;
            scene.camera.updateProjectionMatrix();

		}

		scene.viewportX = scene.vpX !== undefined ? Math.floor( this.width * scene.vpX ) : scene.x;
		scene.viewportWidth = scene.vpWidth !== undefined ? Math.floor( this.width * scene.vpWidth + 0.5 ) : scene.width;

		scene.viewportY = scene.vpY !== undefined ? Math.floor( this.height * scene.vpY ) : scene.y;
		scene.viewportHeight = scene.vpHeight !== undefined ? Math.floor( this.height * scene.vpHeight + 0.5 ) : scene.height;
		scene.viewportTop = this.height - scene.viewportHeight - scene.viewportY;

		scene.viewportPixelX = Math.floor( scene.viewportX * this.pixelRatio );
		scene.viewportPixelWidth = Math.floor( scene.viewportWidth * this.pixelRatio );
		scene.viewportPixelY = Math.floor( scene.viewportY * this.pixelRatio );
		scene.viewportPixelHeight = Math.floor( scene.viewportHeight * this.pixelRatio );
		scene.viewportPixelTop = this.pixelHeight - scene.viewportPixelHeight - scene.viewportY;

        var viewportDiv = scene.viewportDiv;

        viewportDiv.style.left = scene.viewportX + 'px';
        viewportDiv.style.width = scene.viewportWidth + 'px';

        viewportDiv.style.top = scene.viewportTop + 'px';
        viewportDiv.style.height = scene.viewportHeight + 'px';

		var div = scene.div;

		div.style.width = scene.width + 'px';
		div.style.height = scene.height + 'px';
		div.baseLeft = scene.x - scene.viewportX;
		div.baseTop = scene.top - scene.viewportTop;
		div.style.left = div.baseLeft + 'px';
		div.style.top = div.baseTop + 'px';

		var canvas = scene.canvas;

		canvas.width = scene.pixelWidth;
		canvas.height = scene.pixelHeight;

		canvas = scene.highlightCanvas;

		canvas.width = scene.pixelWidth;
		canvas.height = scene.pixelHeight;

		if ( scene.rectCanvas ) {

			scene.rectCanvas.width = scene.pixelWidth;
			scene.rectCanvas.height = scene.pixelHeight;

		}

		if ( scene.leftLimit ) {

			div.leftLimit = Math.floor( - scene.leftLimit * scene.origWidth * ( scene.widthScale - 1 ) );
			div.rightLimit = Math.floor( - scene.rightLimit * scene.origWidth * ( scene.widthScale - 1 ) );

			div.bottomLimit = Math.floor( - scene.bottomLimit * scene.origHeight * ( scene.heightScale - 1 ) );
			div.topLimit = Math.floor( - scene.topLimit * scene.origHeight * ( scene.heightScale - 1 ) );

		}

		scene.renderTarget.setSize( scene.pixelWidth, scene.pixelHeight );
		scene.pixelBuffer = new Uint8Array( 4 * scene.pixelWidth * scene.pixelHeight );

		scene.pickingRenderTarget.setSize( scene.pixelWidth, scene.pixelHeight );
		scene.pickingPixelBuffer = new Uint8Array( 4 * scene.pixelWidth * scene.pixelHeight );

		// Scale camera if client window size doesn't match server
		if ( scene.camera.isOrthographicCamera && scene.camera.keepAspectRatio ) {

			var xScale = scene.width / scene.internalData.pxWidth;
			var yScale = scene.height / scene.internalData.pxHeight;

			var serverAspect = scene.internalData.pxWidth / scene.internalData.pxHeight;
			scene.width / scene.height;

			if ( serverAspect < 1 ) ; else {

				scene.camera.left = scene.camera.origLeft * xScale / yScale;
				scene.camera.right = scene.camera.origRight * xScale / yScale;

			}

			scene.camera.updateProjectionMatrix();

		}

    }

    clearGeometry() {

    	while ( this.container.lastChild ) {
    		
    		this.container.removeChild( this.container.lastChild );
    		
    	}
    	
    	this.scenes = [];
		this.currentScene = null;

		this.startCell = 1;
    	
    }

    setPickDepth( depth ) {

        if ( depth === undefined ) {

            depth = PickDepthEnum.Closest;

        }

		if ( this.pickDepth === depth ) {

			return;

		}

        this.pickDepth = depth;

    }

	setPickRay( x, y ) {

		var px = Math.floor( x * this.pixelRatio );
		var py = Math.floor( y * this.pixelRatio );

		if ( px < 0 || py < 0 || px > this.pixelWidth || py > this.pixelHeight ) {

			this.validPick = false;
			console.error( 'AVS.Three.Viewer: pick ray coordinates out of range.' );
			return;

		}

		this.pickType = PickTypeEnum.Ray;
		this.pickRayX = px;
		this.pickRayY = py;
		this.validPick = true;

	}

	setPickRectangle( left, top, right, bottom ) {

		var px = Math.floor( Math.min( left, right ) * this.pixelRatio );
		var pw = Math.floor( Math.max( left, right ) * this.pixelRatio ) - px;

		var py = Math.floor( Math.max( top, bottom ) * this.pixelRatio );
		var ph = Math.floor( Math.min( top, bottom ) * this.pixelRatio ) - py;

		if ( px < 0 || py < 0 || ( pw + px ) > this.pixelWidth || ( py + ph ) > this.pixelHeight ) {

			this.validPick = false;
			console.error( 'AVS.Three.Viewer: pick rectangle coordinates out of range.' );
			return;

		}

		this.pickType = PickTypeEnum.Rectangle;
		this.pickRectangleX = px;
		this.pickRectangleY = py;
		this.pickRectangleWidth = pw;
		this.pickRectangleHeight = ph;
		this.validPick = true;

	}

	interactorUpdate( interactor ) {

		this.updatePicking = true;
		this.render( true );

		if ( this.stats !== undefined ) {

			this.stats.update();

		}

	}

    addInteractor( interactor ) {

		if ( interactor.isTransformInteractor ) {

			this.transformInteractor = interactor;
			interactor.addEventListener( 'change', this.interactorUpdate.bind( this, interactor ) );

		} else if ( interactor.isZoomRectangleInteractor ) {

			this.zoomRectangleInteractor = interactor;
			interactor.addEventListener( 'change', this.interactorUpdate.bind( this, interactor ) );

		} else if ( interactor.isPanInteractor ) {

			this.panInteractor = interactor;

		} else {

			return;

		}

		interactor.domElement = this.domElement;

    }

	removeInteractor( interactor ) {

		if ( interactor.isTransformInteractor ) {

			this.transformInteractor = undefined;
			interactor.removeEventListener( 'change', this.interactorUpdate.bind( this ) );

		} else if ( interactor.isZoomRectangleInteractor ) {

			this.zoomRectangleInteractor = undefined;
			interactor.removeEventListener( 'change', this.interactorUpdate.bind( this ) );

		} else if ( interactor.isPanInteractor ) {

			this.panInteractor = undefined;

		}

	}

	addStats() {

		if ( this.stats === undefined ) {

			this.stats = new Stats();
			this.container.appendChild( this.stats.dom );

		}

	}

    addGeometry( geometry ) {

		geometry.updateMatrixWorld();

		// Set the container background color from the scene root

		if ( geometry.internalData.background !== undefined ) {

			this.container.style.backgroundColor = "#" + geometry.internalData.background.toString( 16 ).padStart( 6, '0' );

		} else {

			this.container.style.backgroundColor = "transparent";

		}

		var scope = this;

		// Pull out all scenes from the geometry tree

		geometry.traverse( function( object ) {

			if ( object.isScene ) {

				// Find camera reference

				for ( var i = 0; i < object.children.length; i ++ ) {

					var child = object.children[ i ];

					if ( child.isPerspectiveCamera || child.isOrthographicCamera ) {

						object.camera = child;
						object.remove( child );

						break;

					}

				}

				// No camera? Add a dummy one if we need to draw the background

				if ( object.camera == undefined && object.background !== null ) {

					object.camera = new OrthographicCamera$1();

				}

				if ( object.camera !== undefined ) {

					scope.addScene( object );

				}

			}

			scope.attachInteractors( object );
			scope.addLabels( object );
			scope.createPickingInfo( object );
			scope.addMaterialReferences( object );

		} );

//            this.dataMaps = geometry.dataMaps;
//        }

		// Remove scenes from their parent so they become top-level

        for ( var i = 0; i < this.scenes.length; i ++ ) {

			var scene = this.scenes[ i ];

			if ( scene.parent ) {

				scene.parent.remove( scene );

			}

        }

    }

    addScene( scene, panScene ) {

        this.scenes.push( scene );
        this.currentScene = scene;

		if ( panScene === undefined ) {

			this.currentRealScene = scene;

		}

        scene.labels = [];

        var viewportDiv = document.createElement('div');
        viewportDiv.style.position = 'absolute';
        viewportDiv.style.overflow = 'hidden';
		viewportDiv.id = scene.name + "Viewport";

		var div = document.createElement('div');
		div.style.position = 'absolute';
        div.style.overflow = 'hidden';
		div.id = scene.name;
		viewportDiv.appendChild( div );

		var canvas = document.createElement('canvas');
		canvas.style.position = 'absolute';
		canvas.style.width = '100%';
		canvas.style.height = '100%';
		canvas.id = scene.name + "Canvas";
		div.appendChild( canvas );
		scene.canvas = canvas;
		scene.ctx = canvas.getContext('2d');

		var highlightCanvas = document.createElement('canvas');
		highlightCanvas.style.position = 'absolute';
		highlightCanvas.style.width = '100%';
		highlightCanvas.style.height = '100%';
		highlightCanvas.id = scene.name + "HighlightCanvas";
		div.appendChild( highlightCanvas );
		scene.highlightCanvas = highlightCanvas;
		scene.highlightCtx = highlightCanvas.getContext('2d');

		scene.div = div;
        scene.viewportDiv = viewportDiv;
        this.container.appendChild( viewportDiv );

		scene.renderTarget = new WebGLRenderTarget();
		scene.pickingRenderTarget = new WebGLRenderTarget();

        this.updateSceneSize( scene );

		scene.startCell = this.startCell;

        // Create a duplicate scene+lights for rendering just highlighted objects
        scene.highlightScene = new Scene$1();
        scene.highlightScene.add( new Group$1() );

        for ( var i = 0; i < scene.children.length; i ++ ) {

            if ( scene.children[ i ].isLight ) {

                scene.highlightScene.add( scene.children[ i ].clone() );

            }

        }

    }

	attachInteractors( object ) {

		if ( object.internalData.attachTransformInteractor && this.transformInteractor ) {

			// Attach transform interactor to the current object

			this.transformInteractor.setObjectScene( object, this.currentScene );

		}

		if ( object.internalData.attachZoomRectangleInteractor && this.zoomRectangleInteractor ) {

			// Attach zoom rectangle interactor to the current object

			this.zoomRectangleInteractor.setObjectScene( object, this.currentScene, this.pixelRatio );

		}

		if ( object.internalData.attachPanInteractor && this.panInteractor ) {

			// Convert the object's parent (which will either be a "ChartSceneGroup"
			// or "AxisSceneGroup" created by the OpenViz Domain component) into a scene

			var parent = object.parent;

			parent.matrix.copy( object.matrixWorld );
			parent.matrixAutoUpdate = false;

			parent.isScene = true; // pretend to be a THREE.Scene
			parent.autoUpdate = true;
			parent.overrideMaterial = null;
			parent.internalData.is3D = this.currentScene.internalData.is3D;

			parent.internalData.x = this.currentScene.internalData.x;
			parent.internalData.y = this.currentScene.internalData.y;
			parent.internalData.width = this.currentScene.internalData.width;
			parent.internalData.height = this.currentScene.internalData.height;

			// Re-use current camera
			object.camera = parent.camera = this.currentScene.camera;

			var width = object.camera.right - object.camera.left;
			var height = object.camera.top - object.camera.bottom;

			// Lower-left corner of the workbox

			var point = new Vector3();

			point.set( - object.internalData.xSize / 2, - object.internalData.ySize / 2, 0 );
			point.applyMatrix4( parent.matrix );

			// Upper-right corner of the workbox

			var point2 = new Vector3();

			point2.set( object.internalData.xSize / 2, object.internalData.ySize / 2, 0 );
			point2.applyMatrix4( parent.matrix );

			var leftLimit = ( point.x - object.camera.left ) / width;
			var rightLimit = ( point2.x - object.camera.left ) / width;
			var bottomLimit = ( point.y - object.camera.bottom ) / height;
			var topLimit = ( point2.y - object.camera.bottom ) / height;

			var x1 = parent.internalData.x + leftLimit * parent.internalData.width;
			var x2 = parent.internalData.x + rightLimit * parent.internalData.width;

			var y1 = parent.internalData.y + bottomLimit * parent.internalData.height;
			var y2 = parent.internalData.y + topLimit * parent.internalData.height;

			if ( object.internalData.attachPanInteractor === 'center' ) {

				parent.vpX = x1;
				parent.vpWidth = x2 - x1;
				parent.vpY = y1;
				parent.vpHeight = y2 - y1;

				parent.widthScale = this.panInteractor.widthScale;
				parent.heightScale = this.panInteractor.heightScale;

				parent.leftLimit = leftLimit;
				parent.rightLimit = rightLimit;
				parent.bottomLimit = 1 - bottomLimit;
				parent.topLimit = 1 - topLimit;

			} else if ( object.internalData.attachPanInteractor === 'bottom' ) {

				parent.vpX = x1;
				parent.vpWidth = x2 - x1;
				parent.vpY = 0;
				parent.vpHeight = y2;

				parent.widthScale = this.panInteractor.widthScale;

			} else if ( object.internalData.attachPanInteractor === 'top' ) {

				parent.vpX = x1;
				parent.vpWidth = x2 - x1;
				parent.vpY = y1;
				parent.vpHeight = 1 - y1;

				parent.widthScale = this.panInteractor.widthScale;

			} else if ( object.internalData.attachPanInteractor === 'left' ) {

				parent.vpX = 0;
				parent.vpWidth = x2;
				parent.vpY = y1;
				parent.vpHeight = y2 - y1;

				parent.heightScale = this.panInteractor.heightScale;

			} else if ( object.internalData.attachPanInteractor === 'right' ) {

				parent.vpX = x1;
				parent.vpWidth = 1 - x1;
				parent.vpY = y1;
				parent.vpHeight = y2 - y1;

				parent.heightScale = this.panInteractor.heightScale;

			}

			// Reset scene offset

			parent.matrix.elements[ 12 ] = 0;
			parent.matrix.elements[ 13 ] = 0;

			this.addScene( parent, true );

			if ( object.internalData.attachPanInteractor === 'center' ) {

				this.panInteractor.object = parent.div;

			} else if ( object.internalData.attachPanInteractor === 'bottom' ) {

				this.panInteractor.linkObjectsBottom.push( parent.div );

			} else if ( object.internalData.attachPanInteractor === 'top' ) {

				this.panInteractor.linkObjectsTop.push( parent.div );

			} else if ( object.internalData.attachPanInteractor === 'left' ) {

				this.panInteractor.linkObjectsLeft.push( parent.div );

			} else if ( object.internalData.attachPanInteractor === 'right' ) {

				this.panInteractor.linkObjectsRight.push( parent.div );

			}

			if ( this.loading && parent.parent ) {

				parent.parent.remove( parent );

			}

			this.panInteractor.update();

		}

	}

    createPickingInfo( object ) {

		if ( object.geometry !== undefined && object.material !== undefined ) {

			if ( object.geometry.attributes.cellCount === undefined ) {

				var cellCount;
				var nCells;

				if ( object.material.glyphs ) {

					var nGlyphs = object.geometry.attributes.offset.array.length / 3;
					nCells = nGlyphs;

					var cellArray = new Float32Array( nGlyphs );
					for ( var i = 0; i < nGlyphs; i ++ ) {
						cellArray[ i ] = i;
					}

					cellCount = new InstancedBufferAttribute( cellArray, 1 );

				} else if ( object.isThickLineSegments ) {

					var nVertices = object.geometry.attributes.instanceStart.array.length / 3;
					nCells = nVertices / 2;

					var cellArray = new Float32Array( nCells );
					for ( var i = 0; i < nCells; i ++ ) {
						cellArray[ i ] = i;
					}

					cellCount = new InstancedBufferAttribute( cellArray, 1 );

				} else {

					var step = 1;
					if ( object.isPoints ) {
						step = 1;
					} else if ( object.isLineSegments ) {
						step = 2;
					} else if ( object.isMesh ) {
						step = 3;
					}

					var nVertices = object.geometry.attributes.position.array.length / 3;
					nCells = nVertices / step;
					cellCount = new Float32BufferAttribute( nVertices, 1 );

					for ( var i = 0; i < nCells; i ++ ) {
						for ( var j = 0; j < step; j ++ ) {
							cellCount.array[ i * step + j ] = i;
						}
					}

				}

				object.geometry.setAttribute( 'cellCount', cellCount );
				object.geometry.nCells = nCells;

			}

			object.nCells = object.geometry.nCells;
			object.startCell = this.startCell;

			object.onBeforeRender = function( renderer, scene, camera, geometry, material, group ) {

				material.uniforms.startCell.value = this.startCell;

				var materialProperties = renderer.properties.get( material );

				// Material already programmed, this is currently the only way to change a uniform at this point
				if ( materialProperties.program ) {

					var gl = renderer.getContext();

					gl.useProgram( materialProperties.program.program );

					materialProperties.program.getUniforms().setValue( gl, "startCell", this.startCell );

				}

			};

			this.startCell += object.nCells;

			// Overflowed the first picking render target (2^24-1 cells) so need to use second as well
			if ( ! this.pickingRenderTarget2 && this.startCell > 16777215 ) {

				this.pickingRenderTarget2 = new WebGLRenderTarget( this.pixelWidth, this.pixelHeight );
				this.pickingPixelBuffer2 = new Uint8Array( 4 * this.pixelWidth * this.pixelHeight );

			}

			this.updatePicking = true;

		}

	}

    addLabels( object ) {

        if ( object.isBillboardText ) {

			// Add this label to the scene's list
			if ( object.parent.internalData.attachPanInteractorStatic ) {

				object.addToScene( this.currentRealScene );

			} else {

				object.addToScene( this.currentScene );

			}

		}

    }

	addMaterialReferences( object ) {

		if ( object.material !== undefined ) {

			// Keep a reference to the pick state in the shaders
			object.material.pickState = this.pickState;

			if ( object.material.isLineBasicMaterial !== undefined ) {

				// Keep a reference to the screen resolution needed for the line material shaders
				object.material.resolution = this.resolution;

			}

		}

	}

    loadGeometryAsJson( json ) {

		var scope = this;

        this.objectLoader.parse( json, function( object ) {

			scope.clearGeometry();

			scope.updateSize();

			scope.addGeometry( object );

			scope.render();

		} );

    }

	loadGeometryAsEvents( data ) {

        var scope = this;
        var parsedCount = 0;
        var doneCount = -1;
        var remainingCount = 0;

		if ( this.chunkId === undefined || this.chunkId !== data.chunkId ) {

			this.clearGeometry();

			// Reset state vars
			this.curGroup = null;
			this.images = [];
			this.textures = [];
			this.materials = [];
			this.geometries = [];

			this.firstChunk = true;
			this.chunkId = data.chunkId;

		}

		this.loading = true;
		this.updateSize();

        function streamCallback( item ) {

            remainingCount--;
//            console.log("doneCount = " + doneCount + ", callbackCount = " + callbackCount + ", remainingCount = " + remainingCount);

			// Place new items in layer 1 so only they will be rendered next time
			item.layers.set( 1 );

            // Wait to make geometry visible until item is completely loaded
            item.visible = item.saveVisible;

            // Check if we are done
            if ( doneCount > 0 && remainingCount == 0 ) {

//				console.log('done in streamCallback');

				scope.render();

				scope.loading = false;
				scope.firstChunk = false;

                return;

            }

        }

        function processEvent( data ) {

            if ( data.type === "Group" ) {

                var newGroup = scope.objectLoader.parse( data );

                // If it's a sub-group, add to the parent
                if ( scope.curGroup !== null ) {

                    scope.curGroup.add( newGroup );

                }

				// Set the container background color from the scene root
				if ( newGroup.name === "SceneRoot" ) {

					if ( newGroup.internalData.background !== undefined ) {

						scope.container.style.backgroundColor = "#" + newGroup.internalData.background.toString( 16 ).padStart( 6, '0' );

					} else {

						scope.container.style.backgroundColor = "transparent";

					}

				}

				newGroup.updateMatrixWorld( true );
				scope.attachInteractors( newGroup );

                scope.curGroup = newGroup;

            } else if ( data.type === "FinishGroup" ) {

				if ( scope.curGroup !== null ) {

					scope.curGroup = scope.curGroup.parent;

				}

            } else if ( data.type === "Geometry" ) {

                remainingCount++;
                var item = scope.objectLoader.parse( data, streamCallback, scope.images, scope.textures, scope.materials, scope.geometries/*, scope.dataMaps*/, scope.curGroup );
                parsedCount++;

			    scope.addLabels( item );
                scope.createPickingInfo( item );
				scope.addMaterialReferences( item );

            } else if ( data.type === "Layout" ) {

                var scene = scope.objectLoader.parse( data );

				// Find camera reference

				for ( var i = 0; i < scene.children.length; i ++ ) {

					var child = scene.children[ i ];

					if ( child.isPerspectiveCamera || child.isOrthographicCamera ) {

						scene.camera = child;
						scene.remove( child );
						break;

					}

				}

				// No camera? Add a dummy one if we need to draw the background

				if ( scene.camera == undefined && scene.background !== null ) {

					scene.camera = new OrthographicCamera$1();

				}

				if ( scene.camera !== undefined ) {

					scope.addScene( scene );

				}

                scope.curGroup = scene;

            } else {

                console.log("ERROR: unknown type: " + data.type);

            }

        }

        if ( data === undefined || data.events === undefined || data.events.length === 0 ) {

            console.error( 'AVS.Three.Viewer.loadGeometryAsEvents: Can\'t get events' );
            return;

        }

//        console.log( "Events in chunk = " + data.events.length );

        for ( var i = 0; i < data.events.length; i ++ ) {

            processEvent( data.events[i] );

        }

        if ( data.moreChunks === true ) {
				
//			console.log('more chunks');

			this.render();
	    
        } else {

            doneCount = parsedCount - 1;

//			console.log('no more chunks, remaining = ' + remainingCount);

			if ( remainingCount == 0 ) {

				this.render();

				this.loading = false;

			}

        }

		this.firstChunk = false;

	}
/*
    findDataMap( object, type ) {
        var curObject = object.parent;
        while( curObject !== undefined && curObject !== null) {
            if (curObject.userData !== undefined && curObject.userData.dataMaps !== undefined) {
                var objectDataMaps = curObject.userData.dataMaps;
                if (objectDataMaps.hasOwnProperty( type )) {
                    return objectDataMaps[type]; 
                }
            }
            curObject = curObject.parent;	
        }
    }

    cleanDataMaps( dataMaps ) {
        if ( dataMaps !== undefined) {
            for (var dataMap in dataMaps) {
                if ( dataMaps.hasOwnProperty(dataMap)) {
                    dataMaps[dataMap].setDirty(false);
                }
            }
        }
    }

    // Data map update works in onBeforeRender for material level changes but not for vertex based changes (one render behind)
    evaluateDataMaps( object ) {
        // Set a callback to evaluate the datamaps just prior to rendering
        if ( object.userData.cellSetData !== undefined && object.userData.cellSetData.dataMapSourceValues != undefined) {
            var dataMapSourceValues = object.userData.cellSetData.dataMapSourceValues;
            if (dataMapSourceValues !== undefined) {

                // color map
                var colorValue = dataMapSourceValues.color;
                if ( colorValue !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'color'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var newColor = curDataMap.evaluate( colorValue );
                        if (newColor !== undefined) {
                            object.material.color = newColor;
                            object.material.colorWrite = true;
                        }
                        else {
                            object.material.colorWrite = false;
                        }
                    }
                }

                // size map
                var sizeValue = dataMapSourceValues.size;
                if ( sizeValue !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'size'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var newSize = curDataMap.evaluate( sizeValue );
                        if (newSize !== undefined) {
                            // update object matrix size here

                            object.material.colorWrite = true;
                        }
                        else {
                            object.material.colorWrite = false;
                        }
                    }
                }

                // shape map
                var shapeValue = dataMapSourceValues.shape;
                if ( shapeValue !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'shape'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var newShape = curDataMap.evaluate( shapeValue );
                        if (newShape !== undefined) {
                            object.geometry = newShape;
                            object.material.colorWrite = true;
                        }
                        else {
                            object.material.colorWrite = false;
                        }
                    }
                }
            }
        }
        else if ( object.userData.cellData !== undefined && object.userData.cellData.dataMapSourceValues != undefined) {
            var dataMapSourceValues = object.userData.cellData.dataMapSourceValues;
            if (dataMapSourceValues !== undefined) {
                // Color map
                var colorValues = dataMapSourceValues.color;
                if ( colorValues !== undefined ) {
                    var curDataMap = this.findDataMap(object, 'color'); 
                    if (curDataMap !== undefined && curDataMap.isDirty()) {
                        var count = null;
                        var length = null;
                        var attribute = object.geometry.attributes.color;

                        for (var i = 0; i < colorValues.length; i++) {
                            var newColor = curDataMap.evaluate( colorValues[i] );

                            if (object.cellType === AVS.Three.CellTypeEnum.Points) { // THREE.Points
                                count = 3*i;
                                length = 1;
                            } else if (object.cellType === AVS.Three.CellTypeEnum.Lines) { // THREE.LineSegments
                                count = 6*i;
                                length = 2;
                            } else if (object.cellType === AVS.Three.CellTypeEnum.Triangles) { // THREE.Mesh tris
                                count = 9*i;
                                length = 3;
                            } else { // THREE.Mesh quads
                                count = 9*i; 
                                length = 3;
                            }

                            if (newColor !== undefined) {
                                for (var k = 0; k < length; k++) {
                                    attribute.array[count++] = newColor.r;
                                    attribute.array[count++] = newColor.g;
                                    attribute.array[count++] = newColor.b;
                                }
                            }
                            else {
                                for (var k = 0; k < length; k++) {
                                    attribute.array[count++] = undefined;
                                    attribute.array[count++] = undefined;
                                    attribute.array[count++] = undefined;
                                }
                            }
                        }
                        attribute.needsUpdate = true;
                    }
                }
            }
        }

        for (var i = 0; i < object.children.length; i++) {
            this.evaluateDataMaps(object.children[i]);
        }
    }
*/
	highlightRender() {

		if ( this.renderer === undefined ) {

			console.error( 'AVS.Three.Viewer: WebGLRenderer not set.' );
			return;

		}

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            var scene = this.scenes[ i ];         

			this.resolution.x = scene.pixelWidth;
			this.resolution.y = scene.pixelHeight;

			this.renderer.setSize( scene.width, scene.height );
			this.renderer.setClearColor( 0x000000, 0 );
			this.renderer.clear();

            this.renderer.render( scene.highlightScene, scene.camera );

			// Copy the renderer's canvas pixel buffer to the highlight canvas
			scene.highlightCtx.clearRect( 0, 0, scene.pixelWidth, scene.pixelHeight );
			scene.highlightCtx.drawImage( this.renderer.domElement, 0, 0 );

        }

	}

	pickRender() {

		if ( this.renderer === undefined ) {

			console.error( 'AVS.Three.Viewer: WebGLRenderer not set.' );
			return;

		}

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            var scene = this.scenes[ i ];         

			// Make all objects opaque otherwise three.js will always renderer
			// transparent objects in front and hide intersecting objects.
			scene.traverse( function( child ) {

				if ( child.material !== undefined ) {

					child.material.transparent = false;

				}

			} );

			this.resolution.x = scene.pixelWidth;
			this.resolution.y = scene.pixelHeight;

			// Render to the scene's picking render target
			this.renderer.setRenderTarget( scene.pickingRenderTarget );
			this.pickState[ 0 ] = 1;

			this.renderer.setClearColor( 0x000000, 0 );
			this.renderer.clear();

			this.renderer.render( scene, scene.camera );

			// Read the pixels from the primary render target to the primary pixel buffer
			this.renderer.readRenderTargetPixels( scene.pickingRenderTarget, 0, 0, scene.pixelWidth, scene.pixelHeight, scene.pickingPixelBuffer );

			if ( scene.pickingRenderTarget2 ) {

				// Render to the scene's secondary picking target
				this.renderer.setRenderTarget( scene.pickingRenderTarget2 );
				this.pickState[ 0 ] = 2;

				this.renderer.clear();

				this.renderer.render( scene, scene.camera );

				// Read the pixels from the secondary render target to the secondary pixel buffer
				this.renderer.readRenderTargetPixels( scene.pickingRenderTarget2, 0, 0, scene.pixelWidth, scene.pixelHeight, scene.pickingPixelBuffer2 );

			}

			// Restore material transparency
			scene.traverse( function( child ) {

				if ( child.material !== undefined ) {

					child.material.transparent = child.material.saveTransparent;

				}

			} );

        }

		this.pickState[ 0 ] = 0;
		this.renderer.setRenderTarget( null );

	}

    render( forceFull ) {

		if ( this.renderer === undefined ) {

			console.error( 'AVS.Three.Viewer: WebGLRenderer not set.' );
			return;

		}

		// Don't try to render if we are hidden
		if ( this.domElement.offsetParent === null ) {

			return;

		}

		this.updateSize();

		var chunkRender = this.loading;
		var fullRender = forceFull || ! chunkRender;

        for ( var i = 0; i < this.scenes.length; i ++ ) {

            var scene = this.scenes[ i ];         

//            this.evaluateDataMaps( scene );

			this.resolution.x = scene.pixelWidth;
			this.resolution.y = scene.pixelHeight;

			if ( fullRender ) {

				this.renderer.setSize( scene.width, scene.height );

			} else {

				this.renderer.setRenderTarget( scene.renderTarget );

			}

			if ( fullRender || this.firstChunk ) {

				if ( scene.internalData.background ) {

					this.renderer.setClearColor( scene.internalData.background, 1 );

				} else {

					this.renderer.setClearColor( 0x000000, 0 );

				}

				this.renderer.clear();

			}

			// Per-chunk rendering: place the camera+lights in layer 1, then draw to renderTarget
			if ( ! fullRender ) {

				scene.camera.layers.set( 1 );

				for ( var j = 0; j < scene.children.length; j ++ ) {

					if ( scene.children[ j ].isLight ) {

						scene.children[ j ].layers.set( 1 );

					}

				}

			}

			this.renderer.render( scene, scene.camera );

			if ( fullRender ) {

				// Copy the renderer's canvas contents to the scene's canvas

				scene.ctx.clearRect( 0, 0, scene.pixelWidth, scene.pixelHeight );
				scene.ctx.drawImage( this.renderer.domElement, 0, 0 );

			} else {

				// Copy the renderTarget's pixel buffer to the scene's canvas (with vertical flip)

				this.renderer.readRenderTargetPixels( scene.renderTarget, 0, 0, scene.pixelWidth, scene.pixelHeight, scene.pixelBuffer );
				var imgData = scene.ctx.createImageData( scene.pixelWidth, scene.pixelHeight );

				var row, col, rowLength = 4 * scene.pixelWidth;
				for ( var k = 0; k < scene.pixelBuffer.length; k ++ ) {

					row = Math.floor( k / rowLength );
					col = k % rowLength;
					imgData.data[ ( scene.pixelHeight - row - 1 ) * rowLength + col ] = scene.pixelBuffer[ k ];

				}

				scene.ctx.putImageData( imgData, 0, 0 );

				this.renderer.setRenderTarget( null );

				// Place just rendered camera+lights+objects back in layer 0

				scene.camera.layers.set( 0 );

				scene.traverse( function( child ) {

					child.layers.set( 0 );

				} );

			}

            for ( var j = 0; j < scene.labels.length; j ++ ) {

                scene.labels[ j ].updatePosition();

            }

		}

        // Wait to clean data maps until all scene have been rendered because they 
        // may be shared between scenes.
//        this.cleanDataMaps( this.getDataMaps() );

		// Finally render the highlight layer
		if ( this.updateHighlight ) {

			this.highlightRender();
			this.updateHighlight = false;

		}

    }

	addSelectionListener( listener ) {

		if ( listener !== undefined ) {

			this.selectionListeners.push( listener );

		}

	}

    concatObjectsFromCellNums( intersects, object, cellNums, startCell ) {

        // No cells remaining to find
        if ( cellNums === undefined || cellNums.length === 0 || cellNums[ 0 ] === 0 ) {

            return undefined;

        }

        // Start with scene's first cell and sort the cell numbers into increasing order
        if ( startCell === undefined ) {

            startCell = object.startCell;

            cellNums.sort( function( a, b ) {

				return a - b;

			} );

        }

        // Check if this object has a cell matching cellNums[ 0 ]
        while ( object.nCells !== undefined && cellNums[ 0 ] >= startCell && cellNums[ 0 ] < startCell + object.nCells ) {

			if ( object.material.glyphs || object.isThickLineSegments ) {

				intersects.push( {

					object: object,
					index: cellNums[ 0 ] - startCell

				} );

			} else if ( object.isMesh ) {

				intersects.push( {

					object: object,
					faceIndex: cellNums[ 0 ] - startCell

				} );

			} else {

				intersects.push( {

					object: object,
					index: ( object.isLineSegments ? 2 : 1 ) * ( cellNums[ 0 ] - startCell )

				} );

			}

            // Remove cellNums[ 0 ] and test this object again with new cellNums[ 0 ]
            cellNums.splice( 0, 1 );

            // No cells remaining to find
            if ( cellNums.length === 0 ) {

                return undefined;

            }
        }

		// Done with current object, increment startCell and start checking the children
        if ( object.nCells !== undefined ) {

            startCell += object.nCells;

        }

        for ( var i = 0; i < object.children.length; i ++ ) {

            startCell = this.concatObjectsFromCellNums( intersects, object.children[ i ], cellNums, startCell );

            if ( startCell === undefined ) {

                break;

            }

        }

        return startCell;

    }
/*
    getDataMapSourceCellValue( object, primitiveIndex, type ) {
        var cellIndex = undefined;
        var count = 1;

        if (object !== undefined) {
            if (object.cellType === AVS.Three.CellTypeEnum.Points) { // THREE.Points
                cellIndex = primitiveIndex;
            } else if (object.cellType === AVS.Three.CellTypeEnum.Lines) { // THREE.LineSegments
                cellIndex = primitiveIndex/2;
            } else if (object.cellType === AVS.Three.CellTypeEnum.Triangles) { // THREE.Mesh tris
                cellIndex = primitiveIndex/3;
            } else { // THREE.Mesh quads
                cellIndex = Math.floor(primitiveIndex/6); // highlight this tri and its pair
                count = 2;
            }
        }

        var values = object.userData.cellData.dataMapSourceValues[type];
        return values[cellIndex * count];
    }
*/
	/**
	 * Pick objects using a ray or rectangle
	 */
    pick() {

		if ( this.validPick === false ) {

			console.error( 'AVS.Three.Viewer: invalid pick ray or rectangle.' );
			return;

		}

		// Update the picking render targets if needed
		if ( this.pickDepth === PickDepthEnum.Closest && this.updatePicking ) {

			this.pickRender();
			this.updatePicking = false;

		}

		this.intersects = [];

        for ( var s = 0; s < this.scenes.length; s ++ ) {

            var scene = this.scenes[ s ];

            if ( this.pickType === PickTypeEnum.Rectangle ) {

				// Calculate intersection of the pick rectangle and this scene's viewport
				var startX = Math.max( this.pickRectangleX, scene.viewportPixelX );
				var startY = Math.max( this.pickRectangleY, scene.viewportPixelTop );

				var endX = Math.min( this.pickRectangleX + this.pickRectangleWidth, scene.viewportPixelX + scene.viewportPixelWidth );
				var endY = Math.min( this.pickRectangleY + this.pickRectangleHeight, scene.viewportPixelTop + scene.viewportPixelHeight );

				// Translate pixel on viewport to pixel on canvas
				startX -= scene.viewportPixelX;
				startY -= scene.viewportPixelTop;
				endX -= scene.viewportPixelX;
				endY -= scene.viewportPixelTop;

				// Offset due to panned scene
				if ( scene.div.panOffsetX ) {

					startX -= ( scene.div.panOffsetX + scene.div.baseLeft );
					endX -= ( scene.div.panOffsetX + scene.div.baseLeft );

				}

				if ( scene.div.panOffsetY ) {

					startY -= ( scene.div.panOffsetY + scene.div.baseTop );
					endY -= ( scene.div.panOffsetY + scene.div.baseTop );

				}

                var cellNums = [];

				// Loop through every pixel in the intersection
                for ( var x = startX; x < endX; x ++ ) {

                    for ( var y = endY; y < startY; y ++ ) {

						// Pick all objects using CPU (THREE.Raycaster)
						if ( this.pickDepth === PickDepthEnum.All ) {

							var rayX = ( x / scene.pixelWidth ) * 2 - 1;
							var rayY = ( ( scene.pixelHeight - y - 1 ) / scene.pixelHeight ) * 2 - 1;

							this.raycaster.setFromCamera( new Vector2( rayX, rayY ), scene.camera );

                            var rayIntersects = this.raycaster.intersectObjects( scene.children, true );

							this.intersects = this.intersects.concat( rayIntersects );

						// Pick closest object using GPU (picking render target)
						} else {

							var index = ( x + ( ( scene.pixelHeight - y - 1 ) * scene.pixelWidth ) ) * 4;

							var cellNum = ( scene.pickingPixelBuffer[ index     ] * 255 * 255 ) +
							              ( scene.pickingPixelBuffer[ index + 1 ] * 255 ) +
							              ( scene.pickingPixelBuffer[ index + 2 ] );

							if ( scene.pickingPixelBuffer2 ) {

								cellNum += ( scene.pickingPixelBuffer2[ index     ] * 255 * 255 * 255 * 255 * 255 ) +
								           ( scene.pickingPixelBuffer2[ index + 1 ] * 255 * 255 * 255 * 255 ) +
								           ( scene.pickingPixelBuffer2[ index + 2 ] * 255 * 255 * 255 );

							}

                            // Save unique cell nums
                            if ( cellNum > 0 && cellNums.indexOf( cellNum ) === -1 ) {

                                cellNums.push( cellNum );

                            }

                        }

                    }

                }

                if ( this.pickDepth === PickDepthEnum.Closest ) {

					// Convert from cellNum to object+index
                    this.concatObjectsFromCellNums( this.intersects, scene, cellNums );

                }

            } else {

				// Skip if ray missed this scene's viewport
				if ( this.pickRayX < scene.viewportPixelX ||
				     this.pickRayX > ( scene.viewportPixelX + scene.viewportPixelWidth ) ||
				     this.pickRayY < scene.viewportPixelTop ||
				     this.pickRayY > ( scene.viewportPixelTop + scene.viewportPixelHeight ) ) {

					continue;

				}

				// Translate pixel on viewport to pixel on canvas
				var pickX = this.pickRayX - scene.viewportPixelX;
				var pickY = this.pickRayY - scene.viewportPixelTop;

				// Offset due to panned scene
				if ( scene.div.panOffsetX ) { pickX -= ( scene.div.panOffsetX + scene.div.baseLeft ); }
				if ( scene.div.panOffsetY ) { pickY -= ( scene.div.panOffsetY + scene.div.baseTop ); }

				// Pick all objects using CPU (THREE.Raycaster)
                if ( this.pickDepth === PickDepthEnum.All ) {

					var rayX = ( pickX / scene.pixelWidth ) * 2 - 1;
					var rayY = ( ( scene.pixelHeight - pickY - 1 ) / scene.pixelHeight ) * 2 - 1;

                    this.raycaster.setFromCamera( new Vector2( rayX, rayY ), scene.camera );

					// Additions for custom point raycasting (see Points.js)
					this.raycaster.scene = scene;
					this.raycaster.x = pickX;
					this.raycaster.y = pickY;

                    var rayIntersects = this.raycaster.intersectObjects( scene.children, true );

					this.intersects = this.intersects.concat( rayIntersects );

				// Pick closest object using GPU (picking render target)
                } else {

                    var index = ( pickX + ( ( scene.pixelHeight - pickY - 1 ) * scene.pixelWidth ) ) * 4;

					var cellNum = ( scene.pickingPixelBuffer[ index     ] * 255 * 255 ) +
					              ( scene.pickingPixelBuffer[ index + 1 ] * 255 ) +
					              ( scene.pickingPixelBuffer[ index + 2 ] );

					if ( scene.pickingPixelBuffer2 ) {

						cellNum += ( scene.pickingPixelBuffer2[ index     ] * 255 * 255 * 255 * 255 * 255 ) +
						           ( scene.pickingPixelBuffer2[ index + 1 ] * 255 * 255 * 255 * 255 ) +
						           ( scene.pickingPixelBuffer2[ index + 2 ] * 255 * 255 * 255 );

					}

					// Convert from cellNum to object+index
                    this.concatObjectsFromCellNums( this.intersects, scene, [ cellNum ] );

                }

            }

        }

		// Send event to any listeners
		for ( var s = 0; s < this.selectionListeners.length; s ++ ) {

			this.selectionListeners[ s ]();

		}

	}

	getPickedCells() {

		var selectionList = [];

        for ( var i = 0; i < this.intersects.length; i ++ ) {

			var object = this.intersects[ i ].object;

			if ( object.internalData.pickable === false ) {

				continue;

			}

            // Select this object (and its cells) if it isn't already
			var index = this.intersects[ i ].faceIndex ? this.intersects[ i ].faceIndex : this.intersects[ i ].index;
			var objectAlreadySelected = false;

			for ( var j = 0; j < selectionList.length; j ++ ) {

				// Add new index if the object has already been selected
				if ( object === selectionList[ j ].object ) {

					objectAlreadySelected = true;
					var indexAlreadySelected = false;

					for ( var k = 0; k < selectionList[ j ].indices.length; k ++ ) {

						if ( index === selectionList[ j ].indices[ k ] ) {

							indexAlreadySelected = true;
							break;

						}

					}

					// But only if the index hasn't been added already
					if ( ! indexAlreadySelected ) {

						selectionList[ j ].indices.push( index );

					}

					break;

				}

			}

			if ( ! objectAlreadySelected ) {

				selectionList.push( {

					object: object,
					indices: [ index ]

				} );

			}

		}

		return selectionList;

	}

	getPickedCellSets() {

		var selectionList = [];

        for ( var i = 0; i < this.intersects.length; i ++ ) {

			var object = this.intersects[ i ].object;

			if ( object.internalData.pickable === false ) {

				continue;

			}

            // Select this object if it isn't already
            var alreadySelected = false;

            for ( var j = 0; j < selectionList.length; j ++ ) {

                if ( selectionList[ j ].object === object ) {

                    alreadySelected = true;
                    break;

                }

            }

            if ( ! alreadySelected ) {

				selectionList.push( { object: object } );

			}

		}

		return selectionList;

	}

	getPickedSceneNodes() {

		var selectionList = [];

        for ( var i = 0; i < this.intersects.length; i ++ ) {

			var object = this.intersects[ i ].object;

			if ( object.internalData.pickable === false ) {

				continue;

			}

            // Select this object's parent if it isn't already
            var parent = object.parent;
			var alreadySelected = false;

			for ( var k = 0; k < selectionList.length; k ++ ) {

				if ( selectionList[ k ].object === parent ) {

					alreadySelected = true;
					break;

				}

			}

			if ( ! alreadySelected ) {

				selectionList.push( { object: parent } );

			}

		}

		return selectionList;

	}

	getSelectionInfo( selectionList ) {

		var selectionInfo = [];

        for ( var i = 0; i < selectionList.length; i ++ ) {

            var object = selectionList[ i ].object;
			var indices = selectionList[ i ].indices;

			// If selecting cells need one selectionInfo entry for every cell
			if ( indices !== undefined ) {

				for ( var j = 0; j < indices.length; j ++ ) {

					selectionInfo.push( getSelectionInfoObject( object, {}, indices[ j ] ) );

				}

			} else {

				selectionInfo.push( getSelectionInfoObject( object, {} ) );

			}

		}

		function getSelectionInfoObject( object, info, index ) {

			// Check us then each of our parents until we accumulate all entries in userData

			for ( var entry in object.userData ) {

				// We don't have this entry yet
				if ( info[ entry ] === undefined ) {

					if ( index !== undefined && Array.isArray( object.userData[ entry ] ) ) {

						info[ entry ] = decodeURIComponent( object.userData[ entry ][ index ] );

					} else {

						info[ entry ] = decodeURIComponent( object.userData[ entry ] );

					}

				}

			}

			if ( object.parent ) {

				return getSelectionInfoObject( object.parent, info );

			}

			return info;

		}

		return selectionInfo;

	}

	highlightObjects( selectionList, highlightLayer ) {

		var fullRender = false;

		// Restore highlighted objects to their regular state
		for ( var i = 0; i < this.highlightList.length; i ++ ) {

			var object = this.highlightList[ i ];

			// Restore original material
			if ( object.saveMaterial !== undefined ) {

				object.material = object.saveMaterial;
				object.saveMaterial = undefined;

				fullRender = true;

			}

			// Restore original geometry
			if ( object.saveGeometry !== undefined ) {

				object.geometry = object.saveGeometry;
				object.saveGeometry = undefined;

				fullRender = true;

			}

		}

		// Clear out the cloned objects from each highlight scene
        for ( var i = 0; i < this.scenes.length; i ++ ) {

			var highlightObjects = this.scenes[ i ].highlightScene.children[ 0 ].children;

			if ( highlightObjects.length > 0 ) {

				highlightObjects.length = 0;

				this.updateHighlight = true;

			}

		}

        this.highlightList.length = 0;

		var scope = this;

        // Highlight selected objects, either by changing color in-place
		// or cloning and rendering them in front
        for ( var i = 0; i < selectionList.length; i ++ ) {

            var object = selectionList[ i ].object;
			var indices = selectionList[ i ].indices;

			highlightObject( object, indices );

        }

		function highlightObject( object, indices ) {

			if ( object.isMesh || object.isLineSegments || object.isPoints ) {

				scope.highlightList.push( object );

				// Clone the material
				var highlightMaterial = object.material.clone();
				highlightMaterial.opacity = 1.0;

				var highlightGeometry;

				// If selecting cells need to process color attribute
				if ( indices !== undefined ) {

					var geometry = object.geometry;

					highlightMaterial.vertexColors = true;
					highlightMaterial.color = new Color( 0xffffff );

					if ( object.isThickLineSegments ) {

						highlightGeometry = new InstancedBufferGeometry();

						geometry.attributes.instancedColorStart;
						var colorBuffer;

						if ( oldColorStart === undefined ) {

							// Create new color buffer
							colorBuffer = new InstancedInterleavedBuffer( new Float32Array( geometry.attributes.instanceStart.array.length ), 6, 1 );

							// Color all cells with material color
							var count = 0;
							for ( var j = 0; j < colorBuffer.array.length / 3; j ++ ) {

								colorBuffer.array[ count ++ ] = object.material.color.r;
								colorBuffer.array[ count ++ ] = object.material.color.g;
								colorBuffer.array[ count ++ ] = object.material.color.b;

							}

						} else {

							// Clone existing color buffer
							colorBuffer = oldColorStart.data.clone();

						}

						// Update the selected cells
						var count = null;
						var length = null;

						for ( var j = 0; j < indices.length; j ++ ) {

							count = 6 * Math.floor( indices[ j ] / 6 );
							length = 2;

							for ( var k = 0; k < length; k ++ ) {

								colorBuffer.array[ count ++ ] = scope.highlightColor.r;
								colorBuffer.array[ count ++ ] = scope.highlightColor.g;
								colorBuffer.array[ count ++ ] = scope.highlightColor.b;

							}

						}

						highlightGeometry.setAttribute( 'instancedColorStart', new InterleavedBufferAttribute( colorBuffer, 3, 0 ) );
						highlightGeometry.setAttribute( 'instancedColorEnd', new InterleavedBufferAttribute( colorBuffer, 3, 3 ) );

						// Copy attributes other than instancedColorStart/instancedColorEnd over as-is
						for ( var name in geometry.attributes ) {

							if ( name !== 'instancedColorStart' && name !== 'instancedColorEnd' ) {

								highlightGeometry.setAttribute( name, geometry.attributes[ name ] );

							}

						}

					} else { // ! isThickLineSegments

						highlightGeometry = object.material.glyphs ? new InstancedBufferGeometry() : new BufferGeometry();

						var oldAttribute = geometry.attributes.color;
						var attribute = null;

						if ( oldAttribute === undefined ) {

							// Create new color attribute
							if ( object.material.glyphs ) {

								attribute = new InstancedBufferAttribute( new Float32Array( geometry.attributes.offset.array.length ), 3 );

							} else {
							
								attribute = new Float32BufferAttribute( geometry.attributes.position.array.length, 3 );

							}

							// Color all cells with material color
							var count = 0;
							for ( var j = 0; j < attribute.array.length / 3; j ++ ) {

								attribute.array[ count ++ ] = object.material.color.r;
								attribute.array[ count ++ ] = object.material.color.g;
								attribute.array[ count ++ ] = object.material.color.b;

							}

						} else {

							// Clone existing color attribute
							attribute = oldAttribute.clone();

						}

						// Update the selected cells
						var count = null;
						var length = null;

						for ( var j = 0; j < indices.length; j ++ ) {

							if ( object.material.glyphs || object.cellType === CellTypeEnum.Points ) { // THREE.Points or glyphs

								count = 3 * indices[ j ];
								length = 1;

							} else if ( object.cellType === CellTypeEnum.Lines ) { // THREE.LineSegments

								count = 3 * indices[ j ];
								length = 2;

							} else if ( object.cellType === CellTypeEnum.Triangles ) { // THREE.Mesh tris

								count = 9 * indices[ j ];
								length = 3;

							} else { // THREE.Mesh quads

								count = 18 * Math.floor( indices[ j ] / 2 ); // highlight this tri and its pair
								length = 6;

							}

							for ( var k = 0; k < length; k ++ ) {

								attribute.array[ count ++ ] = scope.highlightColor.r;
								attribute.array[ count ++ ] = scope.highlightColor.g;
								attribute.array[ count ++ ] = scope.highlightColor.b;

							}

						}

						highlightGeometry.setAttribute( 'color', attribute );

						// Copy attributes other than color over as-is
						for ( var name in geometry.attributes ) {

							if ( name !== 'color' ) {

								highlightGeometry.setAttribute( name, geometry.attributes[ name ] );

							}

						}

					}

				// Selecting cellSets or sceneNodes, use material color
				} else {

					highlightMaterial.vertexColors = false;
					highlightMaterial.color = scope.highlightColor;

					// No change to geometry
					highlightGeometry = object.geometry;

				}

				var scene = scope.getObjectScene( object );

				// Clone object and add it to the highlight scene to be rendered separately
				if ( scene.internalData.is3D !== undefined && scene.internalData.is3D === false &&
				     highlightLayer !== undefined && highlightLayer === true ) {

					var clonedObj = object.clone();

					clonedObj.material = highlightMaterial;
					clonedObj.geometry = highlightGeometry;

					clonedObj.matrixAutoUpdate = false;
					clonedObj.matrix.copy( object.matrixWorld );

					scene.highlightScene.children[ 0 ].add( clonedObj );

					scope.updateHighlight = true;

				// Change the object's color in-place and re-render everything
				} else {

					object.saveMaterial = object.material;
					object.material = highlightMaterial;

					object.saveGeometry = object.geometry;
					object.geometry = highlightGeometry;

					fullRender = true;

				}

			}

			for ( var i = 0; i < object.children.length; i ++ ) {

				highlightObject( object.children[ i ] );

			}

		}

		// Re-render everything or just the highlight scenes
		if ( fullRender ) {

			this.render( true );

		} else if ( this.updateHighlight ) {

			this.highlightRender();
			this.updateHighlight = false;

		}

    }

	/**
	 * Traverse up this object's parents to find the scene it belongs to.
	 */
    getObjectScene( object ) {

        if ( object.isScene ) {

            return object;

        }

        return this.getObjectScene( object.parent );

    }

}

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };

// This set of controls performs rotation, scaling, and panning.

class TransformInteractor extends EventDispatcher {

	constructor( domElement ) {

		super();

		if ( domElement === undefined ) console.warn( 'AVS.Three.TransformInteractor: The first parameter "domElement" is now mandatory.' );
		if ( domElement === document ) console.error( 'AVS.Three.TransformInteractor: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Empty object & scene until setObjectScene() is called
		this.object = new Object3D();
		this.scene = null;

		// Set to false to disable this control
		this.enabled = true;

		// Set to false to disable zooming
		this.enableZoom = true;

		// Set to false to disable rotating
		this.enableRotate = true;

		// Set to false to disable panning
		this.enablePan = true;
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// Copies of object transforms
		this.quaternion = this.object.quaternion.clone();
		this.position = this.object.position.clone();
		this.scale = this.object.scale.clone();

		// Set to true to copy the transforms from the copies to the object
		// on load, the object has not been transformed on the server.
		this.clientOnly = false;

		// Set to true to copy the object's transforms to the reset and copy values.
		this.fullReset = false;

		// for reset
		this.quaternion0 = this.object.quaternion.clone();
		this.position0 = this.object.position.clone();
		this.scale0 = this.object.scale.clone();

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//
			
		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.setObjectScene = function( object, scene ) {

			scope.object = object;
			scope.scene = scene;

			if ( this.fullReset || object.internalData.transformFullReset ) {

				// Copy transform from object to reset and copy values

				scope.quaternion.copy( scope.object.quaternion );
				scope.scale.copy( scope.object.scale );
				scope.position.copy( scope.object.position );

				scope.quaternion0.copy( scope.object.quaternion );
				scope.scale0.copy( scope.object.scale );
				scope.position0.copy( scope.object.position );

				this.fullReset = false;

			} else if ( scope.clientOnly ) {

				// Copy transform from copy back to object

				scope.object.quaternion.copy( scope.quaternion );
				scope.object.scale.copy( scope.scale );
				scope.object.position.copy( scope.position );

			}

			if ( object.internalData.transformWheelActions ) {

				mouseWheelScrollActions = JSON.parse( object.internalData.transformWheelActions );

			}

			if ( object.internalData.transformTriggers ) {

				pointerTriggers = JSON.parse( object.internalData.transformTriggers );

			}

		};

		this.reset = function () {

			scope.quaternion.copy( scope.quaternion0 );
			scope.scale.copy( scope.scale0 );
			scope.position.copy( scope.position0 );

			scope.object.quaternion.copy( scope.quaternion0 );
			scope.object.scale.copy( scope.scale0 );
			scope.object.position.copy( scope.position0 );

			scope.dispatchEvent( _changeEvent );

			state = STATE.NONE;

		};

		this.zoomIn = function () {
			
			if ( scaleToPoint( 1.05, 0.0, 0.0 ) ) {

				scope.dispatchEvent( _changeEvent );

			}

		};

		this.zoomOut = function () {
			
			if ( scaleToPoint( 1 / 1.05, 0.0, 0.0 ) ) {

				scope.dispatchEvent( _changeEvent );

			}

		};

		this.panTo = function ( x, y, z ) {

			var matrixWorld = scope.object.parent.matrixWorld;

			var xScale = 1 / matrixWorld.elements[ 0 ];
			var yScale = 1 / matrixWorld.elements[ 5 ];
			var zScale = 1 / matrixWorld.elements[ 10 ];

			var xOrigin = matrixWorld.elements[ 12 ] * xScale;
			var yOrigin = matrixWorld.elements[ 13 ] * yScale;
			var zOrigin = matrixWorld.elements[ 14 ] * zScale;

			x *= scope.object.scale.x;
			y *= scope.object.scale.y;
			z *= scope.object.scale.z;

			x += xOrigin;
			y += yOrigin;
			z += zOrigin;

			scope.object.position.set( scope.position0.x - x, scope.position0.y - y, scope.position0.z - z );

			scope.position.copy( scope.object.position );

			scope.dispatchEvent( _changeEvent );

		};

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );


			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		let mouseWheelScrollActions = [ { "modifiers": 0, "param": "ZOOM_AT_POINTER" } ];

		let pointerTriggers = [
			{ "buttons": 1, "modifiers": 0, "param": "ROTATE" },
			{ "buttons": 2, "modifiers": 0, "param": "SCALE" },
			{ "buttons": 4, "modifiers": 0, "param": "TRANSLATE" }
		];

		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();

		const panStart = new Vector2();
		const panEnd = new Vector2();

		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();

		const pointers = [];
		const pointerPositions = {};

		function ndcAdjustX( x ) {

			const adjustX = x - scope.scene.viewportDiv.getBoundingClientRect().left;

			return ( 2 * adjustX / scope.scene.viewportWidth ) - 1;

		}

		function ndcAdjustY( y ) {

			const adjustY = y - scope.scene.viewportDiv.getBoundingClientRect().top;

			return 1 - ( 2 * adjustY / scope.scene.viewportHeight );

		}

		const rotate = function () {

			const total = new Matrix4();
			const origin = new Vector3();
			const s3 = new Vector3();
			const e3 = new Vector3();
			const invTotal = new Matrix4();
			const axis = new Vector3();
			let len, theta;
			const quat = new Quaternion();

			return function rotate() {

				if ( scope.object === null || scope.object.parent === null ) return false;

				total.multiplyMatrices( scope.scene.camera.matrixWorldInverse, scope.object.parent.matrixWorld ); // parent's modelViewMatrix
				
				origin.set( 0, 0, 0 );
				s3.set( rotateStart.x, rotateStart.y, 1 );
				e3.set( rotateEnd.x, rotateEnd.y, 1 );

				invTotal.copy( total ).invert();

				origin.applyMatrix4( invTotal );
				s3.applyMatrix4( invTotal );
				e3.applyMatrix4( invTotal );

				s3.sub( origin ).normalize();
				e3.sub( origin ).normalize();

				if ( scope.scene.internalData.is3D !== undefined && scope.scene.internalData.is3D === false ) {

					axis.set( 0, 0, 1 );

					len = s3.x * e3.y - s3.y * e3.x;
					if ( len < 0 ) {

						axis.negate();
						len = -len;

					}

				} else {

					axis.crossVectors( s3, e3 );

					len = axis.length();

				}

				if ( len < 0.00001 ) return false;

				if ( Math.abs( len ) < 1 ) {

					theta = 2 * Math.sin( len );

				} else {

					theta = Math.PI;

				}

				if ( s3.dot( e3 ) < 0 ) {

					theta += ( 0.5 * Math.PI );

				}

				quat.setFromAxisAngle( axis.normalize(), theta );
				scope.object.quaternion.premultiply( quat );

				scope.quaternion.copy( scope.object.quaternion );

				return true;

			};

		}();

		const pan = function () {

			const total = new Matrix4();
			const origin = new Vector4();
			const o3 = new Vector3();
			const invTotal = new Matrix4();
			const start = new Vector4();
			const end = new Vector4();
			const s3 = new Vector3();
			const e3 = new Vector3();
			const delta = new Vector3();

			return function pan() {

				if ( scope.object === null || scope.object.parent === null ) return false;

				total.multiplyMatrices( scope.scene.camera.matrixWorldInverse, scope.object.parent.matrixWorld ); // parent's modelViewMatrix
				total.premultiply( scope.scene.camera.projectionMatrix );

				origin.set( 0, 0, 0, 1 ).applyMatrix4( total );

				o3.set( origin.x / origin.w, origin.y / origin.w, origin.z / origin.w );

				invTotal.copy( total ).invert();

				// Place the 2 mouse points on the same plane as the
				// projection of the origin. This does the Z scaling
				// as if the 2 points were in the XY plane. That isn't
				// really correct. We should project them into a plane
				// that is parallel to the screen
				start.set( panStart.x, panStart.y, o3.z, 1 );
				end.set( panEnd.x, panEnd.y, o3.z, 1 );

				// back transform
				start.applyMatrix4( invTotal );
				end.applyMatrix4( invTotal );

				s3.set( start.x / start.w, start.y / start.w, start.z / start.w );
				e3.set( end.x / end.w, end.y / end.w, end.z / end.w );

				// Calculate the translation in model coordinates.
				delta.subVectors( e3, s3 );

				scope.object.position.add( delta );

				scope.position.copy( scope.object.position );

				return true;

			};

		}();

		function scale( scaleDelta ) {

			if ( scope.object === null ) return false;

			scope.object.scale.multiplyScalar( scaleDelta );

			scope.scale.copy( scope.object.scale );

			return true;

		}

		const scaleToPoint = function() {

			const total = new Matrix4();
			const invTotal = new Matrix4();
			const origin = new Vector4();
			const zoomPt = new Vector4();
			const pt3 = new Vector3();
			const v3 = new Vector3();

			return function( scaleDelta, ndcX, ndcY ) {

				if ( scope.object === null || scope.object.parent === null ) return false;

				total.multiplyMatrices( scope.scene.camera.matrixWorldInverse, scope.object.parent.matrixWorld ); // parent's modelViewMatrix
				total.premultiply( scope.scene.camera.projectionMatrix );

				origin.set( 0, 0, 0, 1 ).applyMatrix4( total );

				invTotal.copy( total ).invert();

				zoomPt.set( ndcX, ndcY, origin.z / origin.w, 1 ).applyMatrix4( invTotal );

				pt3.set( zoomPt.x / zoomPt.w, zoomPt.y / zoomPt.w, zoomPt.z / zoomPt.w );

				pt3.sub( scope.object.position );

				v3.copy( pt3 ).multiplyScalar( scaleDelta ).add( pt3.negate() );

				scope.object.scale.multiplyScalar( scaleDelta );
				scope.object.position.sub( v3 );

				scope.scale.copy( scope.object.scale );
				scope.position.copy( scope.object.position );

				return true;

			};

		}();

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

		}

		function handleMouseDownDolly( event ) {

			dollyStart.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

		}

		function handleMouseDownPan( event ) {

			panStart.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

		}

		function handleMouseMoveRotate( event ) {
			
			rotateEnd.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

			if ( rotate() ) {

				scope.dispatchEvent( _changeEvent );

			}

			rotateStart.copy( rotateEnd );

		}

		function handleMouseMoveDolly( event ) {
			
			dollyEnd.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

			const dx = dollyEnd.x - dollyStart.x;
			const dy = dollyEnd.y - dollyStart.y;

			const offset = ( Math.abs( dx ) > Math.abs( dy ) ) ? dx : dy;

			let scaleDelta;
			if ( offset > 0 ) {

				scaleDelta = 1 + 0.5 * offset;

			} else {

				scaleDelta = 1 / ( 1 - 0.5 * offset );

			}

			if ( scale( scaleDelta ) ) {

				scope.dispatchEvent( _changeEvent );

			}

			dollyStart.copy( dollyEnd );

		}

		function handleMouseMovePan( event ) {
			
			panEnd.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

			if ( pan() ) {

				scope.dispatchEvent( _changeEvent );

			}

			panStart.copy( panEnd );

		}

		function handleMouseWheelScale( event ) {

			const scaleDelta = event.deltaY > 0 ? 1 / 1.05 : 1.05;

			if ( scale( scaleDelta ) ) {

				scope.dispatchEvent( _changeEvent );

			}

		}

		function handleMouseWheelScaleToPointer( event ) {

			const scaleDelta = event.deltaY > 0 ? 1 / 1.05 : 1.05;
			
			if ( scaleToPoint( scaleDelta, ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) ) ) {

				scope.dispatchEvent( _changeEvent );

			}

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			panStart.set( 0, 0 );
			panEnd.set( 0, 0 );

			switch ( event.code ) {

				case scope.keys.UP:
					panEnd.y = scope.keyPanSpeed / ( scope.scene.height / 2.0 );
					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:
					panEnd.y = - scope.keyPanSpeed / ( scope.scene.height / 2.0 );
					needsUpdate = true;
					break;

				case scope.keys.LEFT:
					panEnd.x = - scope.keyPanSpeed / ( scope.scene.width / 2.0 );
					needsUpdate = true;
					break;

				case scope.keys.RIGHT:
					panEnd.x = scope.keyPanSpeed / ( scope.scene.width / 2.0 );
					needsUpdate = true;
					break;

			}

			let updateEvent = false;

			if ( needsUpdate ) {

				updateEvent = pan();

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

			}

			if ( updateEvent ) scope.dispatchEvent( _changeEvent );

		}

		function handleTouchStartRotate() {

			if ( pointers.length === 1 ) {

				rotateStart.set( ndcAdjustX( pointers[ 0 ].clientX ), ndcAdjustY( pointers[ 0 ].clientY ) );

			} else {

				const x = 0.5 * ( pointers[ 0 ].clientX + pointers[ 1 ].clientX );
				const y = 0.5 * ( pointers[ 0 ].clientY + pointers[ 1 ].clientY );

				rotateStart.set( ndcAdjustX( x ), ndcAdjustY( y ) );

			}

		}

		function handleTouchStartPan() {

			if ( pointers.length === 1 ) {

				panStart.set( ndcAdjustX( pointers[ 0 ].clientX ), ndcAdjustY( pointers[ 0 ].clientY ) );

			} else {

				const x = 0.5 * ( pointers[ 0 ].clientX + pointers[ 1 ].clientX );
				const y = 0.5 * ( pointers[ 0 ].clientY + pointers[ 1 ].clientY );

				panStart.set( ndcAdjustX( x ), ndcAdjustY( y ) );

			}

		}

		function handleTouchStartDolly() {

			const dx = Math.abs( pointers[ 0 ].clientX - pointers[ 1 ].clientX );
			const dy = Math.abs( pointers[ 0 ].clientY - pointers[ 1 ].clientY );

			dollyStart.set( ndcAdjustX( dx ), ndcAdjustY( dy ) );

		}

		function handleTouchStartDollyPan() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enablePan ) handleTouchStartPan();

		}

		function handleTouchStartDollyRotate() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enableRotate ) handleTouchStartRotate();

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.clientX + position.x );
				const y = 0.5 * ( event.clientY + position.y );

				rotateEnd.set( ndcAdjustX( x ), ndcAdjustY( y ) );

			}

			if ( rotate() ) {

				scope.dispatchEvent( _changeEvent );

			}

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( ndcAdjustX( event.clientX ), ndcAdjustY( event.clientY ) );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.clientX + position.x );
				const y = 0.5 * ( event.clientY + position.y );

				panEnd.set( ndcAdjustX( x ), ndcAdjustY( y ) );

			}

			if ( pan() ) {

				scope.dispatchEvent( _changeEvent );

			}

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			let dx = Math.abs( event.clientX - position.x );
			let dy = Math.abs( event.clientY - position.y );

			dollyEnd.set( ndcAdjustX( dx ), ndcAdjustY( dy ) );

			dx = dollyEnd.x - dollyStart.x;
			dy = dollyEnd.y - dollyStart.y;

			const offset = ( Math.abs( dx ) > Math.abs( dy ) ) ? dx : dy;

			let scaleDelta;
			if ( offset < 0 ) {

				scaleDelta = 1 + 0.5 * offset;

			} else {

				scaleDelta = 1 / ( 1 - 0.5 * offset );

			}

			if ( scale( scaleDelta ) ) {

				scope.dispatchEvent( _changeEvent );

			}

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchEnd();

			} else {

				onMouseUp();

			}

			removePointer( event );

			//

			if ( pointers.length === 0 ) {

				scope.domElement.releasePointerCapture( event.pointerId );

				scope.domElement.removeEventListener( 'pointermove', onPointerMove );
				scope.domElement.removeEventListener( 'pointerup', onPointerUp );

			}

		}

		function onPointerCancel( event ) {

			removePointer( event );

		}

		function onMouseDown( event ) {

			var modifiers = 0;

			modifiers += ( event.shiftKey ? 1 : 0 );
			modifiers += ( event.ctrlKey ? 2 : 0 );
			modifiers += ( event.metaKey ? 4 : 0 );

			let mouseAction = 0;

			switch ( event.button ) {

				case 0:

					mouseAction = 1;
					break;

				case 1:

					mouseAction = 2;
					break;

				case 2:

					mouseAction = 4;
					break;

			}

			for ( var i = 0, l = pointerTriggers.length; i < l; i ++ ) {

				if ( ( modifiers === pointerTriggers[ i ].modifiers ) && ( mouseAction & pointerTriggers[ i ].buttons ) ) {

					switch ( pointerTriggers[ i ].param ) {

						case 0:
						case "ROTATE":

							if ( scope.enableRotate === false ) continue;

							handleMouseDownRotate( event );

							state = STATE.ROTATE;

							scope.domElement.ownerDocument.body.style.cursor = 'move';

							break;

						case 1:
						case "SCALE":

							if ( scope.enableZoom === false ) continue;

							handleMouseDownDolly( event );

							state = STATE.DOLLY;

							scope.domElement.ownerDocument.body.style.cursor = 'ne-resize';

							break;

						case 2:
						case "TRANSLATE":

							if ( scope.enablePan === false ) continue;

							handleMouseDownPan( event );

							state = STATE.PAN;

							scope.domElement.ownerDocument.body.style.cursor = 'move';

							break;

						default:

							state = STATE.NONE;

					}

					if ( state !== STATE.NONE ) {

						scope.dispatchEvent( _startEvent );

					}

					break;

				}

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseUp( event ) {

			scope.domElement.ownerDocument.body.style.cursor = 'default';

			scope.dispatchEvent( _endEvent );

			state = STATE.NONE;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

			var modifiers = 0;

			modifiers += ( event.shiftKey ? 1 : 0 );
			modifiers += ( event.ctrlKey ? 2 : 0 );
			modifiers += ( event.metaKey ? 4 : 0 );

			for ( var i = 0, l = mouseWheelScrollActions.length; i < l; i ++ ) {

				if ( modifiers === mouseWheelScrollActions[ i ].modifiers ) {

					event.preventDefault();

					switch ( mouseWheelScrollActions[ i ].param ) {

						case 0:
						case "ZOOM":

							scope.dispatchEvent( _startEvent );

							handleMouseWheelScale( event );
							
							scope.dispatchEvent( _endEvent );

							break;

						case 1:
						case "ZOOM_AT_POINTER":
			
							scope.dispatchEvent( _startEvent );

							handleMouseWheelScaleToPointer( event );

							scope.dispatchEvent( _endEvent );

							break;

					}

					return;

				}

			}

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate();

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan();

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan();

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate();

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onTouchEnd( event ) {

			scope.dispatchEvent( _endEvent );

			state = STATE.NONE;

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ].pointerId == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.clientX, event.clientY );

		}

		function getSecondPointerPosition( event ) {

			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointer.pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		// Add key event listener by default
		scope.listenToKeyEvents( window );

	}

}

TransformInteractor.prototype.isTransformInteractor = true;

// This set of controls performs panning of a domain.
//
//    Pan - left mouse / touch: one-finger move

function PanInteractor( domElement ) {

	if ( domElement === undefined ) console.warn( 'AVS.Three.PanInteractor: The first parameter "domElement" is now mandatory.' );
	if ( domElement === document ) console.error( 'AVS.Three.PanInteractor: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

	// Dummy object until we set something
//	this.object = new Object3D();

	this.linkObjectsBottom = [];
	this.linkObjectsTop = [];
	this.linkObjectsLeft = [];
	this.linkObjectsRight = [];

	this.domElement = domElement;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new Vector3();

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = false;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = false;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.panSpeed = 1.0;
	this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.NONE, RIGHT: MOUSE.NONE };

	// Touch fingers
	this.touches = { ONE: TOUCH.PAN, TWO: TOUCH.NONE };

	// for reset
//	this.target0 = this.target.clone();
//	this.position0 = this.object.position.clone();
//	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.saveState = function () {

		scope.target0.copy( scope.target );
		scope.position0.copy( scope.object.position );
		scope.zoom0 = scope.object.zoom;

	};

	this.reset = function () {

		scope.target.copy( scope.target0 );
		scope.object.position.copy( scope.position0 );
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent( changeEvent );

		scope.update();

		state = STATE.NONE;

	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = function () {

		var obj = null;

		return function update() {

			if ( scope.object === undefined || scope.object.style === undefined ) {

				return;

			}

			// Check limits

			if ( panOffset.x > scope.object.leftLimit ) {

				panOffset.x = scope.object.leftLimit;

			} else if ( panOffset.x < scope.object.rightLimit ) {

				panOffset.x = scope.object.rightLimit;

			}

			if ( panOffset.y < scope.object.bottomLimit ) {

				panOffset.y = scope.object.bottomLimit;

			} else if ( panOffset.y > scope.object.topLimit ) {

				panOffset.y = scope.object.topLimit;

			}

			// Main object

			scope.object.panOffsetX = panOffset.x;
			scope.object.panOffsetY = panOffset.y;

			scope.object.style.left = ( scope.object.baseLeft + panOffset.x ) + 'px';
			scope.object.style.top = ( scope.object.baseTop + panOffset.y ) + 'px';

			// Bottom objects

			for ( var i = 0; i < scope.linkObjectsBottom.length; i ++ ) {

				obj = scope.linkObjectsBottom[ i ];

				obj.style.left = ( obj.baseLeft + panOffset.x ) + 'px';

			}

			// Top objects

			for ( var i = 0; i < scope.linkObjectsTop.length; i ++ ) {

				obj = scope.linkObjectsTop[ i ];

				obj.style.left = ( obj.baseLeft + panOffset.x ) + 'px';

			}

			// Left objects

			for ( var i = 0; i < scope.linkObjectsLeft.length; i ++ ) {

				obj = scope.linkObjectsLeft[ i ];

				obj.style.top = ( obj.baseTop + panOffset.y ) + 'px';

			}

			// Right objects

			for ( var i = 0; i < scope.linkObjectsRight.length; i ++ ) {

				obj = scope.linkObjectsRight[ i ];

				obj.style.top = ( obj.baseTop + panOffset.y ) + 'px';

			}

			scope.dispatchEvent( changeEvent );

		};

	}();

	this.dispose = function () {

		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );

		scope.domElement.removeEventListener( 'pointerdown', onPointerDown, false );
		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

		scope.domElement.removeEventListener( 'keydown', onKeyDown, false );

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = {
		NONE: - 1,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2,
		TOUCH_ROTATE: 3,
		TOUCH_PAN: 4,
		TOUCH_DOLLY_PAN: 5,
		TOUCH_DOLLY_ROTATE: 6
	};

	var state = STATE.NONE;

	// current rotation in spherical coordinates
	var sphericalDelta = new Spherical();

	var panOffset = new Vector3();

	var rotateStart = new Vector2();
	var rotateEnd = new Vector2();
	var rotateDelta = new Vector2();

	var panStart = new Vector2();
	var panEnd = new Vector2();
	var panDelta = new Vector2();

	var dollyStart = new Vector2();
	var dollyEnd = new Vector2();
	var dollyDelta = new Vector2();

	function getZoomScale() {

		return Math.pow( 0.95, scope.zoomSpeed );

	}

	function rotateLeft( angle ) {

		sphericalDelta.theta += angle;

	}

	function rotateUp( angle ) {

		sphericalDelta.phi += angle;

	}

	(function () {

		var v = new Vector3(1, 0, 0);

		return function panLeft( distance, objectMatrix ) {

			v.set( 1, 0, 0 );
			v.multiplyScalar( distance );

			panOffset.add( v );

		};

	})();

	(function () {

		var v = new Vector3(0, 1, 0);

		return function panUp( distance, objectMatrix ) {

			v.set( 0, 1, 0 );
			v.multiplyScalar( - distance );

			panOffset.add( v );

		};

	})();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = function () {

		new Vector3();

		return function pan( deltaX, deltaY ) {

//			var element = scope.domElement;

//			if ( scope.object.camera.isOrthographicCamera ) {

//				var changeX = ( deltaX / element.clientWidth ) * ( scope.object.camera.right - scope.object.camera.left ) / scope.object.camera.zoom;

				panOffset.x += deltaX;
/*
				if ( changeX < 0 ) {

					var xLimit = scope.object.leftLimit;

					if ( panOffset.x < xLimit ) {

						panOffset.x = xLimit;

					}

				} else if ( changeX > 0 ) {

					var xLimit = scope.object.rightLimit;

					if ( panOffset.x > xLimit ) {

						panOffset.x = xLimit;

					}

				}
*/
//				var changeY = ( deltaY / element.clientHeight ) * ( scope.object.camera.top - scope.object.camera.bottom ) / scope.object.camera.zoom;

				panOffset.y += deltaY;
/*
				if ( changeY > 0 ) {

					var yLimit = scope.object.bottomLimit;

					if ( panOffset.y < yLimit ) {

						panOffset.y = yLimit;

					}

				} else if ( changeY < 0 ) {

					var yLimit = scope.object.topLimit;

					if ( panOffset.y > yLimit ) {

						panOffset.y = yLimit;

					}

				}
*/
//			} else {

				// camera not orthographic
//				console.warn( 'WARNING: AVS.Three.PanInteractor encountered an unknown camera type - pan disabled.' );
//				scope.enablePan = false;

//			}

		};

	}();

	function dollyOut( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) ; else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: AVS.Three.PanInteractor encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	function dollyIn( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) ; else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: AVS.Three.PanInteractor encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate( event ) {

		rotateStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownDolly( event ) {

		dollyStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownPan( event ) {

		panStart.set( event.clientX, event.clientY );

	}

	function handleMouseMoveRotate( event ) {

		rotateEnd.set( event.clientX, event.clientY );

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleMouseMoveDolly( event ) {

		dollyEnd.set( event.clientX, event.clientY );

		dollyDelta.subVectors( dollyEnd, dollyStart );

		if ( dollyDelta.y > 0 ) {

			dollyOut( getZoomScale() );

		} else if ( dollyDelta.y < 0 ) {

			dollyIn( getZoomScale() );

		}

		dollyStart.copy( dollyEnd );

		scope.update();

	}

	function handleMouseMovePan( event ) {

		panEnd.set( event.clientX, event.clientY );

		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

		scope.update();

	}

	function handleMouseWheel( event ) {

		if ( event.deltaY < 0 ) {

			dollyIn( getZoomScale() );

		} else if ( event.deltaY > 0 ) {

			dollyOut( getZoomScale() );

		}

		scope.update();

	}

	function handleKeyDown( event ) {

		var needsUpdate = false;

		switch ( event.keyCode ) {

			case scope.keys.UP:
				pan( 0, scope.keyPanSpeed );
				needsUpdate = true;
				break;

			case scope.keys.BOTTOM:
				pan( 0, - scope.keyPanSpeed );
				needsUpdate = true;
				break;

			case scope.keys.LEFT:
				pan( scope.keyPanSpeed, 0 );
				needsUpdate = true;
				break;

			case scope.keys.RIGHT:
				pan( - scope.keyPanSpeed, 0 );
				needsUpdate = true;
				break;

		}

		if ( needsUpdate ) {

			// prevent the browser from scrolling on cursor keys
			event.preventDefault();

			scope.update();

		}


	}

	function handleTouchStartRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateStart.set( x, y );

		}

	}

	function handleTouchStartPan( event ) {

		if ( event.touches.length == 1 ) {

			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panStart.set( x, y );

		}

	}

	function handleTouchStartDolly( event ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

	function handleTouchStartDollyPan( event ) {

		if ( scope.enableZoom ) handleTouchStartDolly( event );

		if ( scope.enablePan ) handleTouchStartPan( event );

	}

	function handleTouchStartDollyRotate( event ) {

		if ( scope.enableZoom ) handleTouchStartDolly( event );

		if ( scope.enableRotate ) handleTouchStartRotate( event );

	}

	function handleTouchMoveRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateEnd.set( x, y );

		}

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

	}

	function handleTouchMovePan( event ) {

		if ( event.touches.length == 1 ) {

			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panEnd.set( x, y );

		}

		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

	}

	function handleTouchMoveDolly( event ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

	function handleTouchMoveDollyPan( event ) {

		if ( scope.enableZoom ) handleTouchMoveDolly( event );

		if ( scope.enablePan ) handleTouchMovePan( event );

	}

	function handleTouchMoveDollyRotate( event ) {

		if ( scope.enableZoom ) handleTouchMoveDolly( event );

		if ( scope.enableRotate ) handleTouchMoveRotate( event );

	}

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onPointerDown( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseDown( event );
				break;

			// TODO touch

		}

	}

	function onPointerMove( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseMove( event );
				break;

			// TODO touch

		}

	}

	function onPointerUp( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseUp();
				break;

			// TODO touch

		}

	}

	function onMouseDown( event ) {

		// Prevent the browser from scrolling.
		event.preventDefault();

		// Manually set the focus since calling preventDefault above
		// prevents the browser from setting it automatically.

		scope.domElement.focus ? scope.domElement.focus() : window.focus();

		var mouseAction;

		switch ( event.button ) {

			case 0:

				mouseAction = scope.mouseButtons.LEFT;
				break;

			case 1:

				mouseAction = scope.mouseButtons.MIDDLE;
				break;

			case 2:

				mouseAction = scope.mouseButtons.RIGHT;
				break;

			default:

				mouseAction = - 1;

		}

		switch ( mouseAction ) {

			case MOUSE.DOLLY:

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

				break;

			case MOUSE.ROTATE:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( scope.enablePan === false ) return;

					handleMouseDownPan( event );

					state = STATE.PAN;

				} else {

					if ( scope.enableRotate === false ) return;

					handleMouseDownRotate( event );

					state = STATE.ROTATE;

				}

				break;

			case MOUSE.PAN:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( scope.enableRotate === false ) return;

					handleMouseDownRotate( event );

					state = STATE.ROTATE;

				} else {

					if ( scope.enablePan === false ) return;

					handleMouseDownPan( event );

					state = STATE.PAN;

					scope.domElement.ownerDocument.body.style.cursor = 'move';

				}

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove, false );
			scope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp, false );

			scope.dispatchEvent( startEvent );

		}

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( state ) {

			case STATE.ROTATE:

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

				break;

			case STATE.DOLLY:

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

				break;

			case STATE.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

				break;

		}

	}

	function onMouseUp( event ) {

		if ( scope.enabled === false ) return;

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );

		scope.domElement.ownerDocument.body.style.cursor = 'default';

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onMouseWheel( event ) {

		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

		event.preventDefault();
		event.stopPropagation();

		scope.dispatchEvent( startEvent );

		handleMouseWheel( event );

		scope.dispatchEvent( endEvent );

	}

	function onKeyDown( event ) {

		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

		handleKeyDown( event );

	}

	function onTouchStart( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling

		switch ( event.touches.length ) {

			case 1:

				switch ( scope.touches.ONE ) {

					case TOUCH.ROTATE:

						if ( scope.enableRotate === false ) return;

						handleTouchStartRotate( event );

						state = STATE.TOUCH_ROTATE;

						break;

					case TOUCH.PAN:

						if ( scope.enablePan === false ) return;

						handleTouchStartPan( event );

						state = STATE.TOUCH_PAN;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			case 2:

				switch ( scope.touches.TWO ) {

					case TOUCH.DOLLY_PAN:

						if ( scope.enableZoom === false && scope.enablePan === false ) return;

						handleTouchStartDollyPan( event );

						state = STATE.TOUCH_DOLLY_PAN;

						break;

					case TOUCH.DOLLY_ROTATE:

						if ( scope.enableZoom === false && scope.enableRotate === false ) return;

						handleTouchStartDollyRotate( event );

						state = STATE.TOUCH_DOLLY_ROTATE;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.dispatchEvent( startEvent );

		}

	}

	function onTouchMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling
		event.stopPropagation();

		switch ( state ) {

			case STATE.TOUCH_ROTATE:

				if ( scope.enableRotate === false ) return;

				handleTouchMoveRotate( event );

				scope.update();

				break;

			case STATE.TOUCH_PAN:

				if ( scope.enablePan === false ) return;

				handleTouchMovePan( event );

				scope.update();

				break;

			case STATE.TOUCH_DOLLY_PAN:

				if ( scope.enableZoom === false && scope.enablePan === false ) return;

				handleTouchMoveDollyPan( event );

				scope.update();

				break;

			case STATE.TOUCH_DOLLY_ROTATE:

				if ( scope.enableZoom === false && scope.enableRotate === false ) return;

				handleTouchMoveDollyRotate( event );

				scope.update();

				break;

			default:

				state = STATE.NONE;

		}

	}

	function onTouchEnd( event ) {

		if ( scope.enabled === false ) return;

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onContextMenu( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

	}

	//

	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

	scope.domElement.addEventListener( 'pointerdown', onPointerDown, false );
	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

	scope.domElement.addEventListener( 'keydown', onKeyDown, false );

	// make sure element can receive keys.

	if ( scope.domElement.tabIndex === - 1 ) {

		scope.domElement.tabIndex = 0;

	}

	// force an update at start

	this.update();

}
PanInteractor.prototype = Object.create( EventDispatcher.prototype );
PanInteractor.prototype.constructor = PanInteractor;

PanInteractor.prototype.isPanInteractor = true;

// This set of controls scales an object by drawing a rectangle.

function ZoomRectangleInteractor( domElement ) {

	if ( domElement === undefined ) console.warn( 'AVS.Three.ZoomRectangleInteractor: The first parameter "domElement" is now mandatory.' );
	if ( domElement === document ) console.error( 'AVS.Three.ZoomRectangleInteractor: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

	this.domElement = domElement;

	// Empty object, scene until we set something
	this.object = new Object3D();
	this.scene = null;

	this.billboardScaleFactor = 1;

	// Set to false to disable this control
	this.enabled = true;

	// for reset
	this.scale0 = this.object.scale.clone();
	this.position0 = this.object.position.clone();

	//
	// public methods
	//
		
	this.setObjectScene = function( object, scene, pixelRatio ) {

		scope.object = object;
		scope.scene = scene;

		scope.pixelRatio = pixelRatio !== undefined ? pixelRatio : window.devicePixelRatio;

		scope.scale0.copy( scope.object.scale );
		scope.position0.copy( scope.object.position );

		scope.billboardScaleFactor = 1;

		if ( object.internalData.zoomRectangleTriggers ) {

			pointerTriggers = JSON.parse( object.internalData.zoomRectangleTriggers );

		}

		zoomInMaxLimit = object.internalData.zoomInMaxLimit;
		zoomOutMaxLimit = object.internalData.zoomOutMaxLimit;

		if ( object.internalData.zoomRectangleColor !== undefined ) {

			lineColor = "#" + object.internalData.zoomRectangleColor.toString( 16 ).padStart( 6, '0' );

		}

		if ( object.internalData.zoomRectangleWidth ) {

			lineWidth = object.internalData.zoomRectangleWidth;

		}

		switch ( object.internalData.zoomRectanglePattern ) {

			case 0: // SOLID

				linePattern = [];

				break;

			case 1: // DASH

				linePattern = [ 4, 4 ];

				break;

			case 2: // DOT

				linePattern = [ 1, 3 ];

				break;

			case 3: // DASH_DOT

				linePattern = [ 5, 1, 1, 1 ];

				break;

		}

		var rectCanvas = document.createElement('canvas');
		rectCanvas.style.position = 'absolute';
		rectCanvas.style.width = '100%';
		rectCanvas.style.height = '100%';
		rectCanvas.id = scope.scene.name + "RectCanvas";

		rectCanvas.width = scope.scene.viewportPixelWidth;
		rectCanvas.height = scope.scene.viewportPixelHeight;

		scope.scene.viewportDiv.appendChild( rectCanvas );
		scope.scene.rectCanvas = rectCanvas;
		scope.scene.rectCtx = rectCanvas.getContext('2d');

	};

	this.reset = function () {

		scope.object.scale.copy( scope.scale0 );
		scope.object.position.copy( scope.position0 );

		scope.billboardScaleFactor = 1;

		scope.dispatchEvent( changeEvent );

		state = STATE.NONE;

	};

	this.dispose = function () {

		scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

		scope.domElement.removeEventListener( 'pointerdown', onPointerDown );

		scope.domElement.removeEventListener( 'touchstart', onTouchStart );
		scope.domElement.removeEventListener( 'touchend', onTouchEnd );
		scope.domElement.removeEventListener( 'touchmove', onTouchMove );

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = {
		NONE: - 1,
		ZOOM_IN: 0,
		ZOOM_OUT: 1
	};

	var state = STATE.NONE;

	var pointerTriggers = [
		{ "buttons": 1, "modifiers": 0, "param": "ZOOM_IN" },
		{ "buttons": 1, "modifiers": 1, "param": "ZOOM_OUT" }
	];

	var zoomInMaxLimit;
	var zoomOutMaxLimit;

	var mouseState = 0;
	var DISTANCE = 25;

	var lineColor = "#ff0000";
	var lineWidth = 1;
	var linePattern = [ 4, 4 ];

	var rectStart = new Vector2();
	var rectEnd = new Vector2();

	function clampClientX( event ) {

		return Math.max( 0, Math.min( event.clientX - scope.scene.viewportDiv.getBoundingClientRect().left, scope.scene.viewportWidth ) );

	}

	function clampClientY( event ) {

		return Math.max( 0, Math.min( event.clientY - scope.scene.viewportDiv.getBoundingClientRect().top, scope.scene.viewportHeight ) );

	}

	var zoom = function() {

		var total = new Matrix4();
		var invTotal = new Matrix4();
		var origin = new Vector4();
		var zoomPt = new Vector4();
		var pt3 = new Vector3();
		var center = new Vector4();
		var center3 = new Vector3();

		return function( left, right, top, bottom ) {

			var scaleX = scope.scene.viewportPixelWidth / ( right - left );
			var scaleY = scope.scene.viewportPixelHeight / ( bottom - top );

			total.multiplyMatrices( scope.scene.camera.matrixWorldInverse, scope.object.parent.matrixWorld ); // parent's modelViewMatrix
			total.premultiply( scope.scene.camera.projectionMatrix );

			origin.set( 0, 0, 0, 1 ).applyMatrix4( total );

			invTotal.copy( total ).invert();

			var scaleDelta = 1;

			if ( state === STATE.ZOOM_IN ) {

				scaleDelta = ( scaleY < scaleX ) ? scaleY : scaleX;

				if ( zoomInMaxLimit !== undefined ) {

					var currentScale = Math.max( Math.max( scope.object.scale.x, scope.object.scale.y ), scope.object.scale.z );
					
					var newScale = scaleDelta * currentScale;

					if ( newScale > zoomInMaxLimit ) {

						scaleDelta = zoomInMaxLimit / currentScale;

					}

				}

				// Center of rectangle in NDC coordinates
				var ndcX = ( ( left + right ) / scope.scene.viewportPixelWidth ) - 1;
				var ndcY = 1 - ( ( top + bottom ) / scope.scene.viewportPixelHeight );

				zoomPt.set( ndcX, ndcY, origin.z / origin.w, 1 ).applyMatrix4( invTotal );

				pt3.set( zoomPt.x / zoomPt.w, zoomPt.y / zoomPt.w, zoomPt.z / zoomPt.w );

				center.set( 0, 0, origin.z / origin.w, 1 ).applyMatrix4( invTotal );

				center3.set( center.x / center.w, center.y / center.w, center.z / center.w );

				pt3.sub( scope.object.position );
				center3.sub( scope.object.position );

				pt3.multiplyScalar( scaleDelta ).sub( center3 );

				scope.object.position.sub( pt3 );

			} else if ( state === STATE.ZOOM_OUT ) {

				scaleDelta = ( scaleY > scaleX ) ? 1 / scaleY : 1 / scaleX;

				if ( zoomOutMaxLimit !== undefined ) {

					var currentScale = Math.max( Math.max( scope.object.scale.x, scope.object.scale.y ), scope.object.scale.z );
					
					var newScale = scaleDelta * currentScale;

					if ( newScale < 1 / zoomOutMaxLimit ) {

						scaleDelta = 1 / zoomOutMaxLimit / currentScale;

					}

				}

				// Center of NDC is 0,0
				zoomPt.set( 0, 0, origin.z / origin.w, 1 ).applyMatrix4( invTotal );

				pt3.set( zoomPt.x / zoomPt.w, zoomPt.y / zoomPt.w, zoomPt.z / zoomPt.w );

				pt3.sub( scope.object.position );

				center3.copy( pt3 );

				pt3.multiplyScalar( scaleDelta ).sub( center3 );

				scope.object.position.sub( pt3 );

			}

			scope.object.scale.multiplyScalar( scaleDelta );

			scope.billboardScaleFactor *= scaleDelta;

			return true;

		}

	}();

	//
	// event callbacks - update the object state
	//

	function handleMouseDown( event ) {

		rectStart.set( clampClientX( event ), clampClientY( event ) );

		mouseState = 1;

	}

	function handleMouseMove( event ) {

		rectEnd.set( clampClientX( event ), clampClientY( event ) );

		scope.scene.rectCtx.clearRect( 0, 0, scope.scene.viewportPixelWidth, scope.scene.viewportPixelHeight );
		
		if ( mouseState == 1 ) {

			var distanceX = Math.abs( rectStart.x - rectEnd.x );
			var distanceY = Math.abs( rectStart.y - rectEnd.y );
			var distance = distanceX * distanceX + distanceY * distanceY;

			if ( distance < DISTANCE ) {

				return;

			}

			mouseState = 2;

		}

		var left = Math.min( rectStart.x, rectEnd.x ) * scope.pixelRatio;
		var right = Math.max( rectStart.x, rectEnd.x ) * scope.pixelRatio;
		var top = Math.min( rectStart.y, rectEnd.y ) * scope.pixelRatio;
		var bottom = Math.max( rectStart.y, rectEnd.y ) * scope.pixelRatio;

		scope.scene.rectCtx.setLineDash( linePattern );
		scope.scene.rectCtx.strokeStyle = lineColor;
		scope.scene.rectCtx.lineWidth = lineWidth;

		scope.scene.rectCtx.strokeRect( left, top, right - left, bottom - top );

	}

	function handleMouseUp( event ) {

		if ( mouseState < 2 ) return;

		rectEnd.set( clampClientX( event ), clampClientY( event ) );

		scope.scene.rectCtx.clearRect( 0, 0, scope.scene.viewportPixelWidth, scope.scene.viewportPixelHeight );
		
		var left = Math.min( rectStart.x, rectEnd.x ) * scope.pixelRatio;
		var right = Math.max( rectStart.x, rectEnd.x ) * scope.pixelRatio;
		var top = Math.min( rectStart.y, rectEnd.y ) * scope.pixelRatio;
		var bottom = Math.max( rectStart.y, rectEnd.y ) * scope.pixelRatio;

		if ( zoom( left, right, top, bottom ) ) {

			scope.dispatchEvent( changeEvent );

		}

		mouseState = 0;

	}

	function handleTouchStartRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateStart.set( x, y );

		}

	}

	function handleTouchStartPan( event ) {

		if ( event.touches.length == 1 ) {

			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panStart.set( x, y );

		}

	}

	function handleTouchStartScale( event ) {

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		scaleStart.set( 0, distance );

	}

	function handleTouchStartScalePan( event ) {

		if ( scope.enableScale ) handleTouchStartScale( event );

		if ( scope.enablePan ) handleTouchStartPan( event );

	}

	function handleTouchStartScaleRotate( event ) {

		if ( scope.enableScale ) handleTouchStartScale( event );

		if ( scope.enableRotate ) handleTouchStartRotate( event );

	}

	function handleTouchMoveRotate( event ) {

		if ( event.touches.length == 1 ) {

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			rotateEnd.set( x, y );

		}

		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

		var element = scope.domElement;

		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

		rotateStart.copy( rotateEnd );

	}

	function handleTouchMovePan( event ) {

		if ( event.touches.length == 1 ) {

			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		} else {

			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			panEnd.set( x, y );

		}

		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

	}

	function handleTouchMoveScale( event ) {

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		scaleEnd.set( 0, distance );

		scaleDelta.set( 0, Math.pow( scaleEnd.y / scaleStart.y, scope.zoomSpeed ) );

		scaleOut( scaleDelta.y );

		scaleStart.copy( scaleEnd );

	}

	function handleTouchMoveScalePan( event ) {

		if ( scope.enableScale ) handleTouchMoveScale( event );

		if ( scope.enablePan ) handleTouchMovePan( event );

	}

	function handleTouchMoveScaleRotate( event ) {

		if ( scope.enableScale ) handleTouchMoveScale( event );

		if ( scope.enableRotate ) handleTouchMoveRotate( event );

	}

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onPointerDown( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseDown( event );
				break;

			// TODO touch

		}

	}

	function onPointerMove( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseMove( event );
				break;

			// TODO touch

		}

	}

	function onPointerUp( event ) {

		switch ( event.pointerType ) {

			case 'mouse':
			case 'pen':
				onMouseUp( event );
				break;

			// TODO touch

		}

	}

	function onMouseDown( event ) {

		// Prevent the browser from scrolling.
		event.preventDefault();

		// Manually set the focus since calling preventDefault above
		// prevents the browser from setting it automatically.

		scope.domElement.focus ? scope.domElement.focus() : window.focus();

		var modifiers = 0;

		modifiers += ( event.shiftKey ? 1 : 0 );
		modifiers += ( event.ctrlKey ? 2 : 0 );
		modifiers += ( event.metaKey ? 4 : 0 );

		var mouseButton = 0;

		switch ( event.button ) {

			case 0: // LEFT

				mouseButton = 1;
				break;

			case 1: // MIDDLE

				mouseButton = 2;
				break;

			case 2: // RIGHT

				mouseButton = 4;
				break;

		}

		for ( var i = 0, l = pointerTriggers.length; i < l; i ++ ) {

			if ( ( modifiers === pointerTriggers[ i ].modifiers ) && ( mouseButton & pointerTriggers[ i ].buttons ) ) {

				switch ( pointerTriggers[ i ].param ) {

					case 1:
					case "ZOOM_IN":

						handleMouseDown( event );

						state = STATE.ZOOM_IN;

						scope.domElement.ownerDocument.body.style.cursor = 'zoom-in';

						break;

					case 2:
					case "ZOOM_OUT":

						handleMouseDown( event );

						state = STATE.ZOOM_OUT;

						scope.domElement.ownerDocument.body.style.cursor = 'zoom-out';

						break;

					default:

						state = STATE.NONE;

				}

				if ( state !== STATE.NONE ) {

					scope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove );
					scope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp );

					scope.dispatchEvent( startEvent );

				}

				return;

			}

		}

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		handleMouseMove( event );

	}

	function onMouseUp( event ) {

		scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );
		scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );

		if ( scope.enabled === false ) return;

		handleMouseUp( event );

		scope.domElement.ownerDocument.body.style.cursor = 'default';

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onTouchStart( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling

		switch ( event.touches.length ) {

			case 1:

				switch ( scope.touches.ONE ) {

					case TOUCH.ROTATE:

						if ( scope.enableRotate === false ) return;

						handleTouchStartRotate( event );

						state = STATE.TOUCH_ROTATE;

						break;

					case TOUCH.PAN:

						if ( scope.enablePan === false ) return;

						handleTouchStartPan( event );

						state = STATE.TOUCH_PAN;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			case 2:

				switch ( scope.touches.TWO ) {

					case TOUCH.SCALE_PAN:

						if ( scope.enableScale === false && scope.enablePan === false ) return;

						handleTouchStartScalePan( event );

						state = STATE.TOUCH_SCALE_PAN;

						break;

					case TOUCH.SCALE_ROTATE:

						if ( scope.enableScale === false && scope.enableRotate === false ) return;

						handleTouchStartScaleRotate( event );

						state = STATE.TOUCH_SCALE_ROTATE;

						break;

					default:

						state = STATE.NONE;

				}

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.dispatchEvent( startEvent );

		}

	}

	function onTouchMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault(); // prevent scrolling
		event.stopPropagation();

		switch ( state ) {

			case STATE.TOUCH_ROTATE:

				if ( scope.enableRotate === false ) return;

				handleTouchMoveRotate( event );

				scope.update();

				break;

			case STATE.TOUCH_PAN:

				if ( scope.enablePan === false ) return;

				handleTouchMovePan( event );

				scope.update();

				break;

			case STATE.TOUCH_SCALE_PAN:

				if ( scope.enableScale === false && scope.enablePan === false ) return;

				handleTouchMoveScalePan( event );

				scope.update();

				break;

			case STATE.TOUCH_SCALE_ROTATE:

				if ( scope.enableScale === false && scope.enableRotate === false ) return;

				handleTouchMoveScaleRotate( event );

				scope.update();

				break;

			default:

				state = STATE.NONE;

		}

	}

	function onTouchEnd( event ) {

		if ( scope.enabled === false ) return;

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onContextMenu( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

	}

	//

	scope.domElement.addEventListener( 'contextmenu', onContextMenu );

	scope.domElement.addEventListener( 'pointerdown', onPointerDown );

	scope.domElement.addEventListener( 'touchstart', onTouchStart );
	scope.domElement.addEventListener( 'touchend', onTouchEnd );
	scope.domElement.addEventListener( 'touchmove', onTouchMove );

}
ZoomRectangleInteractor.prototype = Object.create( EventDispatcher.prototype );
ZoomRectangleInteractor.prototype.constructor = ZoomRectangleInteractor;

ZoomRectangleInteractor.prototype.isZoomRectangleInteractor = true;

export { CellTypeEnum, DEFAULT_VIEWER_HEIGHT, DEFAULT_VIEWER_WIDTH, PanInteractor, PickDepthEnum, PickLevelEnum, PickTypeEnum, RAYCASTER_LINE_PRECISION, REVISION, TransformInteractor, Viewer, ZoomRectangleInteractor };
