<!-- 
avs-viewer.html
Copyright 2018 Advanced Visual Systems Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

This product includes software developed at
Advanced Visual Systems Inc. (http://www.avs.com)
-->

<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">

<dom-module id="avs-viewer">

  <template>

    <style>
      #viewerDiv {
        width: 100%;
        height: 100%;
        position: relative;
      }   
      #sceneImage {
        width:100%; height:100%; 
        position:absolute; top:0px; left:0px;
      }   
      #rectCanvas {
        width:100%; height:100%; 
        overflow: hidden;
        position:absolute; top:0px; left:0px;
      }   
    </style>

    <iron-ajax id="getScene"
      url=[[sceneUrl]]
      handle-as="text"
      method="post"
      content-type="application/json"
      on-response="handleResponse"
      >
    </iron-ajax>

    <div on-click="handleClick" on-mousedown="handleOnMouseDown" on-mousemove="handleOnMouseMove" on-mouseup="handleOnMouseUp" id="viewerDiv">
    </div>
    
  </template>

  <script src="three.min.js"></script>
  <script src="avsthree.min.js"></script>

  <script>
    class AvsViewer extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior, Polymer.GestureEventListeners], Polymer.Element) {
      static get is() {
        return 'avs-viewer';
      }
      
      static get properties() {
        return {

          // Core properties
          width: {
            type: Number,
          },
          height: {
            type: Number,
          },
 
          // Scene properties
          sceneProperties: {
            type: Object
          },
          viewerProperties: {
            type: Object
          },
          hoverProperties: {
            type: Object        
          },
          pickProperties: {
            type: Object
          },
          streamProperties: {
            type: Object
          },
          transformProperties: {
            type: Object
          },
          defaultLineProperties: {
            type: Object
          },
          defaultTextProperties: {
            type: Object
          },

          // Resize threshold (percent) to determine when the update is performed on the client or the server
          resizeThreshold: {
            type: Object,
			      value: 10
          },

          // Internal variables
          initialized: {
            type: Boolean
          },
          viewer: {
            type: Object
          },  
          drag: {
            type: Boolean,
            value: false
          },
          rect: {
            type: Object
          },
          rectCtx: {
            type: Object
          },   
        }
      }
      
      constructor() {
        super();
      }
        
	    rectangleStyle() {
	        // default line style and color
	        this.rectCtx.setLineDash([3]);
	        this.rectCtx.strokeStyle="#ff0000";
	    }

      drawRect() {
	        this.rectangleStyle();
	        this.rectCtx.strokeRect(this.rect.startX, this.rect.startY, this.rect.w, this.rect.h);
      }
      
      buildChartRequest() {
        var scope = this;

        // Scene properties 
        if (this.sceneProperties == undefined) {
          this.sceneProperties = {};
        }
        var request = Object.assign(this.sceneProperties, {width:this.width, height:this.height});

        // Viewer Properties
        if (this.viewerProperties == undefined) {
          this.viewerProperties = {};
        }
        request = Object.assign(request, {"viewerProperties":this.viewerProperties});

        // Background color
        if ( this.viewerProperties.backgroundColor == undefined) {
          var backgroundColor = window.getComputedStyle(this, null).getPropertyValue("background-color");
          request.viewerProperties = Object.assign(request.viewerProperties, {"backgroundColor":backgroundColor} );
        }

       // Text properties
        if (this.defaultTextProperties == undefined) {
          this.defaultTextProperties = {};
        }
        request = Object.assign(request, {"defaultTextProperties":this.defaultTextProperties});

        if (this.defaultTextProperties.color == undefined) {
          var textColor = window.getComputedStyle(this, null).getPropertyValue("color");
          request.defaultTextProperties = Object.assign(request.defaultTextProperties, {"color":textColor});
        }

        if (this.defaultTextProperties.fontFamily == undefined) {
          var fontFamily = window.getComputedStyle(this, null).getPropertyValue("font-family");
          fontFamily = fontFamily.replace('"', '');
          request.defaultTextProperties = Object.assign(request.defaultTextProperties, {"fontFamily":fontFamily});
        }

        // Line Properties
        if (this.defaultLineProperties != undefined) {
          request = Object.assign(request, {"defaultLineProperties":this.defaultLineProperties});
        }

        if (this.streamProperties != undefined) {
          this.streamProperties.chunkId = undefined;
          this.streamProperties.streamUpdate = function( count ) {
             console.log("Stream count = " + count);
             scope.viewer.render();
          }
          request = Object.assign(request, {"streamProperties":this.streamProperties});
        }

        return request;
      }
                
      onResize() {
        var boundingRect = this.$.viewerDiv.getBoundingClientRect();
        if (boundingRect.width < this.lowResizeWidth ||
            boundingRect.width > this.highResizeWidth ||
            boundingRect.height < this.lowResizeHeight ||
            boundingRect.height > this.highResizeHeight) {

            this.updateViewer();
        }
        else {
            this.updateViewerClient();
        }
      }
        
      // This still needs some work...    
      updateSize() {          
        var boundingRect = this.$.viewerDiv.getBoundingClientRect();
        this.width = boundingRect.width;
        if (this.width == 0) {
            this.width = 200;  // default
        }
        
        if (this.height == 0 || this.height == undefined) {
            var height = boundingRect.height;
          
            if (height > 0) {
                this.height = height;
            }
            else {
                this.height = 200;  // default
            }
        }
        if (this.viewerProperties.renderer !== 'THREEJS' && this.pickProperties != undefined && this.pickProperties.type === 'RECTANGLE') {
          this.$$("#rectCanvas").width = this.width;
          this.$$("#rectCanvas").height = this.height;
        }

        this.lowResizeWidth = (100 - this.resizeThreshold) / 100 * this.width;
        this.highResizeWidth = (100 + this.resizeThreshold) / 100 * this.width;
        this.lowResizeHeight = (100 - this.resizeThreshold) / 100 * this.height;
        this.highResizeHeight = (100 + this.resizeThreshold) / 100 * this.height;
      } 

      updateViewer() {
        this.updateStyles();
		this.updateSize();
        if (this.viewerProperties.renderer === 'THREEJS') {
          this.viewer.setSize(this.width, this.height);
          var scope = this;
          var chartRequest = this.buildChartRequest();
          if ( this.viewerProperties.backgroundColor != undefined) {
            this.viewer.setBackgroundColor(this.viewerProperties.backgroundColor);
          }
          this.viewer.loadGeometryAsUrl({
              url: this.sceneProperties.url, 
              success: function() {
                  scope.viewer.render();
              },	
              jsonRequest: chartRequest
          });
        }
        else {
          this.$.getScene.body= this.buildChartRequest();
          this.$.getScene.url = this.sceneProperties.url;
          this.$.getScene.generateRequest();
        }
      }

      updateViewerClient() {
        if (this.viewerProperties.renderer === 'THREEJS') {
          var boundingRect = this.$.viewerDiv.getBoundingClientRect();
          this.viewer.setSize(boundingRect.width, boundingRect.height);
          this.viewer.render();
        }
      }
       
      handleResponse(obj) {
        if (this.viewerProperties.renderer === 'IMAGE') {
          var responseJSON = null;
          try {
            responseJSON = JSON.parse(obj.detail.response);
          } catch (_) {
            console.warn('Failed to parse JSON requested from ' + this.sceneProperties.url);
            return;
          }

          if (responseJSON == undefined || responseJSON == null) {
            console.log("Null JSON response");
            return;
          }

          this.$$("#sceneImage").src = responseJSON.imageurl;
          if (responseJSON.imagemap != undefined) {
//            this.$$("#sceneImageMap").innerHTML = decodeURIComponent(responseJSON.imagemap.replace(/\+/g, '%20'));
          }
          if (responseJSON.selectionInfo != undefined) {
            console.log("selection info = " + responseJSON.selectionInfo);
          }
        }
        else if (this.viewerProperties.renderer === 'SVG') {
          this.$.viewerDiv.innerHTML = obj.detail.response;
        }
      }

      handleOnMouseDown(event) {
        if (this.viewerProperties.renderer != 'THREEJS') {
          if (this.pickProperties != undefined && this.pickProperties.type === 'RECTANGLE' && this.pickProperties.active) {
	            this.rect.startX = event.pageX - this.$.viewerDiv.offsetLeft;
	            this.rect.startY = event.pageY - this.$.viewerDiv.offsetTop;
	            this.rect.startEvent = event;
	            this.drag = true;
          }
        }
      }

      handleOnMouseMove(event) {
        if (this.viewerProperties.renderer != 'THREEJS') {
          if (this.drag && this.pickProperties != undefined && this.pickProperties.type === 'RECTANGLE' && this.pickProperties.active) {
            this.rect.w = (event.pageX - this.$.viewerDiv.offsetLeft) - this.rect.startX;
            this.rect.h = (event.pageY - this.$.viewerDiv.offsetTop) - this.rect.startY ;
            this.rectCtx.clearRect(0,0,this.$$("#rectCanvas").width,this.$$("#rectCanvas").height);
            this.drawRect();
          }
        }
      }

      handleOnMouseUp(event) {
        if (this.viewerProperties.renderer != 'THREEJS') {
          if (this.pickProperties != undefined && this.pickProperties.type === 'RECTANGLE' && this.pickProperties.active) {
	            this.rect.finishX = event.pageX - this.$.viewerDiv.offsetLeft;
	            this.rect.finishY = event.pageY - this.$.viewerDiv.offsetTop;
	            this.drag = false;
	            this.rectCtx.clearRect(0,0,this.$$("#rectCanvas").width,this.$$("#rectCanvas").height);
 
              this.$.getScene.body= this.buildChartRequest();
              this.pickProperties.mouseX=[event.offsetX - this.rect.w, event.offsetX];
              this.pickProperties.mouseY=[event.offsetY - this.rect.h, event.offsetY];
              console.log("mouse x1 = " + this.pickProperties.mouseX[0] + ", " + this.pickProperties.mouseX[1]);
              console.log("mouse y1 = " + this.pickProperties.mouseY[0] + ", " + this.pickProperties.mouseY[1]);
              this.$.getScene.body = Object.assign(this.$.getScene.body, {"pickProperties":this.pickProperties});
              this.$.getScene.url = this.sceneProperties.url;
              this.$.getScene.generateRequest();
          }
          else if (this.pickProperties !== undefined) {
              this.$.getScene.body= this.buildChartRequest();
              this.pickProperties.mouseX=[event.offsetX];
              this.pickProperties.mouseY=[event.offsetY];
              this.$.getScene.body = Object.assign(this.$.getScene.body, {"pickProperties":this.pickProperties});
              this.$.getScene.url = this.sceneProperties.url;
              this.$.getScene.generateRequest();

              var selectedObject = {"pickInfo":"went to server to get new scene"};
              this.dispatchEvent(new CustomEvent('onPick', selectedObject));        
          }
        }
      }

      handleClick(event) {
        // if (this.pickProperties == undefined) return;
        // this.$.getScene.body= this.buildChartRequest();
        // this.pickProperties.mouseX=[event.offsetX];
        // this.pickProperties.mouseY=[event.offsetY];
        // this.$.getScene.body = Object.assign(this.$.getScene.body, {"pickProperties":this.pickProperties});
        // this.$.getScene.url = this.sceneProperties.url;
        // this.$.getScene.generateRequest();
        // var selectedObject = {"pickInfo":"went to server to get new scene"};
        // this.dispatchEvent(new CustomEvent('onPick', selectedObject));        
      }

      getPickDepth( strValue ) {
        if (strValue == "ALL") {
          return AVS.Three.PickDepthEnum.All;
        }
        else {
          return AVS.Three.PickDepthEnum.Closest;
        } 
      }

      getPickLevel( strValue) {
        if (strValue == "CELL_SET") {
          return AVS.Three.PickLevelEnum.CellSet;
        }
        else if (strValue == "SCENE_NODE") {
          return AVS.Three.PickLevelEnum.SceneNode;
        }
        else {
          return AVS.Three.PickLevelEnum.Cell;
        }
      }

      connectedCallback() {
        super.connectedCallback();
 
        // Hack to make sure all CSS and layout has been processed 
        Polymer.RenderStatus.afterNextRender(this, function() {
          this.updateViewer();

          if (this.initialized != true) {  
            this.addEventListener('iron-resize', this.onResize);
            this.initialized = true;
          }
        }); 


        if (this.viewerProperties.renderer === 'THREEJS') {
          if (this.viewer != undefined) {  
              this.$.viewerDiv.removeChild( this.viewer.getCanvas() );
          }
            
          this.viewer = new AVS.Three.Viewer();
          this.$.viewerDiv.appendChild( this.viewer.getCanvas() );

          var renderer = new THREE.WebGLRenderer( {alpha: true} );
          this.viewer.setWebGLRenderer( renderer );
  
          // Setup transform interactor
          if (this.transformProperties != undefined && this.transformProperties.sceneNode != undefined) {
            var ti = new AVS.Three.TransformInteractor( this.viewer.container );
            ti.setSceneNodeByName( this.transformProperties.sceneNode );  // the name of the workbox component set on the server
            this.viewer.addInteractor( ti );  
          }

          // Setup hover interactor
          if (this.hoverProperties != undefined) {
            
            this.hoverProperties.depth = this.getPickDepth(this.hoverProperties.depth);
            this.hoverProperties.level = this.getPickLevel(this.hoverProperties.level);

            var scope = this;
            this.hoverProperties.onHover = function( selectedObject ) {
              if (selectedObject != undefined) {
                scope.dispatchEvent(new CustomEvent('onHover', selectedObject));        
              }
            }

            this.viewer.addHoverListener(this.hoverProperties);
          }

          // Setup pick interactor
          if (this.pickProperties != undefined) {
            
            this.pickProperties.depth = this.getPickDepth(this.pickProperties.depth);
            this.pickProperties.level = this.getPickLevel(this.pickProperties.level);

            var scope = this;
            this.pickProperties.onPick = function( selectedObject ) {
              if (selectedObject != undefined) {
                scope.dispatchEvent(new CustomEvent('onPick', selectedObject));        
              }
            }

            if (this.pickProperties.type === 'RECTANGLE') {
              this.viewer.addRectanglePickListener(this.pickProperties);
            }
            else {
              this.viewer.addPickListener(this.pickProperties);
            }
          }

        }

        else if (this.viewerProperties.renderer === 'IMAGE') {
          var imageElem = document.createElement("img");
          imageElem.setAttribute("id", "sceneImage");
          imageElem.setAttribute("usemap", "#sceneImageMap");
          this.$.viewerDiv.appendChild(imageElem);

          // var mapElem = document.createElement("map");
          // mapElem.setAttribute("id", "sceneImageMap");
          // mapElem.setAttribute("name", "sceneImageMap");
          // this.$.viewerDiv.appendChild(mapElem);
        }

        if (this.viewerProperties.renderer === 'IMAGE' || this.viewerProperties.renderer === 'SVG') {
          
          if (this.pickProperties != undefined && this.pickProperties.type === 'RECTANGLE') {
            var canvasElem = document.createElement("canvas");
            canvasElem.setAttribute("id", "rectCanvas");
            this.$.viewerDiv.appendChild(canvasElem);

            this.pickProperties.active = true;
            this.rectCtx = canvasElem.getContext('2d');
            this.rect = {};
          }

        }
      }
    }
    customElements.define(AvsViewer.is, AvsViewer);
  </script>

</dom-module>
